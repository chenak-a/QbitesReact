import { visit as e } from "graphql/language/visitor.mjs";

import { Kind as r } from "graphql/language/kinds.mjs";

import { print as n } from "graphql/language/printer.mjs";

import { k as t, _ as o, s as i, C as u, m as c, a as s, b as p, c as l, d, e as v, f as y } from "./7685a922.mjs";

export { C as CombinedError, f as createRequest, h as getOperationName, a as makeErrorResult, m as makeResult, g as stringifyVariables } from "./7685a922.mjs";

import { toPromise as k, take as x, filter as E, share as O, map as b, tap as w, merge as q, mergeMap as D, takeUntil as N, make as S, onPush as _, makeSubject as R, subscribe as T, onEnd as P, onStart as M, publish as A, switchMap as j, fromValue as V } from "wonka";

function collectTypes(e, r) {
  if (Array.isArray(e)) {
    for (var n = 0; n < e.length; n++) {
      collectTypes(e[n], r);
    }
  } else if ("object" == typeof e && null !== e) {
    for (var t in e) {
      if ("__typename" === t && "string" == typeof e[t]) {
        r[e[t]] = 0;
      } else {
        collectTypes(e[t], r);
      }
    }
  }
  return r;
}

function collectTypesFromResponse(e) {
  return Object.keys(collectTypes(e, {}));
}

var formatNode = function(e) {
  if (e.selectionSet && !e.selectionSet.selections.some((function(e) {
    return e.kind === r.FIELD && "__typename" === e.name.value && !e.alias;
  }))) {
    return o({}, e, {
      selectionSet: o({}, e.selectionSet, {
        selections: e.selectionSet.selections.concat([ {
          kind: r.FIELD,
          name: {
            kind: r.NAME,
            value: "__typename"
          }
        } ])
      })
    });
  }
};

var I = new Map;

function formatDocument(r) {
  var n = t(r);
  var a = I.get(n.__key);
  if (!a) {
    (a = e(n, {
      Field: formatNode,
      InlineFragment: formatNode
    })).__key = n.__key;
    I.set(n.__key, a);
  }
  return a;
}

function maskTypename(e) {
  if (!e || "object" != typeof e) {
    return e;
  }
  return Object.keys(e).reduce((function(r, n) {
    var t = e[n];
    if ("__typename" === n) {
      Object.defineProperty(r, "__typename", {
        enumerable: !1,
        value: t
      });
    } else if (Array.isArray(t)) {
      r[n] = t.map(maskTypename);
    } else if (t && "object" == typeof t && "__typename" in t) {
      r[n] = maskTypename(t);
    } else {
      r[n] = t;
    }
    return r;
  }), {});
}

function withPromise(e) {
  e.toPromise = function() {
    return k(x(1)(E((function(e) {
      return !e.stale;
    }))(e)));
  };
  return e;
}

function makeOperation(e, r, n) {
  if (!n) {
    n = r.context;
  }
  return {
    key: r.key,
    query: r.query,
    variables: r.variables,
    kind: e,
    context: n
  };
}

function addMetadata(e, r) {
  return makeOperation(e.kind, e, o({}, e.context, {
    meta: o({}, e.context.meta, r)
  }));
}

function noop() {}

function applyDefinitions(e, n, t) {
  for (var a = 0; a < t.length; a++) {
    if (t[a].kind === r.FRAGMENT_DEFINITION) {
      var o = t[a].name.value;
      var u = i(t[a]);
      if (!e.has(o)) {
        e.set(o, u);
        n.push(t[a]);
      } else if ("production" !== process.env.NODE_ENV && e.get(o) !== u) {
        console.warn("[WARNING: Duplicate Fragment] A fragment with name `" + o + "` already exists in this document.\nWhile fragment names may not be unique across your source, each name must be unique per document.");
      }
    } else {
      n.push(t[a]);
    }
  }
}

function gql() {
  var e = arguments;
  var n = new Map;
  var a = [];
  var o = [];
  var i = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || "";
  for (var u = 1; u < arguments.length; u++) {
    var c = e[u];
    if (c && c.definitions) {
      o.push.apply(o, c.definitions);
    } else {
      i += c;
    }
    i += e[0][u];
  }
  applyDefinitions(n, a, t(i).definitions);
  applyDefinitions(n, a, o);
  return t({
    kind: r.DOCUMENT,
    definitions: a
  });
}

function shouldSkip$1(e) {
  var r = e.kind;
  return "subscription" !== r && "query" !== r;
}

function ssrExchange(e) {
  var r = {};
  var n = [];
  function invalidate(e) {
    n.push(e.operation.key);
    if (1 === n.length) {
      Promise.resolve().then((function() {
        var e;
        while (e = n.shift()) {
          delete r[e];
        }
      }));
    }
  }
  function isCached(e) {
    return !shouldSkip$1(e) && void 0 !== r[e.key];
  }
  var ssr = function(n) {
    var t = n.client;
    var a = n.forward;
    return function(n) {
      var o = e && "boolean" == typeof e.isClient ? !!e.isClient : !t.suspense;
      var i = O(n);
      var c = a(E((function(e) {
        return !isCached(e);
      }))(i));
      var s = b((function(e) {
        return function deserializeResult(e, r) {
          var n = r.error;
          var t = r.data;
          return {
            operation: e,
            data: t ? JSON.parse(t) : void 0,
            extensions: void 0,
            error: n ? new u({
              networkError: n.networkError ? new Error(n.networkError) : void 0,
              graphQLErrors: n.graphQLErrors && n.graphQLErrors.length ? n.graphQLErrors : void 0
            }) : void 0
          };
        }(e, r[e.key]);
      }))(E((function(e) {
        return isCached(e);
      }))(i));
      if (!o) {
        c = w((function(e) {
          var n = e.operation;
          if (!shouldSkip$1(n)) {
            var t = function serializeResult(e) {
              var r = e.data;
              var n = e.error;
              var t = {};
              if (void 0 !== r) {
                t.data = JSON.stringify(r);
              }
              if (n) {
                t.error = {
                  graphQLErrors: n.graphQLErrors.map((function(e) {
                    if (!e.path && !e.extensions) {
                      return e.message;
                    }
                    return {
                      message: e.message,
                      path: e.path,
                      extensions: e.extensions
                    };
                  }))
                };
                if (n.networkError) {
                  t.error.networkError = "" + n.networkError;
                }
              }
              return t;
            }(e);
            r[n.key] = t;
          }
        }))(c);
      } else {
        s = w(invalidate)(s);
      }
      return q([ c, s ]);
    };
  };
  ssr.restoreData = function(e) {
    return o(r, e);
  };
  ssr.extractData = function() {
    return o({}, r);
  };
  if (e && e.initialState) {
    ssr.restoreData(e.initialState);
  }
  return ssr;
}

function shouldSkip(e) {
  var r = e.kind;
  return "mutation" !== r && "query" !== r;
}

function cacheExchange(e) {
  var r = e.forward;
  var n = e.client;
  var t = e.dispatchDebug;
  var a = new Map;
  var i = Object.create(null);
  function mapTypeNames(e) {
    var r = makeOperation(e.kind, e);
    r.query = formatDocument(e.query);
    return r;
  }
  function isOperationCached(e) {
    var r = e.context.requestPolicy;
    return "query" === e.kind && "network-only" !== r && ("cache-only" === r || a.has(e.key));
  }
  return function(e) {
    var u = O(e);
    var c = b((function(e) {
      var r = a.get(e.key);
      "production" !== process.env.NODE_ENV && t(o({}, {
        operation: e
      }, r ? {
        type: "cacheHit",
        message: "The result was successfully retried from the cache"
      } : {
        type: "cacheMiss",
        message: "The result could not be retrieved from the cache"
      }));
      var i = o({}, r, {
        operation: addMetadata(e, {
          cacheOutcome: r ? "hit" : "miss"
        })
      });
      if ("cache-and-network" === e.context.requestPolicy) {
        i.stale = !0;
        reexecuteOperation(n, e);
      }
      return i;
    }))(E((function(e) {
      return !shouldSkip(e) && isOperationCached(e);
    }))(u));
    var s = w((function(e) {
      var r = e.operation;
      if (!r) {
        return;
      }
      var o = collectTypesFromResponse(e.data).concat(r.context.additionalTypenames || []);
      if ("mutation" === e.operation.kind) {
        var u = new Set;
        "production" !== process.env.NODE_ENV && t({
          type: "cacheInvalidation",
          message: "The following typenames have been invalidated: " + o,
          operation: r,
          data: {
            typenames: o,
            response: e
          },
          source: "cacheExchange"
        });
        for (var c = 0; c < o.length; c++) {
          var s = o[c];
          var p = i[s] || (i[s] = new Set);
          p.forEach((function(e) {
            u.add(e);
          }));
          p.clear();
        }
        u.forEach((function(e) {
          if (a.has(e)) {
            r = a.get(e).operation;
            a.delete(e);
            reexecuteOperation(n, r);
          }
        }));
      } else if ("query" === r.kind && e.data) {
        a.set(r.key, e);
        for (var f = 0; f < o.length; f++) {
          var l = o[f];
          (i[l] || (i[l] = new Set)).add(r.key);
        }
      }
    }))(r(E((function(e) {
      return "query" !== e.kind || "cache-only" !== e.context.requestPolicy;
    }))(b((function(e) {
      return addMetadata(e, {
        cacheOutcome: "miss"
      });
    }))(q([ b(mapTypeNames)(E((function(e) {
      return !shouldSkip(e) && !isOperationCached(e);
    }))(u)), E((function(e) {
      return shouldSkip(e);
    }))(u) ])))));
    return q([ c, s ]);
  };
}

function reexecuteOperation(e, r) {
  return e.reexecuteOperation(makeOperation(r.kind, r, o({}, r.context, {
    requestPolicy: "network-only"
  })));
}

function subscriptionExchange(e) {
  var r = e.forwardSubscription;
  var t = e.enableAllOperations;
  return function(e) {
    var a = e.client;
    var i = e.forward;
    function isSubscriptionOperation(e) {
      var r = e.kind;
      return "subscription" === r || !!t && ("query" === r || "mutation" === r);
    }
    return function(e) {
      var t = O(e);
      var u = D((function(e) {
        var i = e.key;
        var u = E((function(e) {
          return "teardown" === e.kind && e.key === i;
        }))(t);
        return N(u)(function createSubscriptionSource(e) {
          var t = r({
            key: e.key.toString(36),
            query: n(e.query),
            variables: e.variables,
            context: o({}, e.context)
          });
          return S((function(r) {
            var n = r.next;
            var o = r.complete;
            var i = !1;
            var u;
            Promise.resolve().then((function() {
              if (i) {
                return;
              }
              u = t.subscribe({
                next: function(r) {
                  return n(c(e, r));
                },
                error: function(r) {
                  return n(s(e, r));
                },
                complete: function() {
                  if (!i) {
                    i = !0;
                    if ("subscription" === e.kind) {
                      a.reexecuteOperation(makeOperation("teardown", e, e.context));
                    }
                    o();
                  }
                }
              });
            }));
            return function() {
              i = !0;
              if (u) {
                u.unsubscribe();
              }
            };
          }));
        }(e));
      }))(E(isSubscriptionOperation)(t));
      var p = i(E((function(e) {
        return !isSubscriptionOperation(e);
      }))(t));
      return q([ u, p ]);
    };
  };
}

function debugExchange(e) {
  var r = e.forward;
  if ("production" === process.env.NODE_ENV) {
    return function(e) {
      return r(e);
    };
  } else {
    return function(e) {
      return w((function(e) {
        return console.log("[Exchange debug]: Completed operation: ", e);
      }))(r(w((function(e) {
        return console.log("[Exchange debug]: Incoming operation: ", e);
      }))(e)));
    };
  }
}

function dedupExchange(e) {
  var r = e.forward;
  var n = e.dispatchDebug;
  var t = new Set;
  function filterIncomingOperation(e) {
    var r = e.key;
    var a = e.kind;
    if ("teardown" === a) {
      t.delete(r);
      return !0;
    }
    if ("query" !== a && "subscription" !== a) {
      return !0;
    }
    var o = t.has(r);
    t.add(r);
    if (o) {
      "production" !== process.env.NODE_ENV && n({
        type: "dedup",
        message: "An operation has been deduped.",
        operation: e,
        source: "dedupExchange"
      });
    }
    return !o;
  }
  function afterOperationResult(e) {
    t.delete(e.operation.key);
  }
  return function(e) {
    var n = E(filterIncomingOperation)(e);
    return w(afterOperationResult)(r(n));
  };
}

function fetchExchange(e) {
  var r = e.forward;
  var n = e.dispatchDebug;
  return function(e) {
    var t = O(e);
    var a = D((function(e) {
      var r = e.key;
      var a = E((function(e) {
        return "teardown" === e.kind && e.key === r;
      }))(t);
      var o = p(e);
      var i = l(e, o);
      var u = d(e, o);
      "production" !== process.env.NODE_ENV && n({
        type: "fetchRequest",
        message: "A fetch request is being executed.",
        operation: e,
        data: {
          url: i,
          fetchOptions: u
        },
        source: "fetchExchange"
      });
      return _((function(r) {
        var t = !r.data ? r.error : void 0;
        "production" !== process.env.NODE_ENV && n({
          type: t ? "fetchError" : "fetchSuccess",
          message: "A " + (t ? "failed" : "successful") + " fetch response has been returned.",
          operation: e,
          data: {
            url: i,
            fetchOptions: u,
            value: t || r
          },
          source: "fetchExchange"
        });
      }))(N(a)(v(e, i, u)));
    }))(E((function(e) {
      return "query" === e.kind || "mutation" === e.kind;
    }))(t));
    var o = r(E((function(e) {
      return "query" !== e.kind && "mutation" !== e.kind;
    }))(t));
    return q([ a, o ]);
  };
}

function fallbackExchange(e) {
  var r = e.dispatchDebug;
  return function(e) {
    return E((function() {
      return !1;
    }))(w((function(e) {
      if ("teardown" !== e.kind && "production" !== process.env.NODE_ENV) {
        var n = 'No exchange has handled operations of kind "' + e.kind + "\". Check whether you've added an exchange responsible for these operations.";
        "production" !== process.env.NODE_ENV && r({
          type: "fallbackCatch",
          message: n,
          operation: e,
          source: "fallbackExchange"
        });
        console.warn(n);
      }
    }))(e));
  };
}

var Q = fallbackExchange({
  dispatchDebug: noop
});

function composeExchanges(e) {
  return function(r) {
    var n = r.client;
    var t = r.dispatchDebug;
    return e.reduceRight((function(e, r) {
      return r({
        client: n,
        forward: e,
        dispatchDebug: function dispatchDebug$1(e) {
          "production" !== process.env.NODE_ENV && t(o({}, {
            timestamp: Date.now(),
            source: r.name
          }, e));
        }
      });
    }), r.forward);
  };
}

function errorExchange(e) {
  var r = e.onError;
  return function(e) {
    var n = e.forward;
    return function(e) {
      return w((function(e) {
        var n = e.error;
        if (n) {
          r(n, e.operation);
        }
      }))(n(e));
    };
  };
}

var F = [ dedupExchange, cacheExchange, fetchExchange ];

var L = function Client(e) {
  if ("production" !== process.env.NODE_ENV && !e.url) {
    throw new Error("You are creating an urql-client without a url.");
  }
  var r = new Map;
  var n = new Map;
  var t = [];
  var a = R();
  var i = a.source;
  var u = a.next;
  var c = !1;
  function dispatchOperation(e) {
    c = !0;
    if (e) {
      u(e);
    }
    while (e = t.shift()) {
      u(e);
    }
    c = !1;
  }
  function makeResultSource(e) {
    var a = E((function(r) {
      return r.operation.kind === e.kind && r.operation.key === e.key;
    }))(m);
    if (p.maskTypename) {
      a = b((function(e) {
        return o({}, e, {
          data: maskTypename(e.data)
        });
      }))(a);
    }
    if ("mutation" === e.kind) {
      return x(1)(M((function() {
        return dispatchOperation(e);
      }))(a));
    }
    var u = O(P((function() {
      r.delete(e.key);
      n.delete(e.key);
      for (var a = t.length - 1; a >= 0; a--) {
        if (t[a].key === e.key) {
          t.splice(a, 1);
        }
      }
      dispatchOperation(makeOperation("teardown", e, e.context));
    }))(M((function() {
      n.set(e.key, u);
    }))(_((function(n) {
      r.set(e.key, n);
    }))(j((function(r) {
      if (r.stale) {
        return V(r);
      }
      return q([ V(r), b((function() {
        return o({}, r, {
          stale: !0
        });
      }))(x(1)(E((function(r) {
        return r.kind === e.kind && r.key === e.key && ("network-only" === r.context.requestPolicy || "cache-and-network" === r.context.requestPolicy);
      }))(i))) ]);
    }))(N(E((function(r) {
      return "teardown" === r.kind && r.key === e.key;
    }))(i))(a))))));
    return u;
  }
  var s = this instanceof Client ? this : Object.create(Client.prototype);
  var p = o(s, {
    url: e.url,
    fetchOptions: e.fetchOptions,
    fetch: e.fetch,
    suspense: !!e.suspense,
    requestPolicy: e.requestPolicy || "cache-first",
    preferGetMethod: !!e.preferGetMethod,
    maskTypename: !!e.maskTypename,
    operations$: i,
    reexecuteOperation: function reexecuteOperation(e) {
      if ("mutation" === e.kind || n.has(e.key)) {
        t.push(e);
        if (!c) {
          Promise.resolve().then(dispatchOperation);
        }
      }
    },
    createOperationContext: function createOperationContext(e) {
      if (!e) {
        e = {};
      }
      return o({}, {
        url: p.url,
        fetchOptions: p.fetchOptions,
        fetch: p.fetch,
        preferGetMethod: p.preferGetMethod
      }, e, {
        suspense: e.suspense || !1 !== e.suspense && p.suspense,
        requestPolicy: e.requestPolicy || p.requestPolicy
      });
    },
    createRequestOperation: function createRequestOperation(e, r, n) {
      return makeOperation(e, r, p.createOperationContext(n));
    },
    executeRequestOperation: function executeRequestOperation(e) {
      if ("mutation" === e.kind) {
        return makeResultSource(e);
      }
      var t = n.get(e.key) || makeResultSource(e);
      var a = "cache-and-network" === e.context.requestPolicy || "network-only" === e.context.requestPolicy;
      return S((function(n) {
        return T(n.next)(P(n.complete)(M((function() {
          var t = r.get(e.key);
          if ("subscription" === e.kind) {
            return dispatchOperation(e);
          } else if (a) {
            dispatchOperation(e);
          }
          if (null != t && t === r.get(e.key)) {
            n.next(a ? o({}, t, {
              stale: !0
            }) : t);
          } else if (!a) {
            dispatchOperation(e);
          }
        }))(t))).unsubscribe;
      }));
    },
    executeQuery: function executeQuery(e, r) {
      var n = p.createRequestOperation("query", e, r);
      return p.executeRequestOperation(n);
    },
    executeSubscription: function executeSubscription(e, r) {
      var n = p.createRequestOperation("subscription", e, r);
      return p.executeRequestOperation(n);
    },
    executeMutation: function executeMutation(e, r) {
      var n = p.createRequestOperation("mutation", e, r);
      return p.executeRequestOperation(n);
    },
    query: function query(e, r, n) {
      if (!n || "boolean" != typeof n.suspense) {
        n = o({}, n, {
          suspense: !1
        });
      }
      return withPromise(p.executeQuery(y(e, r), n));
    },
    readQuery: function readQuery(e, r, n) {
      var t = null;
      T((function(e) {
        t = e;
      }))(p.query(e, r, n)).unsubscribe();
      return t;
    },
    subscription: function subscription(e, r, n) {
      return p.executeSubscription(y(e, r), n);
    },
    mutation: function mutation(e, r, n) {
      return withPromise(p.executeMutation(y(e, r), n));
    }
  });
  var f = noop;
  if ("production" !== process.env.NODE_ENV) {
    var l = R();
    var d = l.next;
    var h = l.source;
    p.subscribeToDebugTarget = function(e) {
      return T(e)(h);
    };
    f = d;
  }
  var v = composeExchanges(void 0 !== e.exchanges ? e.exchanges : F);
  var m = O(v({
    client: p,
    dispatchDebug: f,
    forward: fallbackExchange({
      dispatchDebug: f
    })
  })(i));
  A(m);
  return p;
};

var G = L;

export { L as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, F as defaultExchanges, errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };
//# sourceMappingURL=urql-core.mjs.map
