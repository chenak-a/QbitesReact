{"ast":null,"code":"import { visit as e } from \"graphql/language/visitor.mjs\";\nimport { Kind as r } from \"graphql/language/kinds.mjs\";\nimport { print as n } from \"graphql/language/printer.mjs\";\nimport { k as t, _ as o, s as i, C as u, m as c, a as s, b as p, c as l, d, e as v, f as y } from \"./7685a922.mjs\";\nexport { C as CombinedError, f as createRequest, h as getOperationName, a as makeErrorResult, m as makeResult, g as stringifyVariables } from \"./7685a922.mjs\";\nimport { toPromise as k, take as x, filter as E, share as O, map as b, tap as w, merge as q, mergeMap as D, takeUntil as N, make as S, onPush as _, makeSubject as R, subscribe as T, onEnd as P, onStart as M, publish as A, switchMap as j, fromValue as V } from \"wonka\";\n\nfunction collectTypes(e, r) {\n  if (Array.isArray(e)) {\n    for (var n = 0; n < e.length; n++) {\n      collectTypes(e[n], r);\n    }\n  } else if (\"object\" == typeof e && null !== e) {\n    for (var t in e) {\n      if (\"__typename\" === t && \"string\" == typeof e[t]) {\n        r[e[t]] = 0;\n      } else {\n        collectTypes(e[t], r);\n      }\n    }\n  }\n\n  return r;\n}\n\nfunction collectTypesFromResponse(e) {\n  return Object.keys(collectTypes(e, {}));\n}\n\nvar formatNode = function (e) {\n  if (e.selectionSet && !e.selectionSet.selections.some(function (e) {\n    return e.kind === r.FIELD && \"__typename\" === e.name.value && !e.alias;\n  })) {\n    return o({}, e, {\n      selectionSet: o({}, e.selectionSet, {\n        selections: e.selectionSet.selections.concat([{\n          kind: r.FIELD,\n          name: {\n            kind: r.NAME,\n            value: \"__typename\"\n          }\n        }])\n      })\n    });\n  }\n};\n\nvar I = new Map();\n\nfunction formatDocument(r) {\n  var n = t(r);\n  var a = I.get(n.__key);\n\n  if (!a) {\n    (a = e(n, {\n      Field: formatNode,\n      InlineFragment: formatNode\n    })).__key = n.__key;\n    I.set(n.__key, a);\n  }\n\n  return a;\n}\n\nfunction maskTypename(e) {\n  if (!e || \"object\" != typeof e) {\n    return e;\n  }\n\n  return Object.keys(e).reduce(function (r, n) {\n    var t = e[n];\n\n    if (\"__typename\" === n) {\n      Object.defineProperty(r, \"__typename\", {\n        enumerable: !1,\n        value: t\n      });\n    } else if (Array.isArray(t)) {\n      r[n] = t.map(maskTypename);\n    } else if (t && \"object\" == typeof t && \"__typename\" in t) {\n      r[n] = maskTypename(t);\n    } else {\n      r[n] = t;\n    }\n\n    return r;\n  }, {});\n}\n\nfunction withPromise(e) {\n  e.toPromise = function () {\n    return k(x(1)(E(function (e) {\n      return !e.stale;\n    })(e)));\n  };\n\n  return e;\n}\n\nfunction makeOperation(e, r, n) {\n  if (!n) {\n    n = r.context;\n  }\n\n  return {\n    key: r.key,\n    query: r.query,\n    variables: r.variables,\n    kind: e,\n    context: n\n  };\n}\n\nfunction addMetadata(e, r) {\n  return makeOperation(e.kind, e, o({}, e.context, {\n    meta: o({}, e.context.meta, r)\n  }));\n}\n\nfunction noop() {}\n\nfunction applyDefinitions(e, n, t) {\n  for (var a = 0; a < t.length; a++) {\n    if (t[a].kind === r.FRAGMENT_DEFINITION) {\n      var o = t[a].name.value;\n      var u = i(t[a]);\n\n      if (!e.has(o)) {\n        e.set(o, u);\n        n.push(t[a]);\n      } else if (\"production\" !== process.env.NODE_ENV && e.get(o) !== u) {\n        console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + o + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\");\n      }\n    } else {\n      n.push(t[a]);\n    }\n  }\n}\n\nfunction gql() {\n  var e = arguments;\n  var n = new Map();\n  var a = [];\n  var o = [];\n  var i = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || \"\";\n\n  for (var u = 1; u < arguments.length; u++) {\n    var c = e[u];\n\n    if (c && c.definitions) {\n      o.push.apply(o, c.definitions);\n    } else {\n      i += c;\n    }\n\n    i += e[0][u];\n  }\n\n  applyDefinitions(n, a, t(i).definitions);\n  applyDefinitions(n, a, o);\n  return t({\n    kind: r.DOCUMENT,\n    definitions: a\n  });\n}\n\nfunction shouldSkip$1(e) {\n  var r = e.kind;\n  return \"subscription\" !== r && \"query\" !== r;\n}\n\nfunction ssrExchange(e) {\n  var r = {};\n  var n = [];\n\n  function invalidate(e) {\n    n.push(e.operation.key);\n\n    if (1 === n.length) {\n      Promise.resolve().then(function () {\n        var e;\n\n        while (e = n.shift()) {\n          delete r[e];\n        }\n      });\n    }\n  }\n\n  function isCached(e) {\n    return !shouldSkip$1(e) && void 0 !== r[e.key];\n  }\n\n  var ssr = function (n) {\n    var t = n.client;\n    var a = n.forward;\n    return function (n) {\n      var o = e && \"boolean\" == typeof e.isClient ? !!e.isClient : !t.suspense;\n      var i = O(n);\n      var c = a(E(function (e) {\n        return !isCached(e);\n      })(i));\n      var s = b(function (e) {\n        return function deserializeResult(e, r) {\n          var n = r.error;\n          var t = r.data;\n          return {\n            operation: e,\n            data: t ? JSON.parse(t) : void 0,\n            extensions: void 0,\n            error: n ? new u({\n              networkError: n.networkError ? new Error(n.networkError) : void 0,\n              graphQLErrors: n.graphQLErrors && n.graphQLErrors.length ? n.graphQLErrors : void 0\n            }) : void 0\n          };\n        }(e, r[e.key]);\n      })(E(function (e) {\n        return isCached(e);\n      })(i));\n\n      if (!o) {\n        c = w(function (e) {\n          var n = e.operation;\n\n          if (!shouldSkip$1(n)) {\n            var t = function serializeResult(e) {\n              var r = e.data;\n              var n = e.error;\n              var t = {};\n\n              if (void 0 !== r) {\n                t.data = JSON.stringify(r);\n              }\n\n              if (n) {\n                t.error = {\n                  graphQLErrors: n.graphQLErrors.map(function (e) {\n                    if (!e.path && !e.extensions) {\n                      return e.message;\n                    }\n\n                    return {\n                      message: e.message,\n                      path: e.path,\n                      extensions: e.extensions\n                    };\n                  })\n                };\n\n                if (n.networkError) {\n                  t.error.networkError = \"\" + n.networkError;\n                }\n              }\n\n              return t;\n            }(e);\n\n            r[n.key] = t;\n          }\n        })(c);\n      } else {\n        s = w(invalidate)(s);\n      }\n\n      return q([c, s]);\n    };\n  };\n\n  ssr.restoreData = function (e) {\n    return o(r, e);\n  };\n\n  ssr.extractData = function () {\n    return o({}, r);\n  };\n\n  if (e && e.initialState) {\n    ssr.restoreData(e.initialState);\n  }\n\n  return ssr;\n}\n\nfunction shouldSkip(e) {\n  var r = e.kind;\n  return \"mutation\" !== r && \"query\" !== r;\n}\n\nfunction cacheExchange(e) {\n  var r = e.forward;\n  var n = e.client;\n  var t = e.dispatchDebug;\n  var a = new Map();\n  var i = Object.create(null);\n\n  function mapTypeNames(e) {\n    var r = makeOperation(e.kind, e);\n    r.query = formatDocument(e.query);\n    return r;\n  }\n\n  function isOperationCached(e) {\n    var r = e.context.requestPolicy;\n    return \"query\" === e.kind && \"network-only\" !== r && (\"cache-only\" === r || a.has(e.key));\n  }\n\n  return function (e) {\n    var u = O(e);\n    var c = b(function (e) {\n      var r = a.get(e.key);\n      \"production\" !== process.env.NODE_ENV && t(o({}, {\n        operation: e\n      }, r ? {\n        type: \"cacheHit\",\n        message: \"The result was successfully retried from the cache\"\n      } : {\n        type: \"cacheMiss\",\n        message: \"The result could not be retrieved from the cache\"\n      }));\n      var i = o({}, r, {\n        operation: addMetadata(e, {\n          cacheOutcome: r ? \"hit\" : \"miss\"\n        })\n      });\n\n      if (\"cache-and-network\" === e.context.requestPolicy) {\n        i.stale = !0;\n        reexecuteOperation(n, e);\n      }\n\n      return i;\n    })(E(function (e) {\n      return !shouldSkip(e) && isOperationCached(e);\n    })(u));\n    var s = w(function (e) {\n      var r = e.operation;\n\n      if (!r) {\n        return;\n      }\n\n      var o = collectTypesFromResponse(e.data).concat(r.context.additionalTypenames || []);\n\n      if (\"mutation\" === e.operation.kind) {\n        var u = new Set();\n        \"production\" !== process.env.NODE_ENV && t({\n          type: \"cacheInvalidation\",\n          message: \"The following typenames have been invalidated: \" + o,\n          operation: r,\n          data: {\n            typenames: o,\n            response: e\n          },\n          source: \"cacheExchange\"\n        });\n\n        for (var c = 0; c < o.length; c++) {\n          var s = o[c];\n          var p = i[s] || (i[s] = new Set());\n          p.forEach(function (e) {\n            u.add(e);\n          });\n          p.clear();\n        }\n\n        u.forEach(function (e) {\n          if (a.has(e)) {\n            r = a.get(e).operation;\n            a.delete(e);\n            reexecuteOperation(n, r);\n          }\n        });\n      } else if (\"query\" === r.kind && e.data) {\n        a.set(r.key, e);\n\n        for (var f = 0; f < o.length; f++) {\n          var l = o[f];\n          (i[l] || (i[l] = new Set())).add(r.key);\n        }\n      }\n    })(r(E(function (e) {\n      return \"query\" !== e.kind || \"cache-only\" !== e.context.requestPolicy;\n    })(b(function (e) {\n      return addMetadata(e, {\n        cacheOutcome: \"miss\"\n      });\n    })(q([b(mapTypeNames)(E(function (e) {\n      return !shouldSkip(e) && !isOperationCached(e);\n    })(u)), E(function (e) {\n      return shouldSkip(e);\n    })(u)])))));\n    return q([c, s]);\n  };\n}\n\nfunction reexecuteOperation(e, r) {\n  return e.reexecuteOperation(makeOperation(r.kind, r, o({}, r.context, {\n    requestPolicy: \"network-only\"\n  })));\n}\n\nfunction subscriptionExchange(e) {\n  var r = e.forwardSubscription;\n  var t = e.enableAllOperations;\n  return function (e) {\n    var a = e.client;\n    var i = e.forward;\n\n    function isSubscriptionOperation(e) {\n      var r = e.kind;\n      return \"subscription\" === r || !!t && (\"query\" === r || \"mutation\" === r);\n    }\n\n    return function (e) {\n      var t = O(e);\n      var u = D(function (e) {\n        var i = e.key;\n        var u = E(function (e) {\n          return \"teardown\" === e.kind && e.key === i;\n        })(t);\n        return N(u)(function createSubscriptionSource(e) {\n          var t = r({\n            key: e.key.toString(36),\n            query: n(e.query),\n            variables: e.variables,\n            context: o({}, e.context)\n          });\n          return S(function (r) {\n            var n = r.next;\n            var o = r.complete;\n            var i = !1;\n            var u;\n            Promise.resolve().then(function () {\n              if (i) {\n                return;\n              }\n\n              u = t.subscribe({\n                next: function (r) {\n                  return n(c(e, r));\n                },\n                error: function (r) {\n                  return n(s(e, r));\n                },\n                complete: function () {\n                  if (!i) {\n                    i = !0;\n\n                    if (\"subscription\" === e.kind) {\n                      a.reexecuteOperation(makeOperation(\"teardown\", e, e.context));\n                    }\n\n                    o();\n                  }\n                }\n              });\n            });\n            return function () {\n              i = !0;\n\n              if (u) {\n                u.unsubscribe();\n              }\n            };\n          });\n        }(e));\n      })(E(isSubscriptionOperation)(t));\n      var p = i(E(function (e) {\n        return !isSubscriptionOperation(e);\n      })(t));\n      return q([u, p]);\n    };\n  };\n}\n\nfunction debugExchange(e) {\n  var r = e.forward;\n\n  if (\"production\" === process.env.NODE_ENV) {\n    return function (e) {\n      return r(e);\n    };\n  } else {\n    return function (e) {\n      return w(function (e) {\n        return console.log(\"[Exchange debug]: Completed operation: \", e);\n      })(r(w(function (e) {\n        return console.log(\"[Exchange debug]: Incoming operation: \", e);\n      })(e)));\n    };\n  }\n}\n\nfunction dedupExchange(e) {\n  var r = e.forward;\n  var n = e.dispatchDebug;\n  var t = new Set();\n\n  function filterIncomingOperation(e) {\n    var r = e.key;\n    var a = e.kind;\n\n    if (\"teardown\" === a) {\n      t.delete(r);\n      return !0;\n    }\n\n    if (\"query\" !== a && \"subscription\" !== a) {\n      return !0;\n    }\n\n    var o = t.has(r);\n    t.add(r);\n\n    if (o) {\n      \"production\" !== process.env.NODE_ENV && n({\n        type: \"dedup\",\n        message: \"An operation has been deduped.\",\n        operation: e,\n        source: \"dedupExchange\"\n      });\n    }\n\n    return !o;\n  }\n\n  function afterOperationResult(e) {\n    t.delete(e.operation.key);\n  }\n\n  return function (e) {\n    var n = E(filterIncomingOperation)(e);\n    return w(afterOperationResult)(r(n));\n  };\n}\n\nfunction fetchExchange(e) {\n  var r = e.forward;\n  var n = e.dispatchDebug;\n  return function (e) {\n    var t = O(e);\n    var a = D(function (e) {\n      var r = e.key;\n      var a = E(function (e) {\n        return \"teardown\" === e.kind && e.key === r;\n      })(t);\n      var o = p(e);\n      var i = l(e, o);\n      var u = d(e, o);\n      \"production\" !== process.env.NODE_ENV && n({\n        type: \"fetchRequest\",\n        message: \"A fetch request is being executed.\",\n        operation: e,\n        data: {\n          url: i,\n          fetchOptions: u\n        },\n        source: \"fetchExchange\"\n      });\n      return _(function (r) {\n        var t = !r.data ? r.error : void 0;\n        \"production\" !== process.env.NODE_ENV && n({\n          type: t ? \"fetchError\" : \"fetchSuccess\",\n          message: \"A \" + (t ? \"failed\" : \"successful\") + \" fetch response has been returned.\",\n          operation: e,\n          data: {\n            url: i,\n            fetchOptions: u,\n            value: t || r\n          },\n          source: \"fetchExchange\"\n        });\n      })(N(a)(v(e, i, u)));\n    })(E(function (e) {\n      return \"query\" === e.kind || \"mutation\" === e.kind;\n    })(t));\n    var o = r(E(function (e) {\n      return \"query\" !== e.kind && \"mutation\" !== e.kind;\n    })(t));\n    return q([a, o]);\n  };\n}\n\nfunction fallbackExchange(e) {\n  var r = e.dispatchDebug;\n  return function (e) {\n    return E(function () {\n      return !1;\n    })(w(function (e) {\n      if (\"teardown\" !== e.kind && \"production\" !== process.env.NODE_ENV) {\n        var n = 'No exchange has handled operations of kind \"' + e.kind + \"\\\". Check whether you've added an exchange responsible for these operations.\";\n        \"production\" !== process.env.NODE_ENV && r({\n          type: \"fallbackCatch\",\n          message: n,\n          operation: e,\n          source: \"fallbackExchange\"\n        });\n        console.warn(n);\n      }\n    })(e));\n  };\n}\n\nvar Q = fallbackExchange({\n  dispatchDebug: noop\n});\n\nfunction composeExchanges(e) {\n  return function (r) {\n    var n = r.client;\n    var t = r.dispatchDebug;\n    return e.reduceRight(function (e, r) {\n      return r({\n        client: n,\n        forward: e,\n        dispatchDebug: function dispatchDebug$1(e) {\n          \"production\" !== process.env.NODE_ENV && t(o({}, {\n            timestamp: Date.now(),\n            source: r.name\n          }, e));\n        }\n      });\n    }, r.forward);\n  };\n}\n\nfunction errorExchange(e) {\n  var r = e.onError;\n  return function (e) {\n    var n = e.forward;\n    return function (e) {\n      return w(function (e) {\n        var n = e.error;\n\n        if (n) {\n          r(n, e.operation);\n        }\n      })(n(e));\n    };\n  };\n}\n\nvar F = [dedupExchange, cacheExchange, fetchExchange];\n\nvar L = function Client(e) {\n  if (\"production\" !== process.env.NODE_ENV && !e.url) {\n    throw new Error(\"You are creating an urql-client without a url.\");\n  }\n\n  var r = new Map();\n  var n = new Map();\n  var t = [];\n  var a = R();\n  var i = a.source;\n  var u = a.next;\n  var c = !1;\n\n  function dispatchOperation(e) {\n    c = !0;\n\n    if (e) {\n      u(e);\n    }\n\n    while (e = t.shift()) {\n      u(e);\n    }\n\n    c = !1;\n  }\n\n  function makeResultSource(e) {\n    var a = E(function (r) {\n      return r.operation.kind === e.kind && r.operation.key === e.key;\n    })(m);\n\n    if (p.maskTypename) {\n      a = b(function (e) {\n        return o({}, e, {\n          data: maskTypename(e.data)\n        });\n      })(a);\n    }\n\n    if (\"mutation\" === e.kind) {\n      return x(1)(M(function () {\n        return dispatchOperation(e);\n      })(a));\n    }\n\n    var u = O(P(function () {\n      r.delete(e.key);\n      n.delete(e.key);\n\n      for (var a = t.length - 1; a >= 0; a--) {\n        if (t[a].key === e.key) {\n          t.splice(a, 1);\n        }\n      }\n\n      dispatchOperation(makeOperation(\"teardown\", e, e.context));\n    })(M(function () {\n      n.set(e.key, u);\n    })(_(function (n) {\n      r.set(e.key, n);\n    })(j(function (r) {\n      if (r.stale) {\n        return V(r);\n      }\n\n      return q([V(r), b(function () {\n        return o({}, r, {\n          stale: !0\n        });\n      })(x(1)(E(function (r) {\n        return r.kind === e.kind && r.key === e.key && (\"network-only\" === r.context.requestPolicy || \"cache-and-network\" === r.context.requestPolicy);\n      })(i)))]);\n    })(N(E(function (r) {\n      return \"teardown\" === r.kind && r.key === e.key;\n    })(i))(a))))));\n    return u;\n  }\n\n  var s = this instanceof Client ? this : Object.create(Client.prototype);\n  var p = o(s, {\n    url: e.url,\n    fetchOptions: e.fetchOptions,\n    fetch: e.fetch,\n    suspense: !!e.suspense,\n    requestPolicy: e.requestPolicy || \"cache-first\",\n    preferGetMethod: !!e.preferGetMethod,\n    maskTypename: !!e.maskTypename,\n    operations$: i,\n    reexecuteOperation: function reexecuteOperation(e) {\n      if (\"mutation\" === e.kind || n.has(e.key)) {\n        t.push(e);\n\n        if (!c) {\n          Promise.resolve().then(dispatchOperation);\n        }\n      }\n    },\n    createOperationContext: function createOperationContext(e) {\n      if (!e) {\n        e = {};\n      }\n\n      return o({}, {\n        url: p.url,\n        fetchOptions: p.fetchOptions,\n        fetch: p.fetch,\n        preferGetMethod: p.preferGetMethod\n      }, e, {\n        suspense: e.suspense || !1 !== e.suspense && p.suspense,\n        requestPolicy: e.requestPolicy || p.requestPolicy\n      });\n    },\n    createRequestOperation: function createRequestOperation(e, r, n) {\n      return makeOperation(e, r, p.createOperationContext(n));\n    },\n    executeRequestOperation: function executeRequestOperation(e) {\n      if (\"mutation\" === e.kind) {\n        return makeResultSource(e);\n      }\n\n      var t = n.get(e.key) || makeResultSource(e);\n      var a = \"cache-and-network\" === e.context.requestPolicy || \"network-only\" === e.context.requestPolicy;\n      return S(function (n) {\n        return T(n.next)(P(n.complete)(M(function () {\n          var t = r.get(e.key);\n\n          if (\"subscription\" === e.kind) {\n            return dispatchOperation(e);\n          } else if (a) {\n            dispatchOperation(e);\n          }\n\n          if (null != t && t === r.get(e.key)) {\n            n.next(a ? o({}, t, {\n              stale: !0\n            }) : t);\n          } else if (!a) {\n            dispatchOperation(e);\n          }\n        })(t))).unsubscribe;\n      });\n    },\n    executeQuery: function executeQuery(e, r) {\n      var n = p.createRequestOperation(\"query\", e, r);\n      return p.executeRequestOperation(n);\n    },\n    executeSubscription: function executeSubscription(e, r) {\n      var n = p.createRequestOperation(\"subscription\", e, r);\n      return p.executeRequestOperation(n);\n    },\n    executeMutation: function executeMutation(e, r) {\n      var n = p.createRequestOperation(\"mutation\", e, r);\n      return p.executeRequestOperation(n);\n    },\n    query: function query(e, r, n) {\n      if (!n || \"boolean\" != typeof n.suspense) {\n        n = o({}, n, {\n          suspense: !1\n        });\n      }\n\n      return withPromise(p.executeQuery(y(e, r), n));\n    },\n    readQuery: function readQuery(e, r, n) {\n      var t = null;\n      T(function (e) {\n        t = e;\n      })(p.query(e, r, n)).unsubscribe();\n      return t;\n    },\n    subscription: function subscription(e, r, n) {\n      return p.executeSubscription(y(e, r), n);\n    },\n    mutation: function mutation(e, r, n) {\n      return withPromise(p.executeMutation(y(e, r), n));\n    }\n  });\n  var f = noop;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    var l = R();\n    var d = l.next;\n    var h = l.source;\n\n    p.subscribeToDebugTarget = function (e) {\n      return T(e)(h);\n    };\n\n    f = d;\n  }\n\n  var v = composeExchanges(void 0 !== e.exchanges ? e.exchanges : F);\n  var m = O(v({\n    client: p,\n    dispatchDebug: f,\n    forward: fallbackExchange({\n      dispatchDebug: f\n    })\n  })(i));\n  A(m);\n  return p;\n};\n\nvar G = L;\nexport { L as Client, cacheExchange, composeExchanges, G as createClient, debugExchange, dedupExchange, F as defaultExchanges, errorExchange, Q as fallbackExchangeIO, fetchExchange, formatDocument, gql, makeOperation, maskTypename, ssrExchange, subscriptionExchange };","map":{"version":3,"mappings":";;;;;sBAgBMA;;AAKF,SAAKC,YAAL,CAAKA,CAAL,EAAuBC,CAAvB,EAAuBA;MAAcF;;qBAC5BG;;qCAE+B;aAC/BC;;QAELJ;;;;;;;;;;AAS+C;;;;;MAWnDK;WACOA;GADPA;aAMUA,IAAIA;oBAEIC;;gBAEJC;;;;;;MAFID;IAFJD;;;;AAiBhBG;;;MAGIC;;;;;;;;;;;SCzEOC;;;AACwC;;;;;gBAIrCC;;;;;qBAKI;;;6BAGSC;;;;;;;;;;;;qBCJEC;;;;;;;SCUtBC;;;AACiC;;;;;;;;;;;;;;AAyBzC;;;;;;SCjCKC;;AAQAP;;;wBAG0BI;;;;QAOxBI;;;;;;;;;;;AAuBNR;;MAKIS,QAAeC,GAAfD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACuCJT,qBAAqBW,CAArBX,EAAqBW;;;;;;;;;;;;;;;;;;;;;;;;YAoBLC;;cAOdnB;;;;;cAUuBoB;;oBA7DNC;;;;sBAQTC,KAAKC,KAALD,CAAKC,CAALD,IAAKC,KAAkBD;;;;;;;;OAqDRF;;OAAAA;;;;kBAeDI;;UANP;;kBAxGbC;wBACYJ;;;6BAGZC;gBACFE,EAAOF,IAAPE,GAAOF,iBAAPE;;;;;;;sBAKME,OAAOJ,SAAPI;;;;;;;;;;;;;;;;;;;;;;;;;;MAgHJC;;;;EACJC,IAAIC,WAAJD,GAAIC;WAAoBxB,EAAcoB,CAAdpB,EAAcoB,CAAdpB;GAAxBuB;;MAEIV;IACFU,SAAgBV,EAAhBU,EAAgBV,CAAhBU;;;;;;;;;;;;;;;AC9IFrB;MACMuB,MAAcC;;;;UAKCvB;;;;;;;;WAWjBwB;;oDAOsBC;;;;;YAUFb;;;;;QAOVM;QATKA;;;QAeXQ,SAAS;;;;UAKPA;;;;;;;;;;KAlBcd;;KAAAA;;;;;;;;+CAwDFe;;yBAEZT;;iCAEMU;mCAAAA;wEAAAA;sBAAAA;;;;WAAAA;;QAAAA;;;;UAWNC;;;;;;;;;;qBAWOlC;kCACsBmC;;;iBAEH,cAATC,IAAS,IAATA;;;;;;;;WA9CmB;;OAX1CC;aAGiBC,YAAYC,CAAZD,EAAYC;;MAAAA,CAAZD;KAHjBD,EAOIG;;KAAAA;;SAAAA,EAPJH;;;;;AA+EL;;;;;;;;;;;;;;;;;;qBC3CsBI;gBAEYA;UAFZC;;QALO,oBACxBF,CADwB,EACxBA;UAaIG,OAEJC,2BAAOL,GAAPK,KAAOL,CAFHI;SAdoB;QAcZ,qBA7DPE,wBA6DO,CA7DPA,CA6DO,EA7DPA;;YAFPzC;;;;;;YAWE0C;;;;;cAGEC;gBACEC;;;;;;;uBAGOC,UAALC,CAAKD,EAALC;2BACYC;;;;;;oBAOVC;;;;;;;;;mBAQM;;;;;;;;SA6BF;OATKV;;;;;;;;;ACpHnB;YAAsBd;;;qBAEfa;aAMHY;;;;yBAFsBhC;;;;;;;;;;;;;;;;;;;;cCIjB;;;oBAGHiC,KAAa;;;;;UAIHtD;;;;QAAduD;;;;;;;;;;;;;;;;;;;;ACPFnD;;UASMwC;;QAFaJ;;UAMTgB,IAAMC;UACNC,IAAYd;;OAAAA;cAIPe;;;mCAEHC;4BAAAA;qDAAAA;oBAAAA;QAJRtC;gBAAAA;;QAAAA,CAIQsC;;MAAAA;yBAYUvC;;qCAMNuC;iDAAAA;mBAGGzC,2EAHHyC;sBAAAA;;;;;WAAAA;;QAAAA;mBAcyBJ,GAAmBE;OAF1DlB;kDAOFT;KAPES;;;;;;;;ACrCFI;;SAhBAS;;;;;;;gBAYYQ;;;;;;;;;;;;;;;;;YCZRjC;;aAGakC;;;;;;;;;;;;;;;;;;;;;QCNnB;;;;;;;;;;;;ACgJA1D,iBAAqD2D,MAArD3D,CAAqD2D,CAArD3D,EAAqD2D;uBAC/CC,QAAqB/B,GAArB+B,CAAqB/B;;;;;;;;;YAUHe;MACPiB;;;SACWC;;;;;;;;;;;;;;;;;;;;;;;;;;uBAgCpBC;;;;;;YA4CSC,IAAYrC;;;;;;;;;;wBAlCLrB;KAkCP0D,IAjCFC;;;YAGGtC;;;eAcqBsC;;;;;;;0BA5BrCjE;;;SAwDYwC;;KAAAA,WAZGwB;IAefZ;;;;;IAMAlD;;IAIAgE;;;;;;;;;;;;;;;;;QAiBIC,IAAOC,EAAPD;;;eAGc;QACdzC,UADc;QANhB4B,4BAMgB;sBAAA;;MAAA;;;;;;;;8DAiBd3B;;eA2BE0C;;;;;;yBAfIC;;;iCAIAC,EAAU9C;YAGV+C;qBAC+CC;;;;;cAQnDC;;YAAAA;;;;SAhBIJ;;;;;;;sDAoCRrE;;;;;UAK0B0E;;;;;;;;;;;;;;;;2BA4BDC;aAClBC;;IAlIX7E;;;;MAyII8E,OAAOD,0CAAPC;;;;;;;;IAIFC,QAAaC,QAAbD;;;MAGIE,SACCA,CADDA,EACJlB,CADIkB;;;;;;;UAUgBjB;aAAAA;oBAAAA;;;;EAAAA;;;CAjQtBhE","names":["collectTypes","let","types","i","key","node","_extends","Kind","const","query","maskTypename","keys","value","stale","makeOperation","applyDefinitions","console","body","Map","params","ref","map","JSON","error","parse","result","data","message","restoreData","ssr","extractData","operationCache","forward","kind","requestPolicy","operation","concat","env","operations","response","typenames","merge","addMetadata","op","sharedOps$","ops$","subscriptionResults$","forward$","filter","createSubscriptionSource","Promise","sub","next","isComplete","err","makeErrorResult","complete","tap","isInFlight","type","url","makeFetchURL","fetchOptions","makeFetchBody","NODE_ENV","warn","reduceRight","Client","queue","nextOperation","shift","source","share","fromValue","reexecuteOperation","fetch","client","subscribe","onEnd","prevReplay","observer","isNetworkOperation","unsubscribe","suspense","context","withPromise","process","dispatchDebug","ref$1","exchanges"],"sources":["../src/utils/typenames.ts","../src/utils/maskTypename.ts","../src/utils/streamUtils.ts","../src/utils/operation.ts","../src/gql.ts","../src/exchanges/ssr.ts","../src/exchanges/cache.ts","../src/exchanges/subscription.ts","../src/exchanges/debug.ts","../src/exchanges/dedup.ts","../src/exchanges/fetch.ts","../src/exchanges/fallback.ts","../src/exchanges/compose.ts","../src/exchanges/error.ts","../src/client.ts"],"sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  visit,\n} from 'graphql';\n\nimport { KeyedDocumentNode, keyDocument } from './request';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (\n  obj: EntityLike | EntityLike[],\n  types: { [typename: string]: unknown }\n) => {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) collectTypes(obj[i], types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types[obj[key] as string] = 0;\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  Object.keys(collectTypes(response as EntityLike, {}));\n\nconst formatNode = (node: FieldNode | InlineFragmentNode) => {\n  if (\n    node.selectionSet &&\n    !node.selectionSet.selections.some(\n      node =>\n        node.kind === Kind.FIELD &&\n        node.name.value === '__typename' &&\n        !node.alias\n    )\n  ) {\n    return {\n      ...node,\n      selectionSet: {\n        ...node.selectionSet,\n        selections: [\n          ...(node.selectionSet.selections as SelectionNode[]),\n          {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          },\n        ],\n      },\n    };\n  }\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\nexport const formatDocument = <T extends DocumentNode>(node: T): T => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    result = visit(query, {\n      Field: formatNode,\n      InlineFragment: formatNode,\n    }) as KeyedDocumentNode;\n    // Ensure that the hash of the resulting document won't suddenly change\n    result.__key = query.__key;\n    formattedDocs.set(query.__key, result);\n  }\n\n  return (result as unknown) as T;\n};\n","export const maskTypename = (data: any): any => {\n  if (!data || typeof data !== 'object') return data;\n\n  return Object.keys(data).reduce((acc, key: string) => {\n    const value = data[key];\n    if (key === '__typename') {\n      Object.defineProperty(acc, '__typename', {\n        enumerable: false,\n        value,\n      });\n    } else if (Array.isArray(value)) {\n      acc[key] = value.map(maskTypename);\n    } else if (value && typeof value === 'object' && '__typename' in value) {\n      acc[key] = maskTypename(value);\n    } else {\n      acc[key] = value;\n    }\n\n    return acc;\n  }, {});\n};\n","import { Source, pipe, toPromise, filter, take } from 'wonka';\nimport { OperationResult, PromisifiedSource } from '../types';\n\nexport function withPromise<T extends OperationResult>(\n  source$: Source<T>\n): PromisifiedSource<T> {\n  (source$ as PromisifiedSource<T>).toPromise = () => {\n    return pipe(\n      source$,\n      filter(result => !result.stale),\n      take(1),\n      toPromise\n    );\n  };\n\n  return source$ as PromisifiedSource<T>;\n}\n","import {\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  if (!context) context = request.context;\n\n  return {\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    kind,\n    context,\n  };\n}\n\nexport { makeOperation };\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","/* eslint-disable prefer-rest-params */\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  FragmentDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { keyDocument, stringifyDocument } from './utils';\n\nconst applyDefinitions = (\n  fragmentNames: Map<string, string>,\n  target: DefinitionNode[],\n  source: Array<DefinitionNode> | ReadonlyArray<DefinitionNode>\n) => {\n  for (let i = 0; i < source.length; i++) {\n    if (source[i].kind === Kind.FRAGMENT_DEFINITION) {\n      const name = (source[i] as FragmentDefinitionNode).name.value;\n      const value = stringifyDocument(source[i]);\n      // Fragments will be deduplicated according to this Map\n      if (!fragmentNames.has(name)) {\n        fragmentNames.set(name, value);\n        target.push(source[i]);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        fragmentNames.get(name) !== value\n      ) {\n        // Fragments with the same names is expected to have the same contents\n        console.warn(\n          '[WARNING: Duplicate Fragment] A fragment with name `' +\n            name +\n            '` already exists in this document.\\n' +\n            'While fragment names may not be unique across your source, each name must be unique per document.'\n        );\n      }\n    } else {\n      target.push(source[i]);\n    }\n  }\n};\n\nfunction gql<Data = any, Variables = object>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables = object>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(/* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const interpolations: DefinitionNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(arguments[0])\n    ? arguments[0][0]\n    : arguments[0] || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      interpolations.push(...value.definitions);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  // Apply the tag's body definitions\n  applyDefinitions(fragmentNames, definitions, keyDocument(body).definitions);\n  // Copy over each interpolated document's definitions\n  applyDefinitions(fragmentNames, definitions, interpolations);\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","import { GraphQLError } from 'graphql';\nimport { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: string | undefined; // JSON string of data\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'subscription' && kind !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = {};\n\n  if (data !== undefined) {\n    result.data = JSON.stringify(data);\n  }\n\n  if (error) {\n    result.error = {\n      graphQLErrors: error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (error.networkError) {\n      result.error.networkError = '' + error.networkError;\n    }\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data: dataJson } = result;\n\n  const deserialized: OperationResult = {\n    operation,\n    data: dataJson ? JSON.parse(dataJson) : undefined,\n    extensions: undefined,\n    error: error\n      ? new CombinedError({\n          networkError: error.networkError\n            ? new Error(error.networkError)\n            : undefined,\n          graphQLErrors:\n            error.graphQLErrors && error.graphQLErrors.length\n              ? error.graphQLErrors\n              : undefined,\n        })\n      : undefined,\n  };\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) delete data[key];\n      });\n    }\n  };\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(cachedOps$, tap(invalidate));\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = formatDocument(operation.query);\n    return formattedOperation;\n  };\n\n  const isOperationCached = (operation: Operation) => {\n    const {\n      key,\n      kind,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      kind === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        const typenames = collectTypesFromResponse(response.data).concat(\n          operation.context.additionalTypenames || []\n        );\n\n        // Invalidates the cache given a mutation's response\n        if (response.operation.kind === 'mutation') {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.forEach(key => {\n              pendingOperations.add(key);\n            });\n            operations.clear();\n          }\n\n          pendingOperations.forEach(key => {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          });\n          // Mark typenames on typenameInvalidate for early invalidation\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult, makeOperation } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: Record<string, unknown>;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n\n  /** This flag may be turned on to allow your subscriptions-transport to handle all operation types */\n  enableAllOperations?: boolean;\n}\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n      let sub;\n\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n\n        sub = observableish.subscribe({\n          next: result => next(makeResult(operation, result)),\n          error: err => next(makeErrorResult(operation, err)),\n          complete: () => {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.kind === 'subscription') {\n                client.reexecuteOperation(\n                  makeOperation('teardown', operation, operation.context)\n                );\n              }\n\n              complete();\n            }\n          },\n        });\n      });\n\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n\n  const isSubscriptionOperation = (operation: Operation): boolean => {\n    const { kind } = operation;\n    return (\n      kind === 'subscription' ||\n      (!!enableAllOperations && (kind === 'query' || kind === 'mutation'))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward, dispatchDebug }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, kind } = operation;\n    if (kind === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    }\n\n    if (kind !== 'query' && kind !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n\n    if (isInFlight) {\n      dispatchDebug({\n        type: 'dedup',\n        message: 'An operation has been deduped.',\n        operation,\n      });\n    }\n\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, share, takeUntil, onPush } from 'wonka';\n\nimport { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind === 'query' || operation.kind === 'mutation';\n      }),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        return pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(teardown$),\n          onPush(result => {\n            const error = !result.data ? result.error : undefined;\n\n            dispatchDebug({\n              type: error ? 'fetchError' : 'fetchSuccess',\n              message: `A ${\n                error ? 'failed' : 'successful'\n              } fetch response has been returned.`,\n              operation,\n              data: {\n                url,\n                fetchOptions,\n                value: error || result,\n              },\n            });\n          })\n        );\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind !== 'query' && operation.kind !== 'mutation';\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Operation, ExchangeIO, ExchangeInput } from '../types';\nimport { noop } from '../utils';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO = ({\n  dispatchDebug,\n}) => ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(operation => {\n      if (\n        operation.kind !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n        dispatchDebug({\n          type: 'fallbackCatch',\n          message,\n          operation,\n        });\n        console.warn(message);\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n\nexport const fallbackExchangeIO: ExchangeIO = fallbackExchange({\n  dispatchDebug: noop,\n});\n","import { Exchange, ExchangeInput } from '../types';\n\n/** This composes an array of Exchanges into a single ExchangeIO function */\nexport const composeExchanges = (exchanges: Exchange[]) => ({\n  client,\n  forward,\n  dispatchDebug,\n}: ExchangeInput) =>\n  exchanges.reduceRight(\n    (forward, exchange) =>\n      exchange({\n        client,\n        forward,\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      }),\n    forward\n  );\n","import { pipe, tap } from 'wonka';\nimport { Exchange, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport const errorExchange = ({\n  onError,\n}: {\n  onError: (error: CombinedError, operation: Operation) => void;\n}): Exchange => ({ forward }) => ops$ => {\n  return pipe(\n    forward(ops$),\n    tap(({ error, operation }) => {\n      if (error) {\n        onError(error, operation);\n      }\n    })\n  );\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport {\n  filter,\n  make,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n  Subscription,\n} from 'wonka';\n\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { DocumentNode } from 'graphql';\n\nimport { composeExchanges, defaultExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport {\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n} from './utils';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n  /** Use HTTP GET for queries. */\n  preferGetMethod?: boolean;\n  /** Mask __typename from results. */\n  maskTypename?: boolean;\n}\n\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  operations$: Source<Operation>;\n\n  /** Start an operation from an exchange */\n  reexecuteOperation: (operation: Operation) => void;\n  /** Event target for monitoring, e.g. for @urql/devtools */\n  subscribeToDebugTarget?: (onEvent: (e: DebugEvent) => void) => Subscription;\n\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  suspense: boolean;\n  requestPolicy: RequestPolicy;\n  preferGetMethod: boolean;\n  maskTypename: boolean;\n\n  createOperationContext(\n    opts?: Partial<OperationContext> | undefined\n  ): OperationContext;\n\n  createRequestOperation<Data = any, Variables = object>(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation<Data = any, Variables = object>(\n    operation: Operation<Data, Variables>\n  ): Source<OperationResult<Data, Variables>>;\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  readQuery<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  executeQuery<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  subscription<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>>;\n\n  executeSubscription<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>>;\n\n  executeMutation<Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Source<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const queue: Operation[] = [];\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const { source: operations$, next: nextOperation } = makeSubject<Operation>();\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    isOperationBatchActive = true;\n    if (operation) nextOperation(operation);\n    while ((operation = queue.shift())) nextOperation(operation);\n    isOperationBatchActive = false;\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      filter(\n        (res: OperationResult) =>\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key\n      )\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (client.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data) }))\n      );\n    }\n\n    // A mutation is always limited to just a single result and is never shared\n    if (operation.kind === 'mutation') {\n      return pipe(\n        result$,\n        onStart(() => dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const source = pipe(\n      result$,\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations$,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      ),\n      switchMap(result => {\n        if (result.stale) {\n          return fromValue(result);\n        }\n\n        return merge([\n          fromValue(result),\n          // Mark a result as stale when a new operation is sent for it\n          pipe(\n            operations$,\n            filter(op => {\n              return (\n                op.kind === operation.kind &&\n                op.key === operation.key &&\n                (op.context.requestPolicy === 'network-only' ||\n                  op.context.requestPolicy === 'cache-and-network')\n              );\n            }),\n            take(1),\n            map(() => ({ ...result, stale: true }))\n          ),\n        ]);\n      }),\n      onPush(result => {\n        replays.set(operation.key, result);\n      }),\n      onStart(() => {\n        active.set(operation.key, source);\n      }),\n      onEnd(() => {\n        // Delete the active operation handle\n        replays.delete(operation.key);\n        active.delete(operation.key);\n        // Delete all queued up operations of the same key on end\n        for (let i = queue.length - 1; i >= 0; i--)\n          if (queue[i].key === operation.key) queue.splice(i, 1);\n        // Dispatch a teardown signal for the stopped operation\n        dispatchOperation(\n          makeOperation('teardown', operation, operation.context)\n        );\n      }),\n      share\n    );\n\n    return source;\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    url: opts.url,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    suspense: !!opts.suspense,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n    preferGetMethod: !!opts.preferGetMethod,\n    maskTypename: !!opts.maskTypename,\n\n    operations$,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'mutation' || active.has(operation.key)) {\n        queue.push(operation);\n        if (!isOperationBatchActive) {\n          Promise.resolve().then(dispatchOperation);\n        }\n      }\n    },\n\n    createOperationContext(opts) {\n      if (!opts) opts = {};\n\n      return {\n        url: client.url,\n        fetchOptions: client.fetchOptions,\n        fetch: client.fetch,\n        preferGetMethod: client.preferGetMethod,\n        ...opts,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n        requestPolicy: opts.requestPolicy || client.requestPolicy,\n      };\n    },\n\n    createRequestOperation(kind, request, opts) {\n      return makeOperation(kind, request, client.createOperationContext(opts));\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return makeResultSource(operation);\n      }\n\n      const source = active.get(operation.key) || makeResultSource(operation);\n\n      const isNetworkOperation =\n        operation.context.requestPolicy === 'cache-and-network' ||\n        operation.context.requestPolicy === 'network-only';\n\n      return make(observer => {\n        return pipe(\n          source,\n          onStart(() => {\n            const prevReplay = replays.get(operation.key);\n\n            if (operation.kind === 'subscription') {\n              return dispatchOperation(operation);\n            } else if (isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n\n            if (\n              prevReplay != null &&\n              prevReplay === replays.get(operation.key)\n            ) {\n              observer.next(\n                isNetworkOperation ? { ...prevReplay, stale: true } : prevReplay\n              );\n            } else if (!isNetworkOperation) {\n              dispatchOperation(operation);\n            }\n          }),\n          onEnd(observer.complete),\n          subscribe(observer.next)\n        ).unsubscribe;\n      });\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    query(query, variables, context) {\n      if (!context || typeof context.suspense !== 'boolean') {\n        context = { ...context, suspense: false };\n      }\n\n      return withPromise(\n        client.executeQuery(createRequest(query, variables), context)\n      );\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return withPromise(\n        client.executeMutation(createRequest(query, variables), context)\n      );\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  const exchanges =\n    opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations$)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\nexport const createClient = (Client as any) as (opts: ClientOptions) => Client;\n"]},"metadata":{},"sourceType":"module"}