{"ast":null,"code":"import { createClient as e, createRequest as t } from \"@urql/core\";\nexport * from \"@urql/core\";\nimport { createContext as n, useContext as r, useRef as u, useState as i, useCallback as a, useEffect as o, useMemo as c } from \"react\";\nimport { toPromise as s, subscribe as f, onPush as l, takeWhile as v, onEnd as p } from \"wonka\";\nvar d = e({\n  url: \"/graphql\"\n});\nvar x = n(d);\nvar h = x.Provider;\nvar y = x.Consumer;\nx.displayName = \"UrqlContext\";\nvar g = !1;\n\nfunction useClient() {\n  var e = r(x);\n\n  if (\"production\" !== process.env.NODE_ENV && e === d && !g) {\n    g = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return e;\n}\n\nfunction _extends() {\n  return (_extends = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var n = arguments[t];\n\n      for (var r in n) {\n        if (Object.prototype.hasOwnProperty.call(n, r)) {\n          e[r] = n[r];\n        }\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nvar b = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0,\n  operation: void 0\n};\n\nfunction computeNextState(e, t) {\n  var n = _extends({}, e, t, {\n    fetching: !!t.fetching,\n    stale: !!t.stale\n  });\n\n  return function isShallowDifferent(e, t) {\n    if (\"object\" != typeof e || \"object\" != typeof t) {\n      return e !== t;\n    }\n\n    for (var n in e) {\n      if (!(n in t)) {\n        return !0;\n      }\n    }\n\n    for (var r in t) {\n      if (e[r] !== t[r]) {\n        return !0;\n      }\n    }\n\n    return !1;\n  }(e, n) ? n : e;\n}\n\nfunction hasDepsChanged(e, t) {\n  for (var n = 0, r = t.length; n < r; n++) {\n    if (e[n] !== t[n]) {\n      return !0;\n    }\n  }\n\n  return !1;\n}\n\nfunction useMutation(e) {\n  var n = u(!0);\n  var r = useClient();\n  var c = i(b);\n  var f = c[0];\n  var l = c[1];\n  var v = a(function (u, i) {\n    l(_extends({}, b, {\n      fetching: !0\n    }));\n    return s(r.executeMutation(t(e, u), i || {})).then(function (e) {\n      if (n.current) {\n        l({\n          fetching: !1,\n          stale: !!e.stale,\n          data: e.data,\n          error: e.error,\n          extensions: e.extensions,\n          operation: e.operation\n        });\n      }\n\n      return e;\n    });\n  }, [r, e, l]);\n  o(function () {\n    return function () {\n      n.current = !1;\n    };\n  }, []);\n  return [f, v];\n}\n\nfunction useRequest(e, n) {\n  var r = u(void 0);\n  return c(function () {\n    var u = t(e, n);\n\n    if (void 0 !== r.current && r.current.key === u.key) {\n      return r.current;\n    } else {\n      r.current = u;\n      return u;\n    }\n  }, [e, n]);\n}\n\nvar q = !1;\n\nfunction useQuery(e) {\n  var t = useClient();\n\n  var n = function getCacheForClient(e) {\n    if (!e._react) {\n      var t = new Set();\n      var n = new Map();\n\n      if (e.operations$) {\n        f(function (e) {\n          if (\"teardown\" === e.kind && t.has(e.key)) {\n            t.delete(e.key);\n            n.delete(e.key);\n          }\n        })(e.operations$);\n      }\n\n      e._react = {\n        get: function get(e) {\n          return n.get(e);\n        },\n        set: function set(e, r) {\n          t.delete(e);\n          n.set(e, r);\n        },\n        dispose: function dispose(e) {\n          t.add(e);\n        }\n      };\n    }\n\n    return e._react;\n  }(t);\n\n  var r = function isSuspense(e, t) {\n    return e.suspense && (!t || !1 !== t.suspense);\n  }(t, e.context);\n\n  var u = useRequest(e.query, e.variables);\n  var s = c(function () {\n    if (e.pause) {\n      return null;\n    }\n\n    var i = t.executeQuery(u, _extends({}, {\n      requestPolicy: e.requestPolicy\n    }, e.context));\n    return r ? l(function (e) {\n      n.set(u.key, e);\n    })(i) : i;\n  }, [n, t, u, r, e.pause, e.requestPolicy, e.context]);\n  var d = a(function (e, t) {\n    if (!e) {\n      return {\n        fetching: !1\n      };\n    }\n\n    var r = n.get(u.key);\n\n    if (!r) {\n      var i;\n      var a = f(function (e) {\n        r = e;\n\n        if (i) {\n          i(r);\n        }\n      })(v(function () {\n        return t && !i || !r;\n      })(e));\n\n      if (null == r && t) {\n        var o = new Promise(function (e) {\n          i = e;\n        });\n        n.set(u.key, o);\n        throw o;\n      } else {\n        a.unsubscribe();\n      }\n    } else if (t && null != r && \"then\" in r) {\n      throw r;\n    }\n\n    return r || {\n      fetching: !0\n    };\n  }, [n, u]);\n  var x = [t, u, e.requestPolicy, e.context, e.pause];\n  var h = i(function () {\n    q = !0;\n\n    try {\n      return [s, computeNextState(b, d(s, r)), x];\n    } finally {\n      q = !1;\n    }\n  });\n  var y = h[0];\n  var g = h[1];\n  var m = y[1];\n\n  if (s !== y[0] && hasDepsChanged(y[2], x)) {\n    g([s, m = computeNextState(y[1], d(s, r)), x]);\n  }\n\n  o(function () {\n    var e = y[0];\n    var t = y[2][1];\n    var r = !1;\n\n    function updateResult(e) {\n      r = !0;\n\n      if (!q) {\n        g(function (t) {\n          var n = computeNextState(t[1], e);\n          return t[1] !== n ? [t[0], n, t[2]] : t;\n        });\n      }\n    }\n\n    if (e) {\n      var u = f(updateResult)(p(function () {\n        updateResult({\n          fetching: !1\n        });\n      })(e));\n\n      if (!r) {\n        updateResult({\n          fetching: !0\n        });\n      }\n\n      return function () {\n        n.dispose(t.key);\n        u.unsubscribe();\n      };\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [n, y[0], y[2][1]]);\n  return [m, a(function (i) {\n    var a = _extends({}, {\n      requestPolicy: e.requestPolicy\n    }, e.context, i);\n\n    g(function (e) {\n      return [r ? l(function (e) {\n        n.set(u.key, e);\n      })(t.executeQuery(u, a)) : t.executeQuery(u, a), e[1], e[2]];\n    });\n  }, [t, n, u, r, d, e.requestPolicy, e.context])];\n}\n\nfunction useSubscription(e, t) {\n  var n = useClient();\n  var r = useRequest(e.query, e.variables);\n  var s = u(t);\n  s.current = t;\n  var l = c(function () {\n    return !e.pause ? n.executeSubscription(r, e.context) : null;\n  }, [n, r, e.pause, e.context]);\n  var v = [n, r, e.context, e.pause];\n  var d = i(function () {\n    return [l, _extends({}, b, {\n      fetching: !!l\n    }), v];\n  });\n  var x = d[0];\n  var h = d[1];\n  var y = x[1];\n\n  if (l !== x[0] && hasDepsChanged(x[2], v)) {\n    h([l, y = computeNextState(x[1], {\n      fetching: !!l\n    }), v]);\n  }\n\n  o(function () {\n    function updateResult(e) {\n      h(function (t) {\n        var n = computeNextState(t[1], e);\n\n        if (t[1] === n) {\n          return t;\n        }\n\n        if (s.current && t[1].data !== n.data) {\n          n.data = s.current(t[1].data, n.data);\n        }\n\n        return [t[0], n, t[2]];\n      });\n    }\n\n    if (x[0]) {\n      return f(updateResult)(p(function () {\n        updateResult({\n          fetching: !1\n        });\n      })(x[0])).unsubscribe;\n    } else {\n      updateResult({\n        fetching: !1\n      });\n    }\n  }, [x[0]]);\n  return [y, a(function (t) {\n    var u = n.executeSubscription(r, _extends({}, e.context, t));\n    h(function (e) {\n      return [u, e[1], e[2]];\n    });\n  }, [n, e.context, r])];\n}\n\nfunction Mutation(e) {\n  var t = useMutation(e.query);\n  return e.children(_extends({}, t[0], {\n    executeMutation: t[1]\n  }));\n}\n\nfunction Query(e) {\n  var t = useQuery(e);\n  return e.children(_extends({}, t[0], {\n    executeQuery: t[1]\n  }));\n}\n\nfunction Subscription(e) {\n  var t = useSubscription(e, e.handler);\n  return e.children(_extends({}, t[0], {\n    executeSubscription: t[1]\n  }));\n}\n\nexport { y as Consumer, x as Context, Mutation, h as Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":{"version":3,"sources":["../src/context.ts","../src/hooks/state.ts","../src/hooks/useMutation.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/cache.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"names":["url","Context","Consumer","let","hasWarnedAboutDefault","fetching","stale","undefined","error","data","extensions","b","prevState","hasDepsChanged","a","i","l","length","useMutation","query","isMounted","useRef","client","useClient","useState","initialState","executeMutation","useCallback","variables","context","setState","_extends","createRequest","toPromise","then","result","current","operation","useEffect","state","useRequest","prev","useMemo","request","key","isSuspense","suspense","currentInit","const","cache","getCacheForClient","source","pause","getSnapshot","subscription","promise","deps","currentResult","hasResult","computeNextState","nextResult","executeQuery","opts","_react","reclaim","Set","map","Map","operations$","subscribe","kind","has","delete","get","set","value","dispose","add","handlerRef","args","useQuery","executeSubscription","handler"],"mappings":"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","sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\nContext.displayName = 'UrqlContext';\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\ninterface Stateish {\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState = {\n    ...prevState,\n    ...result,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './state';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nlet currentInit = false;\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  const source = useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = useState(() => {\n    currentInit = true;\n    try {\n      return [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const;\n    } finally {\n      currentInit = false;\n    }\n  });\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      if (!currentInit) {\n        setState(state => {\n          const nextResult = computeNextState(state[1], result);\n          return state[1] !== nextResult\n            ? [state[0], nextResult, state[2]]\n            : state;\n        });\n      }\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      setState(state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], state[2]];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      getSnapshot,\n      args.requestPolicy,\n      args.context,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { DocumentNode } from 'graphql';\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport { useEffect, useState, useCallback, useMemo, useRef } from 'react';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  const handlerRef = useRef<SubscriptionHandler<Data, Result> | undefined>(\n    handler\n  );\n  handlerRef.current = handler;\n\n  const source = useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      setState(state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      setState(state => [source, state[1], state[2]]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"]},"metadata":{},"sourceType":"module"}