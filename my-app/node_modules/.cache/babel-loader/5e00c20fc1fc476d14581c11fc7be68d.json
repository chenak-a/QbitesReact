{"ast":null,"code":"import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport { quadtree } from \"d3-quadtree\";\nimport { x, y } from \"./simulation\";\nexport default function () {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i,\n        n = nodes.length,\n        tree = quadtree(nodes, x, y).visitAfter(accumulate);\n\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i,\n        n = nodes.length,\n        node;\n    strengths = new Array(n);\n\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0,\n        q,\n        c,\n        weight = 0,\n        x,\n        y,\n        i; // For internal nodes, accumulate forces from child quadrants.\n\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n\n      quad.x = x / weight;\n      quad.y = y / weight;\n    } // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n\n      do strength += strengths[q.data.index]; while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y; // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n\n      return true;\n    } // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident.\n\n\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function (_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function (_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function (_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function (_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function (_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}","map":{"version":3,"names":["constant","jiggle","quadtree","x","y","nodes","node","alpha","strength","strengths","distanceMin2","distanceMax2","Infinity","theta2","force","_","i","n","length","tree","visitAfter","accumulate","visit","apply","initialize","Array","index","quad","q","c","weight","Math","abs","value","data","next","x1","x2","w","l","sqrt","vx","vy","arguments","distanceMin","distanceMax","theta"],"sources":["/home/chenak/QbitesReact/my-app/node_modules/d3-force/src/manyBody.js"],"sourcesContent":["import constant from \"./constant\";\nimport jiggle from \"./jiggle\";\nimport {quadtree} from \"d3-quadtree\";\nimport {x, y} from \"./simulation\";\n\nexport default function() {\n  var nodes,\n      node,\n      alpha,\n      strength = constant(-30),\n      strengths,\n      distanceMin2 = 1,\n      distanceMax2 = Infinity,\n      theta2 = 0.81;\n\n  function force(_) {\n    var i, n = nodes.length, tree = quadtree(nodes, x, y).visitAfter(accumulate);\n    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);\n  }\n\n  function initialize() {\n    if (!nodes) return;\n    var i, n = nodes.length, node;\n    strengths = new Array(n);\n    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);\n  }\n\n  function accumulate(quad) {\n    var strength = 0, q, c, weight = 0, x, y, i;\n\n    // For internal nodes, accumulate forces from child quadrants.\n    if (quad.length) {\n      for (x = y = i = 0; i < 4; ++i) {\n        if ((q = quad[i]) && (c = Math.abs(q.value))) {\n          strength += q.value, weight += c, x += c * q.x, y += c * q.y;\n        }\n      }\n      quad.x = x / weight;\n      quad.y = y / weight;\n    }\n\n    // For leaf nodes, accumulate forces from coincident quadrants.\n    else {\n      q = quad;\n      q.x = q.data.x;\n      q.y = q.data.y;\n      do strength += strengths[q.data.index];\n      while (q = q.next);\n    }\n\n    quad.value = strength;\n  }\n\n  function apply(quad, x1, _, x2) {\n    if (!quad.value) return true;\n\n    var x = quad.x - node.x,\n        y = quad.y - node.y,\n        w = x2 - x1,\n        l = x * x + y * y;\n\n    // Apply the Barnes-Hut approximation if possible.\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (w * w / theta2 < l) {\n      if (l < distanceMax2) {\n        if (x === 0) x = jiggle(), l += x * x;\n        if (y === 0) y = jiggle(), l += y * y;\n        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n        node.vx += x * quad.value * alpha / l;\n        node.vy += y * quad.value * alpha / l;\n      }\n      return true;\n    }\n\n    // Otherwise, process points directly.\n    else if (quad.length || l >= distanceMax2) return;\n\n    // Limit forces for very close nodes; randomize direction if coincident.\n    if (quad.data !== node || quad.next) {\n      if (x === 0) x = jiggle(), l += x * x;\n      if (y === 0) y = jiggle(), l += y * y;\n      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);\n    }\n\n    do if (quad.data !== node) {\n      w = strengths[quad.data.index] * alpha / l;\n      node.vx += x * w;\n      node.vy += y * w;\n    } while (quad = quad.next);\n  }\n\n  force.initialize = function(_) {\n    nodes = _;\n    initialize();\n  };\n\n  force.strength = function(_) {\n    return arguments.length ? (strength = typeof _ === \"function\" ? _ : constant(+_), initialize(), force) : strength;\n  };\n\n  force.distanceMin = function(_) {\n    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);\n  };\n\n  force.distanceMax = function(_) {\n    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);\n  };\n\n  force.theta = function(_) {\n    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);\n  };\n\n  return force;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}