{"ast":null,"code":"// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function (global) {\n  'use strict'; // If we're in node require encoding-indexes and attach it to the global.\n\n  if (typeof module !== \"undefined\" && module.exports && !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] = require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  } //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n\n\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n\n\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n\n\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n    // 1. Let S be the DOMString value.\n    var s = String(string); // 2. Let n be the length of S.\n\n    var n = s.length; // 3. Initialize i to 0.\n\n    var i = 0; // 4. Initialize U to be an empty sequence of Unicode characters.\n\n    var u = []; // 5. While i < n:\n\n    while (i < n) {\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i); // 2. Depending on the value of c:\n      // c < 0xD800 or c > 0xDFFF\n\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      } // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n          // Append to U a U+FFFD REPLACEMENT CHARACTER.\n          u.push(0xFFFD);\n        } // 0xD800 ≤ c ≤ 0xDBFF\n        else if (0xD800 <= c && c <= 0xDBFF) {\n            // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n            // CHARACTER.\n            if (i === n - 1) {\n              u.push(0xFFFD);\n            } // 2. Otherwise, i < n−1:\n            else {\n                // 1. Let d be the code unit in S at index i+1.\n                var d = s.charCodeAt(i + 1); // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n\n                if (0xDC00 <= d && d <= 0xDFFF) {\n                  // 1. Let a be c & 0x3FF.\n                  var a = c & 0x3FF; // 2. Let b be d & 0x3FF.\n\n                  var b = d & 0x3FF; // 3. Append to U the Unicode character with code point\n                  // 2^16+2^10*a+b.\n\n                  u.push(0x10000 + (a << 10) + b); // 4. Set i to i+1.\n\n                  i += 1;\n                } // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n                // U+FFFD REPLACEMENT CHARACTER.\n                else {\n                    u.push(0xFFFD);\n                  }\n              }\n          } // 3. Set i to i+1.\n\n\n      i += 1;\n    } // 6. Return U.\n\n\n    return u;\n  }\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n\n\n  function codePointsToString(code_points) {\n    var s = '';\n\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);\n      }\n    }\n\n    return s;\n  } //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n\n\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n\n\n  var isASCIICodePoint = isASCIIByte;\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */\n\n  var end_of_stream = -1;\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens); // Reversed as push/pop is more efficient than shift/unshift.\n\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function () {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n    read: function () {\n      if (!this.tokens.length) return end_of_stream;\n      return this.tokens.pop();\n    },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function (token) {\n      if (Array.isArray(token)) {\n        var tokens =\n        /**@type {!Array.<number>}*/\n        token;\n\n        while (tokens.length) this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function (token) {\n      if (Array.isArray(token)) {\n        var tokens =\n        /**@type {!Array.<number>}*/\n        token;\n\n        while (tokens.length) this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  }; //\n  // 5. Encodings\n  //\n  // 5.1 Encoders and decoders\n\n  /** @const */\n\n  var finished = -1;\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n\n  function decoderError(fatal, opt_code_point) {\n    if (fatal) throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n\n\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n  /** @interface */\n\n\n  function Decoder() {}\n\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function (stream, bite) {}\n  };\n  /** @interface */\n\n  function Encoder() {}\n\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function (stream, code_point) {}\n  }; // 5.2 Names and labels\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase(); // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n\n    return null;\n  }\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n\n\n  var encodings = [{\n    \"encodings\": [{\n      \"labels\": [\"unicode-1-1-utf-8\", \"utf-8\", \"utf8\"],\n      \"name\": \"UTF-8\"\n    }],\n    \"heading\": \"The Encoding\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"866\", \"cp866\", \"csibm866\", \"ibm866\"],\n      \"name\": \"IBM866\"\n    }, {\n      \"labels\": [\"csisolatin2\", \"iso-8859-2\", \"iso-ir-101\", \"iso8859-2\", \"iso88592\", \"iso_8859-2\", \"iso_8859-2:1987\", \"l2\", \"latin2\"],\n      \"name\": \"ISO-8859-2\"\n    }, {\n      \"labels\": [\"csisolatin3\", \"iso-8859-3\", \"iso-ir-109\", \"iso8859-3\", \"iso88593\", \"iso_8859-3\", \"iso_8859-3:1988\", \"l3\", \"latin3\"],\n      \"name\": \"ISO-8859-3\"\n    }, {\n      \"labels\": [\"csisolatin4\", \"iso-8859-4\", \"iso-ir-110\", \"iso8859-4\", \"iso88594\", \"iso_8859-4\", \"iso_8859-4:1988\", \"l4\", \"latin4\"],\n      \"name\": \"ISO-8859-4\"\n    }, {\n      \"labels\": [\"csisolatincyrillic\", \"cyrillic\", \"iso-8859-5\", \"iso-ir-144\", \"iso8859-5\", \"iso88595\", \"iso_8859-5\", \"iso_8859-5:1988\"],\n      \"name\": \"ISO-8859-5\"\n    }, {\n      \"labels\": [\"arabic\", \"asmo-708\", \"csiso88596e\", \"csiso88596i\", \"csisolatinarabic\", \"ecma-114\", \"iso-8859-6\", \"iso-8859-6-e\", \"iso-8859-6-i\", \"iso-ir-127\", \"iso8859-6\", \"iso88596\", \"iso_8859-6\", \"iso_8859-6:1987\"],\n      \"name\": \"ISO-8859-6\"\n    }, {\n      \"labels\": [\"csisolatingreek\", \"ecma-118\", \"elot_928\", \"greek\", \"greek8\", \"iso-8859-7\", \"iso-ir-126\", \"iso8859-7\", \"iso88597\", \"iso_8859-7\", \"iso_8859-7:1987\", \"sun_eu_greek\"],\n      \"name\": \"ISO-8859-7\"\n    }, {\n      \"labels\": [\"csiso88598e\", \"csisolatinhebrew\", \"hebrew\", \"iso-8859-8\", \"iso-8859-8-e\", \"iso-ir-138\", \"iso8859-8\", \"iso88598\", \"iso_8859-8\", \"iso_8859-8:1988\", \"visual\"],\n      \"name\": \"ISO-8859-8\"\n    }, {\n      \"labels\": [\"csiso88598i\", \"iso-8859-8-i\", \"logical\"],\n      \"name\": \"ISO-8859-8-I\"\n    }, {\n      \"labels\": [\"csisolatin6\", \"iso-8859-10\", \"iso-ir-157\", \"iso8859-10\", \"iso885910\", \"l6\", \"latin6\"],\n      \"name\": \"ISO-8859-10\"\n    }, {\n      \"labels\": [\"iso-8859-13\", \"iso8859-13\", \"iso885913\"],\n      \"name\": \"ISO-8859-13\"\n    }, {\n      \"labels\": [\"iso-8859-14\", \"iso8859-14\", \"iso885914\"],\n      \"name\": \"ISO-8859-14\"\n    }, {\n      \"labels\": [\"csisolatin9\", \"iso-8859-15\", \"iso8859-15\", \"iso885915\", \"iso_8859-15\", \"l9\"],\n      \"name\": \"ISO-8859-15\"\n    }, {\n      \"labels\": [\"iso-8859-16\"],\n      \"name\": \"ISO-8859-16\"\n    }, {\n      \"labels\": [\"cskoi8r\", \"koi\", \"koi8\", \"koi8-r\", \"koi8_r\"],\n      \"name\": \"KOI8-R\"\n    }, {\n      \"labels\": [\"koi8-ru\", \"koi8-u\"],\n      \"name\": \"KOI8-U\"\n    }, {\n      \"labels\": [\"csmacintosh\", \"mac\", \"macintosh\", \"x-mac-roman\"],\n      \"name\": \"macintosh\"\n    }, {\n      \"labels\": [\"dos-874\", \"iso-8859-11\", \"iso8859-11\", \"iso885911\", \"tis-620\", \"windows-874\"],\n      \"name\": \"windows-874\"\n    }, {\n      \"labels\": [\"cp1250\", \"windows-1250\", \"x-cp1250\"],\n      \"name\": \"windows-1250\"\n    }, {\n      \"labels\": [\"cp1251\", \"windows-1251\", \"x-cp1251\"],\n      \"name\": \"windows-1251\"\n    }, {\n      \"labels\": [\"ansi_x3.4-1968\", \"ascii\", \"cp1252\", \"cp819\", \"csisolatin1\", \"ibm819\", \"iso-8859-1\", \"iso-ir-100\", \"iso8859-1\", \"iso88591\", \"iso_8859-1\", \"iso_8859-1:1987\", \"l1\", \"latin1\", \"us-ascii\", \"windows-1252\", \"x-cp1252\"],\n      \"name\": \"windows-1252\"\n    }, {\n      \"labels\": [\"cp1253\", \"windows-1253\", \"x-cp1253\"],\n      \"name\": \"windows-1253\"\n    }, {\n      \"labels\": [\"cp1254\", \"csisolatin5\", \"iso-8859-9\", \"iso-ir-148\", \"iso8859-9\", \"iso88599\", \"iso_8859-9\", \"iso_8859-9:1989\", \"l5\", \"latin5\", \"windows-1254\", \"x-cp1254\"],\n      \"name\": \"windows-1254\"\n    }, {\n      \"labels\": [\"cp1255\", \"windows-1255\", \"x-cp1255\"],\n      \"name\": \"windows-1255\"\n    }, {\n      \"labels\": [\"cp1256\", \"windows-1256\", \"x-cp1256\"],\n      \"name\": \"windows-1256\"\n    }, {\n      \"labels\": [\"cp1257\", \"windows-1257\", \"x-cp1257\"],\n      \"name\": \"windows-1257\"\n    }, {\n      \"labels\": [\"cp1258\", \"windows-1258\", \"x-cp1258\"],\n      \"name\": \"windows-1258\"\n    }, {\n      \"labels\": [\"x-mac-cyrillic\", \"x-mac-ukrainian\"],\n      \"name\": \"x-mac-cyrillic\"\n    }],\n    \"heading\": \"Legacy single-byte encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"chinese\", \"csgb2312\", \"csiso58gb231280\", \"gb2312\", \"gb_2312\", \"gb_2312-80\", \"gbk\", \"iso-ir-58\", \"x-gbk\"],\n      \"name\": \"GBK\"\n    }, {\n      \"labels\": [\"gb18030\"],\n      \"name\": \"gb18030\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"big5\", \"big5-hkscs\", \"cn-big5\", \"csbig5\", \"x-x-big5\"],\n      \"name\": \"Big5\"\n    }],\n    \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseucpkdfmtjapanese\", \"euc-jp\", \"x-euc-jp\"],\n      \"name\": \"EUC-JP\"\n    }, {\n      \"labels\": [\"csiso2022jp\", \"iso-2022-jp\"],\n      \"name\": \"ISO-2022-JP\"\n    }, {\n      \"labels\": [\"csshiftjis\", \"ms932\", \"ms_kanji\", \"shift-jis\", \"shift_jis\", \"sjis\", \"windows-31j\", \"x-sjis\"],\n      \"name\": \"Shift_JIS\"\n    }],\n    \"heading\": \"Legacy multi-byte Japanese encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"cseuckr\", \"csksc56011987\", \"euc-kr\", \"iso-ir-149\", \"korean\", \"ks_c_5601-1987\", \"ks_c_5601-1989\", \"ksc5601\", \"ksc_5601\", \"windows-949\"],\n      \"name\": \"EUC-KR\"\n    }],\n    \"heading\": \"Legacy multi-byte Korean encodings\"\n  }, {\n    \"encodings\": [{\n      \"labels\": [\"csiso2022kr\", \"hz-gb-2312\", \"iso-2022-cn\", \"iso-2022-cn-ext\", \"iso-2022-kr\"],\n      \"name\": \"replacement\"\n    }, {\n      \"labels\": [\"utf-16be\"],\n      \"name\": \"UTF-16BE\"\n    }, {\n      \"labels\": [\"utf-16\", \"utf-16le\"],\n      \"name\": \"UTF-16LE\"\n    }, {\n      \"labels\": [\"x-user-defined\"],\n      \"name\": \"x-user-defined\"\n    }],\n    \"heading\": \"Legacy miscellaneous encodings\"\n  }]; // Label to encoding registry.\n\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n\n  var label_to_encoding = {};\n  encodings.forEach(function (category) {\n    category.encodings.forEach(function (encoding) {\n      encoding.labels.forEach(function (label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  }); // Registry of of encoder/decoder factories, by encoding name.\n\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n\n  var decoders = {}; //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n\n\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n\n\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" + \" Did you forget to include encoding-indexes.js first?\");\n    }\n\n    return global['encoding-indexes'][name];\n  }\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n\n\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if (pointer > 39419 && pointer < 189000 || pointer > 1237575) return null; // 2. If pointer is 7457, return code point U+E7C7.\n\n    if (pointer === 7457) return 0xE7C7; // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    } // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n\n\n    return code_point_offset + pointer - offset;\n  }\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n\n\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457; // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    } // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n\n\n    return pointer_offset + code_point - offset;\n  }\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n\n\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index || index('jis0208').map(function (code_point, pointer) {\n      return inRange(pointer, 8272, 8835) ? null : code_point;\n    });\n    var index_ = shift_jis_index; // 2. Return the index pointer for code point in index.\n\n    return index_.indexOf(code_point);\n  }\n\n  var shift_jis_index;\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs || index('big5').map(function (code_point, pointer) {\n      return pointer < (0xA1 - 0x81) * 157 ? null : code_point;\n    });\n    var index_ = big5_index_no_hkscs; // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n\n    if (code_point === 0x2550 || code_point === 0x255E || code_point === 0x2561 || code_point === 0x256A || code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    } // 3. Return the index pointer for code point in index.\n\n\n    return indexPointerFor(code_point, index_);\n  }\n\n  var big5_index_no_hkscs; //\n  // 8. API\n  //\n\n  /** @const */\n\n  var DEFAULT_ENCODING = 'utf-8'; // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options); // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n\n    this._decoder = null;\n    /** @private @type {boolean} */\n\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n\n    this._BOMseen = false;\n    /** @private @type {string} */\n\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n\n    this._do_not_flush = false; // 1. Let encoding be the result of getting an encoding from\n    // label.\n\n    var encoding = getEncoding(label); // 2. If encoding is failure or replacement, throw a RangeError.\n\n    if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n    } // 3. Let dec be a new TextDecoder object.\n\n\n    var dec = this; // 4. Set dec's encoding to encoding.\n\n    dec._encoding = encoding; // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n\n    if (Boolean(options['fatal'])) dec._error_mode = 'fatal'; // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n\n    if (Boolean(options['ignoreBOM'])) dec._ignoreBOM = true; // For pre-ES5 runtimes:\n\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    } // 7. Return dec.\n\n\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    }); // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._error_mode === 'fatal';\n      }\n    }); // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function () {\n        return this._ignoreBOM;\n      }\n    });\n  }\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n\n\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options); // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'\n      });\n      this._BOMseen = false;\n    } // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n\n\n    this._do_not_flush = Boolean(options['stream']); // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n\n    var input_stream = new Stream(bytes); // 4. Let output be a new stream.\n\n    var output = [];\n    /** @type {?(number|!Array.<number>)} */\n\n    var result; // 5. While true:\n\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read(); // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n\n      if (token === end_of_stream) break; // 3. Otherwise, run these subsubsteps:\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n\n      result = this._decoder.handler(input_stream, token); // 2. If result is finished, return output, serialized.\n\n      if (result === finished) break;\n\n      if (result !== null) {\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      } // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n      // 4. Otherwise, do nothing.\n\n    } // TODO: Align with spec algorithm.\n\n\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      } while (!input_stream.endOfStream());\n\n      this._decoder = null;\n    } // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n\n\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) && !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {// 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      } // 4. Otherwise, return output.\n\n\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  }; // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n\n\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder)) throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options); // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n\n    this._encoder = null; // Non-standard\n\n    /** @private @type {boolean} */\n\n    this._do_not_flush = false;\n    /** @private @type {string} */\n\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement'; // 1. Let enc be a new TextEncoder object.\n\n    var enc = this; // 2. Set enc's encoding to UTF-8's encoder.\n\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement') throw RangeError('Unknown encoding: ' + label);\n\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' + ' Did you forget to include encoding-indexes.js first?');\n      }\n\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, ' + 'which is ignored.');\n      }\n    } // For pre-ES5 runtimes:\n\n\n    if (!Object.defineProperty) this.encoding = enc._encoding.name.toLowerCase(); // 3. Return enc.\n\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function () {\n        return this._encoding.name.toLowerCase();\n      }\n    });\n  }\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n\n\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options); // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n\n    if (!this._do_not_flush) this._encoder = encoders[this._encoding.name]({\n      fatal: this._fatal === 'fatal'\n    });\n    this._do_not_flush = Boolean(options['stream']); // 1. Convert input to a stream.\n\n    var input = new Stream(stringToCodePoints(opt_string)); // 2. Let output be a new stream\n\n    var output = [];\n    /** @type {?(number|!Array.<number>)} */\n\n    var result; // 3. While true, run these substeps:\n\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream) break; // 2. Let result be the result of processing token for encoder,\n      // input, output.\n\n      result = this._encoder.handler(input, token);\n      if (result === finished) break;\n      if (Array.isArray(result)) output.push.apply(output,\n      /**@type {!Array.<number>}*/\n      result);else output.push(result);\n    } // TODO: Align with spec algorithm.\n\n\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished) break;\n        if (Array.isArray(result)) output.push.apply(output,\n        /**@type {!Array.<number>}*/\n        result);else output.push(result);\n      }\n\n      this._encoder = null;\n    } // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n\n\n    return new Uint8Array(output);\n  }; //\n  // 9. The encoding\n  //\n  // 9.1 utf-8\n  // 9.1.1 utf-8 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF8Decoder(options) {\n    var fatal = options.fatal; // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n\n    var\n    /** @type {number} */\n    utf8_code_point = 0,\n\n    /** @type {number} */\n    utf8_bytes_seen = 0,\n\n    /** @type {number} */\n    utf8_bytes_needed = 0,\n\n    /** @type {number} */\n    utf8_lower_boundary = 0x80,\n\n    /** @type {number} */\n    utf8_upper_boundary = 0xBF;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream, return finished.\n\n\n      if (bite === end_of_stream) return finished; // 3. If utf-8 bytes needed is 0, based on byte:\n\n      if (utf8_bytes_needed === 0) {\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        } // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n            // 1. Set utf-8 bytes needed to 1.\n            utf8_bytes_needed = 1; // 2. Set UTF-8 code point to byte & 0x1F.\n\n            utf8_code_point = bite & 0x1F;\n          } // 0xE0 to 0xEF\n          else if (inRange(bite, 0xE0, 0xEF)) {\n              // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n              if (bite === 0xE0) utf8_lower_boundary = 0xA0; // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n\n              if (bite === 0xED) utf8_upper_boundary = 0x9F; // 3. Set utf-8 bytes needed to 2.\n\n              utf8_bytes_needed = 2; // 4. Set UTF-8 code point to byte & 0xF.\n\n              utf8_code_point = bite & 0xF;\n            } // 0xF0 to 0xF4\n            else if (inRange(bite, 0xF0, 0xF4)) {\n                // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n                if (bite === 0xF0) utf8_lower_boundary = 0x90; // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n\n                if (bite === 0xF4) utf8_upper_boundary = 0x8F; // 3. Set utf-8 bytes needed to 3.\n\n                utf8_bytes_needed = 3; // 4. Set UTF-8 code point to byte & 0x7.\n\n                utf8_code_point = bite & 0x7;\n              } // Otherwise\n              else {\n                  // Return error.\n                  return decoderError(fatal);\n                } // Return continue.\n\n\n        return null;\n      } // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n\n\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF; // 2. Prepend byte to stream.\n\n        stream.prepend(bite); // 3. Return error.\n\n        return decoderError(fatal);\n      } // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n\n\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF; // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n\n      utf8_code_point = utf8_code_point << 6 | bite & 0x3F; // 7. Increase utf-8 bytes seen by one.\n\n      utf8_bytes_seen += 1; // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n\n      if (utf8_bytes_seen !== utf8_bytes_needed) return null; // 9. Let code point be utf-8 code point.\n\n      var code_point = utf8_code_point; // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0; // 11. Return a code point whose value is code point.\n\n      return code_point;\n    };\n  } // 9.1.2 utf-8 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Set count and offset based on the range code point is in:\n\n      var count, offset; // U+0080 to U+07FF, inclusive:\n\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      } // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n          // 2 and 0xE0\n          count = 2;\n          offset = 0xE0;\n        } // U+10000 to U+10FFFF, inclusive:\n        else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n            // 3 and 0xF0\n            count = 3;\n            offset = 0xF0;\n          } // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n\n\n      var bytes = [(code_point >> 6 * count) + offset]; // 5. Run these substeps while count is greater than 0:\n\n      while (count > 0) {\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> 6 * (count - 1); // 2. Append to bytes 0x80 | (temp & 0x3F).\n\n        bytes.push(0x80 | temp & 0x3F); // 3. Decrease count by one.\n\n        count -= 1;\n      } // 6. Return bytes bytes, in order.\n\n\n      return bytes;\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-8'] = function (options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-8'] = function (options) {\n    return new UTF8Decoder(options);\n  }; //\n  // 10. Legacy single-byte encodings\n  //\n  // 10.1 single-byte decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished; // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n      if (isASCIIByte(bite)) return bite; // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n\n      var code_point = index[bite - 0x80]; // 4. If code point is null, return error.\n\n      if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n      return code_point;\n    };\n  } // 10.2 single-byte encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n\n      var pointer = indexPointerFor(code_point, index); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) encoderError(code_point); // 5. Return a byte whose value is pointer + 0x80.\n\n      return pointer + 0x80;\n    };\n  }\n\n  (function () {\n    if (!('encoding-indexes' in global)) return;\n    encodings.forEach(function (category) {\n      if (category.heading !== 'Legacy single-byte encodings') return;\n      category.encodings.forEach(function (encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n\n        decoders[name] = function (options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n\n\n        encoders[name] = function (options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  })(); //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n  // 11.1 gbk\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['GBK'] = function (options) {\n    return new GB18030Decoder(options);\n  }; // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['GBK'] = function (options) {\n    return new GB18030Encoder(options, true);\n  }; // 11.2 gb18030\n  // 11.2.1 gb18030 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function GB18030Decoder(options) {\n    var fatal = options.fatal; // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n\n    var\n    /** @type {number} */\n    gb18030_first = 0x00,\n\n    /** @type {number} */\n    gb18030_second = 0x00,\n\n    /** @type {number} */\n    gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 && gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      } // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n\n\n      if (bite === end_of_stream && (gb18030_first !== 0x00 || gb18030_second !== 0x00 || gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n\n      var code_point; // 3. If gb18030 third is not 0x00, run these substeps:\n\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null; // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor((((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 + gb18030_third - 0x81) * 10 + bite - 0x30);\n        } // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n\n\n        var buffer = [gb18030_second, gb18030_third, bite]; // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00; // 5. If code point is null, prepend buffer to stream and\n        // return error.\n\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        } // 6. Return a code point whose value is code point.\n\n\n        return code_point;\n      } // 4. If gb18030 second is not 0x00, run these substeps:\n\n\n      if (gb18030_second !== 0x00) {\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        } // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n\n\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      } // 5. If gb18030 first is not 0x00, run these substeps:\n\n\n      if (gb18030_first !== 0x00) {\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        } // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n\n\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00; // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x41; // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - offset); // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n\n        code_point = pointer === null ? null : indexCodePointFor(pointer, index('gb18030')); // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 7. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 8. Return a code point whose value is code point.\n\n        return code_point;\n      } // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 7. If byte is 0x80, return code point U+20AC.\n\n      if (bite === 0x80) return 0x20AC; // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      } // 9. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 11.2.2 gb18030 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n\n\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal; // gb18030's decoder has an associated gbk flag (initially unset).\n\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is U+E5E5, return error with code point.\n\n      if (code_point === 0xE5E5) return encoderError(code_point); // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n\n      if (gbk_flag && code_point === 0x20AC) return 0x80; // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n\n      var pointer = indexPointerFor(code_point, index('gb18030')); // 6. If pointer is not null, run these substeps:\n\n      if (pointer !== null) {\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81; // 2. Let trail be pointer % 190.\n\n        var trail = pointer % 190; // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n\n        var offset = trail < 0x3F ? 0x40 : 0x41; // 4. Return two bytes whose values are lead and trail + offset.\n\n        return [lead, trail + offset];\n      } // 7. If gbk flag is set, return error with code point.\n\n\n      if (gbk_flag) return encoderError(code_point); // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n\n      pointer = indexGB18030RangesPointerFor(code_point); // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n\n      var byte1 = floor(pointer / 10 / 126 / 10); // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n\n      pointer = pointer - byte1 * 10 * 126 * 10; // 11. Let byte2 be floor(pointer / 10 / 126).\n\n      var byte2 = floor(pointer / 10 / 126); // 12. Set pointer to pointer − byte2 × 10 × 126.\n\n      pointer = pointer - byte2 * 10 * 126; // 13. Let byte3 be floor(pointer / 10).\n\n      var byte3 = floor(pointer / 10); // 14. Let byte4 be pointer − byte3 × 10.\n\n      var byte4 = pointer - byte3 * 10; // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n\n      return [byte1 + 0x81, byte2 + 0x30, byte3 + 0x81, byte4 + 0x30];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['gb18030'] = function (options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['gb18030'] = function (options) {\n    return new GB18030Decoder(options);\n  }; //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n  // 12.1 Big5\n  // 12.1.1 Big5 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function Big5Decoder(options) {\n    var fatal = options.fatal; // Big5's decoder has an associated Big5 lead (initially 0x00).\n\n    var\n    /** @type {number} */\n    Big5_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && Big5_lead === 0x00) return finished; // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00; // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x62; // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE)) pointer = (lead - 0x81) * 157 + (bite - offset); // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n\n        switch (pointer) {\n          case 1133:\n            return [0x00CA, 0x0304];\n\n          case 1135:\n            return [0x00CA, 0x030C];\n\n          case 1164:\n            return [0x00EA, 0x0304];\n\n          case 1166:\n            return [0x00EA, 0x030C];\n        } // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('big5')); // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 6. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 7. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      } // 6. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 12.1.2 Big5 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index Big5 pointer for code point.\n\n      var pointer = indexBig5PointerFor(code_point); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 5. Let lead be floor(pointer / 157) + 0x81.\n\n      var lead = floor(pointer / 157) + 0x81; // 6. If lead is less than 0xA1, return error with code point.\n\n      if (lead < 0xA1) return encoderError(code_point); // 7. Let trail be pointer % 157.\n\n      var trail = pointer % 157; // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n\n      var offset = trail < 0x3F ? 0x40 : 0x62; // Return two bytes whose values are lead and trail + offset.\n\n      return [lead, trail + offset];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['Big5'] = function (options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['Big5'] = function (options) {\n    return new Big5Decoder(options);\n  }; //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n  // 13.1 euc-jp\n  // 13.1.1 euc-jp decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal; // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n\n    var\n    /** @type {boolean} */\n    eucjp_jis0212_flag = false,\n\n    /** @type {number} */\n    eucjp_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && eucjp_lead === 0x00) return finished; // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      } // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n\n\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      } // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n\n\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00; // 1. Let code point be null.\n\n        var code_point = null; // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor((lead - 0xA1) * 94 + (bite - 0xA1), index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        } // 3. Unset the euc-jp jis0212 flag.\n\n\n        eucjp_jis0212_flag = false; // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n\n        if (!inRange(bite, 0xA1, 0xFE)) stream.prepend(bite); // 5. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 6. Return a code point whose value is code point.\n\n        return code_point;\n      } // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      } // 8. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 13.1.2 euc-jp encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is U+00A5, return byte 0x5C.\n\n      if (code_point === 0x00A5) return 0x5C; // 4. If code point is U+203E, return byte 0x7E.\n\n      if (code_point === 0x203E) return 0x7E; // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return [0x8E, code_point - 0xFF61 + 0xA1]; // 6. If code point is U+2212, set it to U+FF0D.\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n\n      var pointer = indexPointerFor(code_point, index('jis0208')); // 8. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 9. Let lead be floor(pointer / 94) + 0xA1.\n\n      var lead = floor(pointer / 94) + 0xA1; // 10. Let trail be pointer % 94 + 0xA1.\n\n      var trail = pointer % 94 + 0xA1; // 11. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['EUC-JP'] = function (options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['EUC-JP'] = function (options) {\n    return new EUCJPDecoder(options);\n  }; // 13.2 iso-2022-jp\n  // 13.2.1 iso-2022-jp decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    }; // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n\n    var\n    /** @type {number} */\n    iso2022jp_decoder_state = states.ASCII,\n\n    /** @type {number} */\n    iso2022jp_decoder_output_state = states.ASCII,\n\n    /** @type {number} */\n    iso2022jp_lead = 0x00,\n\n    /** @type {boolean} */\n    iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n        default:\n        case states.ASCII:\n          // ASCII\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n\n\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.Roman:\n          // Roman\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x5C\n\n\n          if (bite === 0x5C) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+00A5.\n            iso2022jp_output_flag = false;\n            return 0x00A5;\n          } // 0x7E\n\n\n          if (bite === 0x7E) {\n            // Unset the iso-2022-jp output flag and return code point\n            // U+203E.\n            iso2022jp_output_flag = false;\n            return 0x203E;\n          } // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n\n\n          if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is byte.\n            iso2022jp_output_flag = false;\n            return bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.Katakana:\n          // Katakana\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x21 to 0x5F\n\n\n          if (inRange(bite, 0x21, 0x5F)) {\n            // Unset the iso-2022-jp output flag and return a code point\n            // whose value is 0xFF61 − 0x21 + byte.\n            iso2022jp_output_flag = false;\n            return 0xFF61 - 0x21 + bite;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.LeadByte:\n          // Lead byte\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return null;\n          } // 0x21 to 0x7E\n\n\n          if (inRange(bite, 0x21, 0x7E)) {\n            // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n            // to byte, iso-2022-jp decoder state to trail byte, and\n            // return continue.\n            iso2022jp_output_flag = false;\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.TrailByte;\n            return null;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Return finished.\n            return finished;\n          } // Otherwise\n          // Unset the iso-2022-jp output flag and return error.\n\n\n          iso2022jp_output_flag = false;\n          return decoderError(fatal);\n\n        case states.TrailByte:\n          // Trail byte\n          // Based on byte:\n          // 0x1B\n          if (bite === 0x1B) {\n            // Set iso-2022-jp decoder state to escape start and return\n            // continue.\n            iso2022jp_decoder_state = states.EscapeStart;\n            return decoderError(fatal);\n          } // 0x21 to 0x7E\n\n\n          if (inRange(bite, 0x21, 0x7E)) {\n            // 1. Set the iso-2022-jp decoder state to lead byte.\n            iso2022jp_decoder_state = states.LeadByte; // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n\n            var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21; // 3. Let code point be the index code point for pointer in\n            // index jis0208.\n\n            var code_point = indexCodePointFor(pointer, index('jis0208')); // 4. If code point is null, return error.\n\n            if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n            return code_point;\n          } // end-of-stream\n\n\n          if (bite === end_of_stream) {\n            // Set the iso-2022-jp decoder state to lead byte, prepend\n            // byte to stream, and return error.\n            iso2022jp_decoder_state = states.LeadByte;\n            stream.prepend(bite);\n            return decoderError(fatal);\n          } // Otherwise\n          // Set iso-2022-jp decoder state to lead byte and return\n          // error.\n\n\n          iso2022jp_decoder_state = states.LeadByte;\n          return decoderError(fatal);\n\n        case states.EscapeStart:\n          // Escape start\n          // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n          // byte, iso-2022-jp decoder state to escape, and return\n          // continue.\n          if (bite === 0x24 || bite === 0x28) {\n            iso2022jp_lead = bite;\n            iso2022jp_decoder_state = states.Escape;\n            return null;\n          } // 2. Prepend byte to stream.\n\n\n          stream.prepend(bite); // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state, and\n          // return error.\n\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n\n        case states.Escape:\n          // Escape\n          // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n          // 0x00.\n          var lead = iso2022jp_lead;\n          iso2022jp_lead = 0x00; // 2. Let state be null.\n\n          var state = null; // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n\n          if (lead === 0x28 && bite === 0x42) state = states.ASCII; // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n\n          if (lead === 0x28 && bite === 0x4A) state = states.Roman; // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n\n          if (lead === 0x28 && bite === 0x49) state = states.Katakana; // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n          // state to lead byte.\n\n          if (lead === 0x24 && (bite === 0x40 || bite === 0x42)) state = states.LeadByte; // 7. If state is non-null, run these substeps:\n\n          if (state !== null) {\n            // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n            // output state to states.\n            iso2022jp_decoder_state = iso2022jp_decoder_state = state; // 2. Let output flag be the iso-2022-jp output flag.\n\n            var output_flag = iso2022jp_output_flag; // 3. Set the iso-2022-jp output flag.\n\n            iso2022jp_output_flag = true; // 4. Return continue, if output flag is unset, and error\n            // otherwise.\n\n            return !output_flag ? null : decoderError(fatal);\n          } // 8. Prepend lead and byte to stream.\n\n\n          stream.prepend([lead, bite]); // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n          // decoder state to iso-2022-jp decoder output state and\n          // return error.\n\n          iso2022jp_output_flag = false;\n          iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n          return decoderError(fatal);\n      }\n    };\n  } // 13.2.2 iso-2022-jp encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal; // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n\n    /** @enum */\n\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var\n    /** @type {number} */\n    iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      } // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n\n\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII) return finished; // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n\n      if ((iso2022jp_state === states.ASCII || iso2022jp_state === states.Roman) && (code_point === 0x000E || code_point === 0x000F || code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      } // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n\n\n      if (iso2022jp_state === states.ASCII && isASCIICodePoint(code_point)) return code_point; // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n\n      if (iso2022jp_state === states.Roman && (isASCIICodePoint(code_point) && code_point !== 0x005C && code_point !== 0x007E || code_point == 0x00A5 || code_point == 0x203E)) {\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point)) return code_point; // 2. If code point is U+00A5, return byte 0x5C.\n\n        if (code_point === 0x00A5) return 0x5C; // 3. If code point is U+203E, return byte 0x7E.\n\n        if (code_point === 0x203E) return 0x7E;\n      } // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n\n\n      if (isASCIICodePoint(code_point) && iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      } // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n\n\n      if ((code_point === 0x00A5 || code_point === 0x203E) && iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      } // 8. If code point is U+2212, set it to U+FF0D.\n\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n\n      var pointer = indexPointerFor(code_point, index('jis0208')); // 10. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      } // 12. Let lead be floor(pointer / 94) + 0x21.\n\n\n      var lead = floor(pointer / 94) + 0x21; // 13. Let trail be pointer % 94 + 0x21.\n\n      var trail = pointer % 94 + 0x21; // 14. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['ISO-2022-JP'] = function (options) {\n    return new ISO2022JPDecoder(options);\n  }; // 13.3 Shift_JIS\n  // 13.3.1 Shift_JIS decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal; // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n\n    var\n    /** @type {number} */\n    Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n\n\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00) return finished; // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00; // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n\n        var offset = bite < 0x7F ? 0x40 : 0x41; // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n\n        var lead_offset = lead < 0xA0 ? 0x81 : 0xC1; // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC)) pointer = (lead - lead_offset) * 188 + bite - offset; // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n\n        if (inRange(pointer, 8836, 10715)) return 0xE000 - 8836 + pointer; // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('jis0208')); // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (code_point === null && isASCIIByte(bite)) stream.prepend(bite); // 7. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 8. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n\n\n      if (isASCIIByte(bite) || bite === 0x80) return bite; // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n\n      if (inRange(bite, 0xA1, 0xDF)) return 0xFF61 - 0xA1 + bite; // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      } // 7. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 13.3.2 Shift_JIS encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n\n      if (isASCIICodePoint(code_point) || code_point === 0x0080) return code_point; // 3. If code point is U+00A5, return byte 0x5C.\n\n      if (code_point === 0x00A5) return 0x5C; // 4. If code point is U+203E, return byte 0x7E.\n\n      if (code_point === 0x203E) return 0x7E; // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n\n      if (inRange(code_point, 0xFF61, 0xFF9F)) return code_point - 0xFF61 + 0xA1; // 6. If code point is U+2212, set it to U+FF0D.\n\n      if (code_point === 0x2212) code_point = 0xFF0D; // 7. Let pointer be the index Shift_JIS pointer for code point.\n\n      var pointer = indexShiftJISPointerFor(code_point); // 8. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 9. Let lead be floor(pointer / 188).\n\n      var lead = floor(pointer / 188); // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n\n      var lead_offset = lead < 0x1F ? 0x81 : 0xC1; // 11. Let trail be pointer % 188.\n\n      var trail = pointer % 188; // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n\n      var offset = trail < 0x3F ? 0x40 : 0x41; // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['Shift_JIS'] = function (options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['Shift_JIS'] = function (options) {\n    return new ShiftJISDecoder(options);\n  }; //\n  // 14. Legacy multi-byte Korean encodings\n  //\n  // 14.1 euc-kr\n  // 14.1.1 euc-kr decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal; // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n\n    var\n    /** @type {number} */\n    euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n\n\n      if (bite === end_of_stream && euckr_lead === 0) return finished; // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00; // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n\n        if (inRange(bite, 0x41, 0xFE)) pointer = (lead - 0x81) * 190 + (bite - 0x41); // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n\n        var code_point = pointer === null ? null : indexCodePointFor(pointer, index('euc-kr')); // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n\n        if (pointer === null && isASCIIByte(bite)) stream.prepend(bite); // 4. If code point is null, return error.\n\n        if (code_point === null) return decoderError(fatal); // 5. Return a code point whose value is code point.\n\n        return code_point;\n      } // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n\n      if (isASCIIByte(bite)) return bite; // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      } // 6. Return error.\n\n\n      return decoderError(fatal);\n    };\n  } // 14.1.2 euc-kr encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n\n      var pointer = indexPointerFor(code_point, index('euc-kr')); // 4. If pointer is null, return error with code point.\n\n      if (pointer === null) return encoderError(code_point); // 5. Let lead be floor(pointer / 190) + 0x81.\n\n      var lead = floor(pointer / 190) + 0x81; // 6. Let trail be pointer % 190 + 0x41.\n\n      var trail = pointer % 190 + 0x41; // 7. Return two bytes whose values are lead and trail.\n\n      return [lead, trail];\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['EUC-KR'] = function (options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['EUC-KR'] = function (options) {\n    return new EUCKRDecoder(options);\n  }; //\n  // 15. Legacy miscellaneous encodings\n  //\n  // 15.1 replacement\n  // Not needed - API throws RangeError\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n\n\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8; // 2. Let byte2 be code unit & 0x00FF.\n\n    var byte2 = code_unit & 0x00FF; // 3. Then return the bytes in order:\n    // utf-16be flag is set: byte1, then byte2.\n\n    if (utf16be) return [byte1, byte2]; // utf-16be flag is unset: byte2, then byte1.\n\n    return [byte2, byte1];\n  } // 15.2.1 shared utf-16 decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var\n    /** @type {?number} */\n    utf16_lead_byte = null,\n\n    /** @type {?number} */\n    utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null || utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      } // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n\n\n      if (bite === end_of_stream && utf16_lead_byte === null && utf16_lead_surrogate === null) {\n        return finished;\n      } // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n\n\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      } // 4. Let code unit be the result of:\n\n\n      var code_unit;\n\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      } // Then set utf-16 lead byte to null.\n\n\n      utf16_lead_byte = null; // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null; // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 + (code_unit - 0xDC00);\n        } // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n\n\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      } // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n\n\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      } // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n\n\n      if (inRange(code_unit, 0xDC00, 0xDFFF)) return decoderError(fatal); // 8. Return code point code unit.\n\n      return code_unit;\n    };\n  } // 15.2.2 shared utf-16 encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n\n      if (inRange(code_point, 0x0000, 0xFFFF)) return convertCodeUnitToBytes(code_point, utf16_be); // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n\n      var lead = convertCodeUnitToBytes((code_point - 0x10000 >> 10) + 0xD800, utf16_be); // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n\n      var trail = convertCodeUnitToBytes((code_point - 0x10000 & 0x3FF) + 0xDC00, utf16_be); // 5. Return a byte sequence of lead followed by trail.\n\n      return lead.concat(trail);\n    };\n  } // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-16BE'] = function (options) {\n    return new UTF16Encoder(true, options);\n  }; // 15.3.2 utf-16be encoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-16BE'] = function (options) {\n    return new UTF16Decoder(true, options);\n  }; // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['UTF-16LE'] = function (options) {\n    return new UTF16Encoder(false, options);\n  }; // 15.4.2 utf-16le encoder\n\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['UTF-16LE'] = function (options) {\n    return new UTF16Decoder(false, options);\n  }; // 15.5 x-user-defined\n  // 15.5.1 x-user-defined decoder\n\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n\n    this.handler = function (stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream) return finished; // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n\n      if (isASCIIByte(bite)) return bite; // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n\n      return 0xF780 + bite - 0x80;\n    };\n  } // 15.5.2 x-user-defined encoder\n\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n\n\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n\n    this.handler = function (stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream) return finished; // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n\n      if (isASCIICodePoint(code_point)) return code_point; // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n\n      if (inRange(code_point, 0xF780, 0xF7FF)) return code_point - 0xF780 + 0x80; // 4. Return error with code point.\n\n      return encoderError(code_point);\n    };\n  }\n  /** @param {{fatal: boolean}} options */\n\n\n  encoders['x-user-defined'] = function (options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n\n\n  decoders['x-user-defined'] = function (options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder']) global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder']) global['TextDecoder'] = TextDecoder;\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  } // For strict environments where `this` inside the global scope\n  // is `undefined`, take a pure object instead\n\n})(this || {});","map":{"version":3,"sources":["C:/Users/chena/reactgun/my-app/node_modules/text-encoding/lib/encoding.js"],"names":["global","module","exports","require","inRange","a","min","max","includes","array","item","indexOf","floor","Math","ToDictionary","o","undefined","Object","TypeError","stringToCodePoints","string","s","String","n","length","i","u","c","charCodeAt","push","d","b","codePointsToString","code_points","cp","fromCharCode","isASCIIByte","isASCIICodePoint","end_of_stream","Stream","tokens","slice","call","reverse","prototype","endOfStream","read","pop","prepend","token","Array","isArray","unshift","shift","finished","decoderError","fatal","opt_code_point","encoderError","code_point","Decoder","handler","stream","bite","Encoder","getEncoding","label","trim","toLowerCase","hasOwnProperty","label_to_encoding","encodings","forEach","category","encoding","labels","encoders","decoders","indexCodePointFor","pointer","index","indexPointerFor","name","Error","indexGB18030RangesCodePointFor","offset","code_point_offset","idx","entry","indexGB18030RangesPointerFor","pointer_offset","indexShiftJISPointerFor","shift_jis_index","map","index_","indexBig5PointerFor","big5_index_no_hkscs","lastIndexOf","DEFAULT_ENCODING","TextDecoder","options","_encoding","_decoder","_ignoreBOM","_BOMseen","_error_mode","_do_not_flush","RangeError","dec","Boolean","defineProperty","ignoreBOM","get","decode","input","bytes","ArrayBuffer","Uint8Array","buffer","byteOffset","byteLength","input_stream","output","result","apply","serializeStream","TextEncoder","_encoder","_fatal","enc","console","warn","encode","opt_string","UTF8Decoder","utf8_code_point","utf8_bytes_seen","utf8_bytes_needed","utf8_lower_boundary","utf8_upper_boundary","UTF8Encoder","count","temp","SingleByteDecoder","SingleByteEncoder","heading","GB18030Decoder","GB18030Encoder","gb18030_first","gb18030_second","gb18030_third","lead","gbk_flag","trail","byte1","byte2","byte3","byte4","Big5Decoder","Big5_lead","Big5Encoder","EUCJPDecoder","eucjp_jis0212_flag","eucjp_lead","EUCJPEncoder","ISO2022JPDecoder","states","ASCII","Roman","Katakana","LeadByte","TrailByte","EscapeStart","Escape","iso2022jp_decoder_state","iso2022jp_decoder_output_state","iso2022jp_lead","iso2022jp_output_flag","state","output_flag","ISO2022JPEncoder","jis0208","iso2022jp_state","ShiftJISDecoder","Shift_JIS_lead","lead_offset","ShiftJISEncoder","EUCKRDecoder","euckr_lead","EUCKREncoder","convertCodeUnitToBytes","code_unit","utf16be","UTF16Decoder","utf16_be","utf16_lead_byte","utf16_lead_surrogate","lead_surrogate","UTF16Encoder","concat","XUserDefinedDecoder","XUserDefinedEncoder","EncodingIndexes"],"mappings":"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","sourcesContent":["// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\n(function(global) {\n  'use strict';\n\n  // If we're in node require encoding-indexes and attach it to the global.\n  if (typeof module !== \"undefined\" && module.exports &&\n    !global[\"encoding-indexes\"]) {\n    global[\"encoding-indexes\"] =\n      require(\"./encoding-indexes.js\")[\"encoding-indexes\"];\n  }\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError('Could not convert argument to dictionary');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00 ≤ c ≤ 0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800 ≤ c ≤ 0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n−1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = s.charCodeAt(i + 1);\n\n          // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = '';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */ var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError('Decoder error');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError('The code point ' + code_point + ' could not be encoded.');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function(stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function(stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"unicode-1-1-utf-8\",\n            \"utf-8\",\n            \"utf8\"\n          ],\n          \"name\": \"UTF-8\"\n        }\n      ],\n      \"heading\": \"The Encoding\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"866\",\n            \"cp866\",\n            \"csibm866\",\n            \"ibm866\"\n          ],\n          \"name\": \"IBM866\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin2\",\n            \"iso-8859-2\",\n            \"iso-ir-101\",\n            \"iso8859-2\",\n            \"iso88592\",\n            \"iso_8859-2\",\n            \"iso_8859-2:1987\",\n            \"l2\",\n            \"latin2\"\n          ],\n          \"name\": \"ISO-8859-2\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin3\",\n            \"iso-8859-3\",\n            \"iso-ir-109\",\n            \"iso8859-3\",\n            \"iso88593\",\n            \"iso_8859-3\",\n            \"iso_8859-3:1988\",\n            \"l3\",\n            \"latin3\"\n          ],\n          \"name\": \"ISO-8859-3\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin4\",\n            \"iso-8859-4\",\n            \"iso-ir-110\",\n            \"iso8859-4\",\n            \"iso88594\",\n            \"iso_8859-4\",\n            \"iso_8859-4:1988\",\n            \"l4\",\n            \"latin4\"\n          ],\n          \"name\": \"ISO-8859-4\"\n        },\n        {\n          \"labels\": [\n            \"csisolatincyrillic\",\n            \"cyrillic\",\n            \"iso-8859-5\",\n            \"iso-ir-144\",\n            \"iso8859-5\",\n            \"iso88595\",\n            \"iso_8859-5\",\n            \"iso_8859-5:1988\"\n          ],\n          \"name\": \"ISO-8859-5\"\n        },\n        {\n          \"labels\": [\n            \"arabic\",\n            \"asmo-708\",\n            \"csiso88596e\",\n            \"csiso88596i\",\n            \"csisolatinarabic\",\n            \"ecma-114\",\n            \"iso-8859-6\",\n            \"iso-8859-6-e\",\n            \"iso-8859-6-i\",\n            \"iso-ir-127\",\n            \"iso8859-6\",\n            \"iso88596\",\n            \"iso_8859-6\",\n            \"iso_8859-6:1987\"\n          ],\n          \"name\": \"ISO-8859-6\"\n        },\n        {\n          \"labels\": [\n            \"csisolatingreek\",\n            \"ecma-118\",\n            \"elot_928\",\n            \"greek\",\n            \"greek8\",\n            \"iso-8859-7\",\n            \"iso-ir-126\",\n            \"iso8859-7\",\n            \"iso88597\",\n            \"iso_8859-7\",\n            \"iso_8859-7:1987\",\n            \"sun_eu_greek\"\n          ],\n          \"name\": \"ISO-8859-7\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598e\",\n            \"csisolatinhebrew\",\n            \"hebrew\",\n            \"iso-8859-8\",\n            \"iso-8859-8-e\",\n            \"iso-ir-138\",\n            \"iso8859-8\",\n            \"iso88598\",\n            \"iso_8859-8\",\n            \"iso_8859-8:1988\",\n            \"visual\"\n          ],\n          \"name\": \"ISO-8859-8\"\n        },\n        {\n          \"labels\": [\n            \"csiso88598i\",\n            \"iso-8859-8-i\",\n            \"logical\"\n          ],\n          \"name\": \"ISO-8859-8-I\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin6\",\n            \"iso-8859-10\",\n            \"iso-ir-157\",\n            \"iso8859-10\",\n            \"iso885910\",\n            \"l6\",\n            \"latin6\"\n          ],\n          \"name\": \"ISO-8859-10\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-13\",\n            \"iso8859-13\",\n            \"iso885913\"\n          ],\n          \"name\": \"ISO-8859-13\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-14\",\n            \"iso8859-14\",\n            \"iso885914\"\n          ],\n          \"name\": \"ISO-8859-14\"\n        },\n        {\n          \"labels\": [\n            \"csisolatin9\",\n            \"iso-8859-15\",\n            \"iso8859-15\",\n            \"iso885915\",\n            \"iso_8859-15\",\n            \"l9\"\n          ],\n          \"name\": \"ISO-8859-15\"\n        },\n        {\n          \"labels\": [\n            \"iso-8859-16\"\n          ],\n          \"name\": \"ISO-8859-16\"\n        },\n        {\n          \"labels\": [\n            \"cskoi8r\",\n            \"koi\",\n            \"koi8\",\n            \"koi8-r\",\n            \"koi8_r\"\n          ],\n          \"name\": \"KOI8-R\"\n        },\n        {\n          \"labels\": [\n            \"koi8-ru\",\n            \"koi8-u\"\n          ],\n          \"name\": \"KOI8-U\"\n        },\n        {\n          \"labels\": [\n            \"csmacintosh\",\n            \"mac\",\n            \"macintosh\",\n            \"x-mac-roman\"\n          ],\n          \"name\": \"macintosh\"\n        },\n        {\n          \"labels\": [\n            \"dos-874\",\n            \"iso-8859-11\",\n            \"iso8859-11\",\n            \"iso885911\",\n            \"tis-620\",\n            \"windows-874\"\n          ],\n          \"name\": \"windows-874\"\n        },\n        {\n          \"labels\": [\n            \"cp1250\",\n            \"windows-1250\",\n            \"x-cp1250\"\n          ],\n          \"name\": \"windows-1250\"\n        },\n        {\n          \"labels\": [\n            \"cp1251\",\n            \"windows-1251\",\n            \"x-cp1251\"\n          ],\n          \"name\": \"windows-1251\"\n        },\n        {\n          \"labels\": [\n            \"ansi_x3.4-1968\",\n            \"ascii\",\n            \"cp1252\",\n            \"cp819\",\n            \"csisolatin1\",\n            \"ibm819\",\n            \"iso-8859-1\",\n            \"iso-ir-100\",\n            \"iso8859-1\",\n            \"iso88591\",\n            \"iso_8859-1\",\n            \"iso_8859-1:1987\",\n            \"l1\",\n            \"latin1\",\n            \"us-ascii\",\n            \"windows-1252\",\n            \"x-cp1252\"\n          ],\n          \"name\": \"windows-1252\"\n        },\n        {\n          \"labels\": [\n            \"cp1253\",\n            \"windows-1253\",\n            \"x-cp1253\"\n          ],\n          \"name\": \"windows-1253\"\n        },\n        {\n          \"labels\": [\n            \"cp1254\",\n            \"csisolatin5\",\n            \"iso-8859-9\",\n            \"iso-ir-148\",\n            \"iso8859-9\",\n            \"iso88599\",\n            \"iso_8859-9\",\n            \"iso_8859-9:1989\",\n            \"l5\",\n            \"latin5\",\n            \"windows-1254\",\n            \"x-cp1254\"\n          ],\n          \"name\": \"windows-1254\"\n        },\n        {\n          \"labels\": [\n            \"cp1255\",\n            \"windows-1255\",\n            \"x-cp1255\"\n          ],\n          \"name\": \"windows-1255\"\n        },\n        {\n          \"labels\": [\n            \"cp1256\",\n            \"windows-1256\",\n            \"x-cp1256\"\n          ],\n          \"name\": \"windows-1256\"\n        },\n        {\n          \"labels\": [\n            \"cp1257\",\n            \"windows-1257\",\n            \"x-cp1257\"\n          ],\n          \"name\": \"windows-1257\"\n        },\n        {\n          \"labels\": [\n            \"cp1258\",\n            \"windows-1258\",\n            \"x-cp1258\"\n          ],\n          \"name\": \"windows-1258\"\n        },\n        {\n          \"labels\": [\n            \"x-mac-cyrillic\",\n            \"x-mac-ukrainian\"\n          ],\n          \"name\": \"x-mac-cyrillic\"\n        }\n      ],\n      \"heading\": \"Legacy single-byte encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"chinese\",\n            \"csgb2312\",\n            \"csiso58gb231280\",\n            \"gb2312\",\n            \"gb_2312\",\n            \"gb_2312-80\",\n            \"gbk\",\n            \"iso-ir-58\",\n            \"x-gbk\"\n          ],\n          \"name\": \"GBK\"\n        },\n        {\n          \"labels\": [\n            \"gb18030\"\n          ],\n          \"name\": \"gb18030\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (simplified) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"big5\",\n            \"big5-hkscs\",\n            \"cn-big5\",\n            \"csbig5\",\n            \"x-x-big5\"\n          ],\n          \"name\": \"Big5\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Chinese (traditional) encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseucpkdfmtjapanese\",\n            \"euc-jp\",\n            \"x-euc-jp\"\n          ],\n          \"name\": \"EUC-JP\"\n        },\n        {\n          \"labels\": [\n            \"csiso2022jp\",\n            \"iso-2022-jp\"\n          ],\n          \"name\": \"ISO-2022-JP\"\n        },\n        {\n          \"labels\": [\n            \"csshiftjis\",\n            \"ms932\",\n            \"ms_kanji\",\n            \"shift-jis\",\n            \"shift_jis\",\n            \"sjis\",\n            \"windows-31j\",\n            \"x-sjis\"\n          ],\n          \"name\": \"Shift_JIS\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Japanese encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"cseuckr\",\n            \"csksc56011987\",\n            \"euc-kr\",\n            \"iso-ir-149\",\n            \"korean\",\n            \"ks_c_5601-1987\",\n            \"ks_c_5601-1989\",\n            \"ksc5601\",\n            \"ksc_5601\",\n            \"windows-949\"\n          ],\n          \"name\": \"EUC-KR\"\n        }\n      ],\n      \"heading\": \"Legacy multi-byte Korean encodings\"\n    },\n    {\n      \"encodings\": [\n        {\n          \"labels\": [\n            \"csiso2022kr\",\n            \"hz-gb-2312\",\n            \"iso-2022-cn\",\n            \"iso-2022-cn-ext\",\n            \"iso-2022-kr\"\n          ],\n          \"name\": \"replacement\"\n        },\n        {\n          \"labels\": [\n            \"utf-16be\"\n          ],\n          \"name\": \"UTF-16BE\"\n        },\n        {\n          \"labels\": [\n            \"utf-16\",\n            \"utf-16le\"\n          ],\n          \"name\": \"UTF-16LE\"\n        },\n        {\n          \"labels\": [\n            \"x-user-defined\"\n          ],\n          \"name\": \"x-user-defined\"\n        }\n      ],\n      \"heading\": \"Legacy miscellaneous encodings\"\n    }\n  ];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!('encoding-indexes' in global)) {\n      throw Error(\"Indexes missing.\" +\n                  \" Did you forget to include encoding-indexes.js first?\");\n    }\n    return global['encoding-indexes'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer − offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index('gb18030-ranges');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    // − offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the Shift_JIS\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the Shift_JIS index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all entries whose\n    // pointer is in the range 8272 to 8835, inclusive.\n    shift_jis_index = shift_jis_index ||\n      index('jis0208').map(function(code_point, pointer) {\n        return inRange(pointer, 8272, 8835) ? null : code_point;\n      });\n    var index_ = shift_jis_index;\n\n    // 2. Return the index pointer for code point in index.\n    return index_.indexOf(code_point);\n  }\n  var shift_jis_index;\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n    // 1. Let index be index Big5 excluding all entries whose pointer\n    big5_index_no_hkscs = big5_index_no_hkscs ||\n      index('big5').map(function(code_point, pointer) {\n        return (pointer < (0xA1 - 0x81) * 157) ? null : code_point;\n      });\n    var index_ = big5_index_no_hkscs;\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n  var big5_index_no_hkscs;\n\n  //\n  // 8. API\n  //\n\n  /** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to 'utf-8'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = 'replacement';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === 'replacement')\n      throw RangeError('Unknown encoding: ' + label);\n    if (!decoders[encoding.name]) {\n      throw Error('Decoder not present.' +\n                  ' Did you forget to include encoding-indexes.js first?');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec's encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options's fatal member is true, set dec's error mode to\n    // fatal.\n    if (Boolean(options['fatal']))\n      dec._error_mode = 'fatal';\n\n    // 6. If options's ignoreBOM member is true, set dec's ignore BOM\n    // flag.\n    if (Boolean(options['ignoreBOM']))\n      dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === 'fatal';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextDecoder.prototype, 'encoding', {\n      /** @this {TextDecoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n\n    // The fatal attribute's getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'fatal', {\n      /** @this {TextDecoder} */\n      get: function() { return this._error_mode === 'fatal'; }\n    });\n\n    // The ignoreBOM attribute's getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, 'ignoreBOM', {\n      /** @this {TextDecoder} */\n      get: function() { return this._ignoreBOM; }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === 'fatal'});\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break;\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes(['UTF-8', 'UTF-16LE', 'UTF-16BE'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder))\n      throw TypeError('Called as a function. Did you forget \\'new\\'?');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options['fatal']) ? 'fatal' : 'replacement';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc's encoding to UTF-8's encoder.\n    if (Boolean(options['NONSTANDARD_allowLegacyEncoding'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === 'replacement')\n        throw RangeError('Unknown encoding: ' + label);\n      if (!encoders[encoding.name]) {\n        throw Error('Encoder not present.' +\n                    ' Did you forget to include encoding-indexes.js first?');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding('utf-8');\n\n      if (label !== undefined && 'console' in global) {\n        console.warn('TextEncoder constructor called with encoding label, '\n                     + 'which is ignored.');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute's getter must return encoding's name.\n    Object.defineProperty(TextEncoder.prototype, 'encoding', {\n      /** @this {TextEncoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string === undefined ? '' : String(opt_string);\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === 'fatal'});\n    this._do_not_flush = Boolean(options['stream']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\n      else\n        output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8's decoder's has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0,\n        /** @type {number} */ utf8_bytes_seen = 0,\n        /** @type {number} */ utf8_bytes_needed = 0,\n        /** @type {number} */ utf8_lower_boundary = 0x80,\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        else if (inRange(bite, 0xC2, 0xDF)) {\n          // 1. Set utf-8 bytes needed to 1.\n          utf8_bytes_needed = 1;\n\n          // 2. Set UTF-8 code point to byte & 0x1F.\n          utf8_code_point = bite & 0x1F;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2.\n          utf8_bytes_needed = 2;\n          // 4. Set UTF-8 code point to byte & 0xF.\n          utf8_code_point = bite & 0xF;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3.\n          utf8_bytes_needed = 3;\n          // 4. Set UTF-8 code point to byte & 0x7.\n          utf8_code_point = bite & 0x7;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Return continue.\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n      // 0x3F)\n      utf8_code_point = (utf8_code_point << 6) | (bite & 0x3F);\n\n      // 7. Increase utf-8 bytes seen by one.\n      utf8_bytes_seen += 1;\n\n      // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n\n      // 9. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 11. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4. Let bytes be a byte sequence whose first byte is (code\n      // point >> (6 × count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n\n        // 1. Set temp to code point >> (6 × (count − 1)).\n        var temp = code_point >> (6 * (count - 1));\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F));\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-8'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-8'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Let code point be the index code point for byte − 0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n\n  (function() {\n    if (!('encoding-indexes' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== 'Legacy single-byte encodings')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk's decoder is gb18030's decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders['GBK'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk's encoder is gb18030's encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders['GBK'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */ gb18030_first = 0x00,\n        /** @type {number} */ gb18030_second = 0x00,\n        /** @type {number} */ gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, inclusive, set\n        // code point to the index gb18030 ranges code point for\n        // (((gb18030 first − 0x81) × 10 + gb18030 second − 0x30) ×\n        // 126 + gb18030 third − 0x81) × 10 + byte − 0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + gb18030_second - 0x30) * 126 +\n               gb18030_third - 0x81) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n\n        // 1. If byte is in the range 0x81 to 0xFE, inclusive, set\n        // gb18030 third to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n\n        // 1. If byte is in the range 0x30 to 0x39, inclusive, set\n        // gb18030 second to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 190 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index('gb18030'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80)\n        return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // gb18030 first to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030's decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index('gb18030'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag)\n        return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer − byte1 × 10 × 126 × 10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer − byte2 × 10 × 126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer − byte3 × 10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['gb18030'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['gb18030'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 Big5\n\n  // 12.1.1 Big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // Big5's decoder has an associated Big5 lead (initially 0x00).\n    var /** @type {number} */ Big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Big5 lead is not 0x00, set\n      // Big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && Big5_lead !== 0x00) {\n        Big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && Big5_lead === 0x00)\n        return finished;\n\n      // 3. If Big5 lead is not 0x00, let lead be Big5 lead, let\n      // pointer be null, set Big5 lead to 0x00, and then run these\n      // substeps:\n      if (Big5_lead !== 0x00) {\n        var lead = Big5_lead;\n        var pointer = null;\n        Big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E, inclusive, or 0xA1\n        // to 0xFE, inclusive, set pointer to (lead − 0x81) × 157 +\n        // (byte − offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index Big5 otherwise.\n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index('big5'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set Big5\n      // lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        Big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 Big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index Big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Big5'] = function(options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Big5'] = function(options) {\n    return new Big5Decoder(options);\n  };\n\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp's decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\n        /** @type {number} */ eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, inclusive, set euc-jp lead to 0x00 and return a code\n      // point whose value is 0xFF61 − 0xA1 + byte.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 - 0xA1 + bite;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, inclusive, set the euc-jp jis0212 flag, set euc-jp lead\n      // to byte, and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE,\n        // inclusive, set code point to the index code point for (lead\n        // − 0xA1) × 94 + byte − 0xA1 in index jis0208 if the euc-jp\n        // jis0212 flag is unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? 'jis0208' : 'jis0212'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, inclusive,\n        // prepend byte to stream.\n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE,\n      // inclusive, set euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return two bytes whose values are 0x8E and code point −\n      // 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-JP'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-JP'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp's decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n        /** @type {number} */ iso2022jp_lead = 0x00,\n        /** @type {boolean} */ iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 − 0x21 + byte.\n          iso2022jp_output_flag = false;\n          return 0xFF61 - 0x21 + bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead − 0x21) × 94 + byte − 0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index('jis0208'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null)\n            return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp's encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point))\n          return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5)\n          return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index('jis0208'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['ISO-2022-JP'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 Shift_JIS\n\n  // 13.3.1 Shift_JIS decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // Shift_JIS's decoder has an associated Shift_JIS lead (initially\n    // 0x00).\n    var /** @type {number} */ Shift_JIS_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and Shift_JIS lead is not 0x00,\n      // set Shift_JIS lead to 0x00 and return error.\n      if (bite === end_of_stream && Shift_JIS_lead !== 0x00) {\n        Shift_JIS_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and Shift_JIS lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && Shift_JIS_lead === 0x00)\n        return finished;\n\n      // 3. If Shift_JIS lead is not 0x00, let lead be Shift_JIS lead,\n      // let pointer be null, set Shift_JIS lead to 0x00, and then run\n      // these substeps:\n      if (Shift_JIS_lead !== 0x00) {\n        var lead = Shift_JIS_lead;\n        var pointer = null;\n        Shift_JIS_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E, inclusive, or 0x80\n        // to 0xFC, inclusive, set pointer to (lead − lead offset) ×\n        // 188 + byte − offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. If pointer is in the range 8836 to 10715, inclusive,\n        // return a code point whose value is 0xE000 − 8836 + pointer.\n        if (inRange(pointer, 8836, 10715))\n          return 0xE000 - 8836 + pointer;\n\n        // 5. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index('jis0208'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, inclusive, return a\n      // code point whose value is 0xFF61 − 0xA1 + byte.\n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 - 0xA1 + bite;\n\n      // 6. If byte is in the range 0x81 to 0x9F, inclusive, or 0xE0\n      // to 0xFC, inclusive, set Shift_JIS lead to byte and return\n      // continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        Shift_JIS_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 Shift_JIS encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, inclusive,\n      // return a byte whose value is code point − 0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index Shift_JIS pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['Shift_JIS'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['Shift_JIS'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr's decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */ euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, inclusive, set\n        // pointer to (lead − 0x81) × 190 + (byte − 0x41).\n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index('euc-kr'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, inclusive, set\n      // euc-kr lead to byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index('euc-kr'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = (pointer % 190) + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['EUC-KR'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['EUC-KR'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n        // utf-16be flag is set: byte1, then byte2.\n    if (utf16be)\n      return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */ utf16_lead_byte = null,\n        /** @type {?number} */ utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF,\n        // inclusive, return a code point whose value is 0x10000 +\n        // ((lead surrogate − 0xD800) << 10) + (code unit − 0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, inclusive,\n      // set utf-16 lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, inclusive,\n      // return error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, inclusive,\n      // return the sequence resulting of converting code point to\n      // bytes using utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point − 0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point − 0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16BE'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16BE'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders['UTF-16LE'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders['UTF-16LE'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte − 0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, inclusive,\n      // return a byte whose value is code point − 0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders['x-user-defined'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders['x-user-defined'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global['TextEncoder'])\n    global['TextEncoder'] = TextEncoder;\n  if (!global['TextDecoder'])\n    global['TextDecoder'] = TextDecoder;\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = {\n      TextEncoder: global['TextEncoder'],\n      TextDecoder: global['TextDecoder'],\n      EncodingIndexes: global[\"encoding-indexes\"]\n    };\n  }\n\n// For strict environments where `this` inside the global scope\n// is `undefined`, take a pure object instead\n}(this || {}));"]},"metadata":{},"sourceType":"script"}