{"ast":null,"code":"import { syntaxError } from \"../error/syntaxError.mjs\";\nimport { Kind } from \"./kinds.mjs\";\nimport { Location } from \"./ast.mjs\";\nimport { TokenKind } from \"./tokenKind.mjs\";\nimport { Source, isSource } from \"./source.mjs\";\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\n/**\r\n * Configuration options to control parser behavior\r\n */\n\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\n\nexport function parse(source, options) {\n  var parser = new Parser(source, options);\n  return parser.parseDocument();\n}\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\n\nexport function parseValue(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var value = parser.parseValueLiteral(false);\n  parser.expectToken(TokenKind.EOF);\n  return value;\n}\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\n\nexport function parseType(source, options) {\n  var parser = new Parser(source, options);\n  parser.expectToken(TokenKind.SOF);\n  var type = parser.parseTypeReference();\n  parser.expectToken(TokenKind.EOF);\n  return type;\n}\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(source, options) {\n    var sourceObj = isSource(source) ? source : new Source(source);\n    this._lexer = new Lexer(sourceObj);\n    this._options = options;\n  }\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\n\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  } // Implements the parsing rules in the Document section.\n\n  /**\r\n   * Document : Definition+\r\n   */\n  ;\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   */\n  ;\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case 'query':\n        case 'mutation':\n        case 'subscription':\n          return this.parseOperationDefinition();\n\n        case 'fragment':\n          return this.parseFragmentDefinition();\n\n        case 'schema':\n        case 'scalar':\n        case 'type':\n        case 'interface':\n        case 'union':\n        case 'enum':\n        case 'input':\n        case 'directive':\n          return this.parseTypeSystemDefinition();\n\n        case 'extend':\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  } // Implements the parsing rules in the Operations section.\n\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\n  ;\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: 'query',\n        name: undefined,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\n  ;\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case 'query':\n        return 'query';\n\n      case 'mutation':\n        return 'mutation';\n\n      case 'subscription':\n        return 'subscription';\n    }\n\n    throw this.unexpected(operationToken);\n  }\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\n  ;\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  }\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\n  ;\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\n      directives: this.parseDirectives(true),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * Variable : $ Name\r\n   */\n  ;\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * SelectionSet : { Selection+ }\r\n   */\n  ;\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\n  ;\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  }\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\n  ;\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(false),\n      directives: this.parseDirectives(false),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\n  ;\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\n  }\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\n  ;\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(false),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Fragments section.\n\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\n  ;\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword('on');\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(false),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\n  ;\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var _this$_options;\n\n    var start = this._lexer.token;\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\n    // the grammar of FragmentDefinition:\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\n\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n        directives: this.parseDirectives(false),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\n      directives: this.parseDirectives(false),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\n  ;\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (this._lexer.token.value === 'on') {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  } // Implements the parsing rules in the Values section.\n\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\n  ;\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        this._lexer.advance();\n\n        switch (token.value) {\n          case 'true':\n            return {\n              kind: Kind.BOOLEAN,\n              value: true,\n              loc: this.loc(token)\n            };\n\n          case 'false':\n            return {\n              kind: Kind.BOOLEAN,\n              value: false,\n              loc: this.loc(token)\n            };\n\n          case 'null':\n            return {\n              kind: Kind.NULL,\n              loc: this.loc(token)\n            };\n\n          default:\n            return {\n              kind: Kind.ENUM,\n              value: token.value,\n              loc: this.loc(token)\n            };\n        }\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n        break;\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  }\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\n  ;\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this.parseValueLiteral(isConst);\n    };\n\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   */\n  ;\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n\n    var item = function item() {\n      return _this2.parseObjectField(isConst);\n    };\n\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\n  ;\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Directives section.\n\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\n  ;\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  }\n  /**\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   */\n  ;\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Types section.\n\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\n  ;\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  }\n  /**\r\n   * NamedType : Name\r\n   */\n  ;\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  } // Implements the parsing rules in the Type Definition section.\n\n  /**\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\n  ;\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    // Many definitions begin with a description and require a lookahead.\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaDefinition();\n\n        case 'scalar':\n          return this.parseScalarTypeDefinition();\n\n        case 'type':\n          return this.parseObjectTypeDefinition();\n\n        case 'interface':\n          return this.parseInterfaceTypeDefinition();\n\n        case 'union':\n          return this.parseUnionTypeDefinition();\n\n        case 'enum':\n          return this.parseEnumTypeDefinition();\n\n        case 'input':\n          return this.parseInputObjectTypeDefinition();\n\n        case 'directive':\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  }\n  /**\r\n   * Description : StringValue\r\n   */\n  ;\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  }\n  /**\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   */\n  ;\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      description: description,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\n  ;\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\n  ;\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\n  ;\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\n  ;\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var _this$_options2;\n\n    if (!this.expectOptionalKeyword('implements')) {\n      return [];\n    }\n\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\n      var types = []; // Optional leading ampersand\n\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\n\n      return types;\n    }\n\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\n  }\n  /**\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   */\n  ;\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    var _this$_options3; // Legacy support for the SDL?\n\n\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\n  ;\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\n  ;\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  }\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\n  ;\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(true);\n    }\n\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\n  ;\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\n  ;\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\n  ;\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\n  }\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\n  ;\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   */\n  ;\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  }\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   *\r\n   * EnumValue : Name\r\n   */\n  ;\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\n  ;\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   */\n  ;\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  }\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\n  ;\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case 'schema':\n          return this.parseSchemaExtension();\n\n        case 'scalar':\n          return this.parseScalarTypeExtension();\n\n        case 'type':\n          return this.parseObjectTypeExtension();\n\n        case 'interface':\n          return this.parseInterfaceTypeExtension();\n\n        case 'union':\n          return this.parseUnionTypeExtension();\n\n        case 'enum':\n          return this.parseEnumTypeExtension();\n\n        case 'input':\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  }\n  /**\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   */\n  ;\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('schema');\n    var directives = this.parseDirectives(true);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (directives.length === 0 && operationTypes.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\n  ;\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('scalar');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n\n    if (directives.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\n  ;\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('type');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\n  ;\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('interface');\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseFieldsDefinition();\n\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\n  ;\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('union');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var types = this.parseUnionMemberTypes();\n\n    if (directives.length === 0 && types.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\n  ;\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('enum');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var values = this.parseEnumValuesDefinition();\n\n    if (directives.length === 0 && values.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\n  ;\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword('extend');\n    this.expectKeyword('input');\n    var name = this.parseName();\n    var directives = this.parseDirectives(true);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (directives.length === 0 && fields.length === 0) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   */\n  ;\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword('directive');\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword('repeatable');\n    this.expectKeyword('on');\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  }\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\n  ;\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\n  }\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\n  ;\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (DirectiveLocation[name.value] !== undefined) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  } // Core parsing utility functions\n\n  /**\r\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\r\n   */\n  ;\n\n  _proto.loc = function loc(startToken) {\n    var _this$_options4;\n\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  }\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\n  ;\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  }\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n  ;\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\n  }\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return undefined.\r\n   */\n  ;\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return undefined;\n  }\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\n  ;\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\n    }\n  }\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\n  ;\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return true;\n    }\n\n    return false;\n  }\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\n  ;\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\n  }\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n  ;\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  }\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n  ;\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\n  ;\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  }\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\n  ;\n\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\n    this.expectOptionalToken(delimiterKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (this.expectOptionalToken(delimiterKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\n}\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\n\n\nfunction getTokenKindDesc(kind) {\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\n}","map":{"version":3,"sources":["C:/Users/chena/QbitesReact/my-app/node_modules/graphql/language/parser.mjs"],"names":["syntaxError","Kind","Location","TokenKind","Source","isSource","DirectiveLocation","Lexer","isPunctuatorTokenKind","parse","source","options","parser","Parser","parseDocument","parseValue","expectToken","SOF","value","parseValueLiteral","EOF","parseType","type","parseTypeReference","sourceObj","_lexer","_options","_proto","prototype","parseName","token","NAME","kind","loc","start","DOCUMENT","definitions","many","parseDefinition","peek","parseOperationDefinition","parseFragmentDefinition","parseTypeSystemDefinition","parseTypeSystemExtension","BRACE_L","peekDescription","unexpected","OPERATION_DEFINITION","operation","name","undefined","variableDefinitions","directives","selectionSet","parseSelectionSet","parseOperationType","parseVariableDefinitions","parseDirectives","operationToken","optionalMany","PAREN_L","parseVariableDefinition","PAREN_R","VARIABLE_DEFINITION","variable","parseVariable","COLON","defaultValue","expectOptionalToken","EQUALS","DOLLAR","VARIABLE","SELECTION_SET","selections","parseSelection","BRACE_R","SPREAD","parseFragment","parseField","nameOrAlias","alias","FIELD","arguments","parseArguments","isConst","item","parseConstArgument","parseArgument","ARGUMENT","hasTypeCondition","expectOptionalKeyword","FRAGMENT_SPREAD","parseFragmentName","INLINE_FRAGMENT","typeCondition","parseNamedType","_this$_options","expectKeyword","experimentalFragmentVariables","FRAGMENT_DEFINITION","BRACKET_L","parseList","parseObject","INT","advance","FLOAT","STRING","BLOCK_STRING","parseStringLiteral","BOOLEAN","NULL","ENUM","block","_this","LIST","values","any","BRACKET_R","_this2","parseObjectField","OBJECT","fields","OBJECT_FIELD","AT","push","parseDirective","DIRECTIVE","LIST_TYPE","BANG","NON_NULL_TYPE","NAMED_TYPE","keywordToken","lookahead","parseSchemaDefinition","parseScalarTypeDefinition","parseObjectTypeDefinition","parseInterfaceTypeDefinition","parseUnionTypeDefinition","parseEnumTypeDefinition","parseInputObjectTypeDefinition","parseDirectiveDefinition","parseDescription","description","operationTypes","parseOperationTypeDefinition","SCHEMA_DEFINITION","OPERATION_TYPE_DEFINITION","SCALAR_TYPE_DEFINITION","interfaces","parseImplementsInterfaces","parseFieldsDefinition","OBJECT_TYPE_DEFINITION","_this$_options2","allowLegacySDLImplementsInterfaces","types","AMP","delimitedMany","_this$_options3","allowLegacySDLEmptyFields","parseFieldDefinition","args","parseArgumentDefs","FIELD_DEFINITION","parseInputValueDef","INPUT_VALUE_DEFINITION","INTERFACE_TYPE_DEFINITION","parseUnionMemberTypes","UNION_TYPE_DEFINITION","PIPE","parseEnumValuesDefinition","ENUM_TYPE_DEFINITION","parseEnumValueDefinition","ENUM_VALUE_DEFINITION","parseInputFieldsDefinition","INPUT_OBJECT_TYPE_DEFINITION","parseSchemaExtension","parseScalarTypeExtension","parseObjectTypeExtension","parseInterfaceTypeExtension","parseUnionTypeExtension","parseEnumTypeExtension","parseInputObjectTypeExtension","length","SCHEMA_EXTENSION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_EXTENSION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_EXTENSION","repeatable","locations","parseDirectiveLocations","DIRECTIVE_DEFINITION","parseDirectiveLocation","startToken","_this$_options4","noLocation","lastToken","concat","getTokenKindDesc","getTokenDesc","atToken","openKind","parseFn","closeKind","nodes","call","delimiterKind"],"mappings":"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","sourcesContent":["import { syntaxError } from \"../error/syntaxError.mjs\";\r\nimport { Kind } from \"./kinds.mjs\";\r\nimport { Location } from \"./ast.mjs\";\r\nimport { TokenKind } from \"./tokenKind.mjs\";\r\nimport { Source, isSource } from \"./source.mjs\";\r\nimport { DirectiveLocation } from \"./directiveLocation.mjs\";\r\nimport { Lexer, isPunctuatorTokenKind } from \"./lexer.mjs\";\r\n/**\r\n * Configuration options to control parser behavior\r\n */\r\n\r\n/**\r\n * Given a GraphQL source, parses it into a Document.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n */\r\nexport function parse(source, options) {\r\n  var parser = new Parser(source, options);\r\n  return parser.parseDocument();\r\n}\r\n/**\r\n * Given a string containing a GraphQL value (ex. `[42]`), parse the AST for\r\n * that value.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Values directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: valueFromAST().\r\n */\r\n\r\nexport function parseValue(source, options) {\r\n  var parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  var value = parser.parseValueLiteral(false);\r\n  parser.expectToken(TokenKind.EOF);\r\n  return value;\r\n}\r\n/**\r\n * Given a string containing a GraphQL Type (ex. `[Int!]`), parse the AST for\r\n * that type.\r\n * Throws GraphQLError if a syntax error is encountered.\r\n *\r\n * This is useful within tools that operate upon GraphQL Types directly and\r\n * in isolation of complete GraphQL documents.\r\n *\r\n * Consider providing the results to the utility function: typeFromAST().\r\n */\r\n\r\nexport function parseType(source, options) {\r\n  var parser = new Parser(source, options);\r\n  parser.expectToken(TokenKind.SOF);\r\n  var type = parser.parseTypeReference();\r\n  parser.expectToken(TokenKind.EOF);\r\n  return type;\r\n}\r\n/**\r\n * This class is exported only to assist people in implementing their own parsers\r\n * without duplicating too much code and should be used only as last resort for cases\r\n * such as experimental syntax or if certain features could not be contributed upstream.\r\n *\r\n * It is still part of the internal API and is versioned, so any changes to it are never\r\n * considered breaking changes. If you still need to support multiple versions of the\r\n * library, please use the `versionInfo` variable for version detection.\r\n *\r\n * @internal\r\n */\r\n\r\nexport var Parser = /*#__PURE__*/function () {\r\n  function Parser(source, options) {\r\n    var sourceObj = isSource(source) ? source : new Source(source);\r\n    this._lexer = new Lexer(sourceObj);\r\n    this._options = options;\r\n  }\r\n  /**\r\n   * Converts a name lex token into a name parse node.\r\n   */\r\n\r\n\r\n  var _proto = Parser.prototype;\r\n\r\n  _proto.parseName = function parseName() {\r\n    var token = this.expectToken(TokenKind.NAME);\r\n    return {\r\n      kind: Kind.NAME,\r\n      value: token.value,\r\n      loc: this.loc(token)\r\n    };\r\n  } // Implements the parsing rules in the Document section.\r\n\r\n  /**\r\n   * Document : Definition+\r\n   */\r\n  ;\r\n\r\n  _proto.parseDocument = function parseDocument() {\r\n    var start = this._lexer.token;\r\n    return {\r\n      kind: Kind.DOCUMENT,\r\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * Definition :\r\n   *   - ExecutableDefinition\r\n   *   - TypeSystemDefinition\r\n   *   - TypeSystemExtension\r\n   *\r\n   * ExecutableDefinition :\r\n   *   - OperationDefinition\r\n   *   - FragmentDefinition\r\n   */\r\n  ;\r\n\r\n  _proto.parseDefinition = function parseDefinition() {\r\n    if (this.peek(TokenKind.NAME)) {\r\n      switch (this._lexer.token.value) {\r\n        case 'query':\r\n        case 'mutation':\r\n        case 'subscription':\r\n          return this.parseOperationDefinition();\r\n\r\n        case 'fragment':\r\n          return this.parseFragmentDefinition();\r\n\r\n        case 'schema':\r\n        case 'scalar':\r\n        case 'type':\r\n        case 'interface':\r\n        case 'union':\r\n        case 'enum':\r\n        case 'input':\r\n        case 'directive':\r\n          return this.parseTypeSystemDefinition();\r\n\r\n        case 'extend':\r\n          return this.parseTypeSystemExtension();\r\n      }\r\n    } else if (this.peek(TokenKind.BRACE_L)) {\r\n      return this.parseOperationDefinition();\r\n    } else if (this.peekDescription()) {\r\n      return this.parseTypeSystemDefinition();\r\n    }\r\n\r\n    throw this.unexpected();\r\n  } // Implements the parsing rules in the Operations section.\r\n\r\n  /**\r\n   * OperationDefinition :\r\n   *  - SelectionSet\r\n   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\r\n   */\r\n  ;\r\n\r\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\r\n    var start = this._lexer.token;\r\n\r\n    if (this.peek(TokenKind.BRACE_L)) {\r\n      return {\r\n        kind: Kind.OPERATION_DEFINITION,\r\n        operation: 'query',\r\n        name: undefined,\r\n        variableDefinitions: [],\r\n        directives: [],\r\n        selectionSet: this.parseSelectionSet(),\r\n        loc: this.loc(start)\r\n      };\r\n    }\r\n\r\n    var operation = this.parseOperationType();\r\n    var name;\r\n\r\n    if (this.peek(TokenKind.NAME)) {\r\n      name = this.parseName();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.OPERATION_DEFINITION,\r\n      operation: operation,\r\n      name: name,\r\n      variableDefinitions: this.parseVariableDefinitions(),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * OperationType : one of query mutation subscription\r\n   */\r\n  ;\r\n\r\n  _proto.parseOperationType = function parseOperationType() {\r\n    var operationToken = this.expectToken(TokenKind.NAME);\r\n\r\n    switch (operationToken.value) {\r\n      case 'query':\r\n        return 'query';\r\n\r\n      case 'mutation':\r\n        return 'mutation';\r\n\r\n      case 'subscription':\r\n        return 'subscription';\r\n    }\r\n\r\n    throw this.unexpected(operationToken);\r\n  }\r\n  /**\r\n   * VariableDefinitions : ( VariableDefinition+ )\r\n   */\r\n  ;\r\n\r\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\r\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?\r\n   */\r\n  ;\r\n\r\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\r\n    var start = this._lexer.token;\r\n    return {\r\n      kind: Kind.VARIABLE_DEFINITION,\r\n      variable: this.parseVariable(),\r\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\r\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : undefined,\r\n      directives: this.parseDirectives(true),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * Variable : $ Name\r\n   */\r\n  ;\r\n\r\n  _proto.parseVariable = function parseVariable() {\r\n    var start = this._lexer.token;\r\n    this.expectToken(TokenKind.DOLLAR);\r\n    return {\r\n      kind: Kind.VARIABLE,\r\n      name: this.parseName(),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * SelectionSet : { Selection+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseSelectionSet = function parseSelectionSet() {\r\n    var start = this._lexer.token;\r\n    return {\r\n      kind: Kind.SELECTION_SET,\r\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * Selection :\r\n   *   - Field\r\n   *   - FragmentSpread\r\n   *   - InlineFragment\r\n   */\r\n  ;\r\n\r\n  _proto.parseSelection = function parseSelection() {\r\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\r\n  }\r\n  /**\r\n   * Field : Alias? Name Arguments? Directives? SelectionSet?\r\n   *\r\n   * Alias : Name :\r\n   */\r\n  ;\r\n\r\n  _proto.parseField = function parseField() {\r\n    var start = this._lexer.token;\r\n    var nameOrAlias = this.parseName();\r\n    var alias;\r\n    var name;\r\n\r\n    if (this.expectOptionalToken(TokenKind.COLON)) {\r\n      alias = nameOrAlias;\r\n      name = this.parseName();\r\n    } else {\r\n      name = nameOrAlias;\r\n    }\r\n\r\n    return {\r\n      kind: Kind.FIELD,\r\n      alias: alias,\r\n      name: name,\r\n      arguments: this.parseArguments(false),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * Arguments[Const] : ( Argument[?Const]+ )\r\n   */\r\n  ;\r\n\r\n  _proto.parseArguments = function parseArguments(isConst) {\r\n    var item = isConst ? this.parseConstArgument : this.parseArgument;\r\n    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * Argument[Const] : Name : Value[?Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseArgument = function parseArgument() {\r\n    var start = this._lexer.token;\r\n    var name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return {\r\n      kind: Kind.ARGUMENT,\r\n      name: name,\r\n      value: this.parseValueLiteral(false),\r\n      loc: this.loc(start)\r\n    };\r\n  };\r\n\r\n  _proto.parseConstArgument = function parseConstArgument() {\r\n    var start = this._lexer.token;\r\n    return {\r\n      kind: Kind.ARGUMENT,\r\n      name: this.parseName(),\r\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),\r\n      loc: this.loc(start)\r\n    };\r\n  } // Implements the parsing rules in the Fragments section.\r\n\r\n  /**\r\n   * Corresponds to both FragmentSpread and InlineFragment in the spec.\r\n   *\r\n   * FragmentSpread : ... FragmentName Directives?\r\n   *\r\n   * InlineFragment : ... TypeCondition? Directives? SelectionSet\r\n   */\r\n  ;\r\n\r\n  _proto.parseFragment = function parseFragment() {\r\n    var start = this._lexer.token;\r\n    this.expectToken(TokenKind.SPREAD);\r\n    var hasTypeCondition = this.expectOptionalKeyword('on');\r\n\r\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\r\n      return {\r\n        kind: Kind.FRAGMENT_SPREAD,\r\n        name: this.parseFragmentName(),\r\n        directives: this.parseDirectives(false),\r\n        loc: this.loc(start)\r\n      };\r\n    }\r\n\r\n    return {\r\n      kind: Kind.INLINE_FRAGMENT,\r\n      typeCondition: hasTypeCondition ? this.parseNamedType() : undefined,\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * FragmentDefinition :\r\n   *   - fragment FragmentName on TypeCondition Directives? SelectionSet\r\n   *\r\n   * TypeCondition : NamedType\r\n   */\r\n  ;\r\n\r\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\r\n    var _this$_options;\r\n\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('fragment'); // Experimental support for defining variables within fragments changes\r\n    // the grammar of FragmentDefinition:\r\n    //   - fragment FragmentName VariableDefinitions? on TypeCondition Directives? SelectionSet\r\n\r\n    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {\r\n      return {\r\n        kind: Kind.FRAGMENT_DEFINITION,\r\n        name: this.parseFragmentName(),\r\n        variableDefinitions: this.parseVariableDefinitions(),\r\n        typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n        directives: this.parseDirectives(false),\r\n        selectionSet: this.parseSelectionSet(),\r\n        loc: this.loc(start)\r\n      };\r\n    }\r\n\r\n    return {\r\n      kind: Kind.FRAGMENT_DEFINITION,\r\n      name: this.parseFragmentName(),\r\n      typeCondition: (this.expectKeyword('on'), this.parseNamedType()),\r\n      directives: this.parseDirectives(false),\r\n      selectionSet: this.parseSelectionSet(),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * FragmentName : Name but not `on`\r\n   */\r\n  ;\r\n\r\n  _proto.parseFragmentName = function parseFragmentName() {\r\n    if (this._lexer.token.value === 'on') {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return this.parseName();\r\n  } // Implements the parsing rules in the Values section.\r\n\r\n  /**\r\n   * Value[Const] :\r\n   *   - [~Const] Variable\r\n   *   - IntValue\r\n   *   - FloatValue\r\n   *   - StringValue\r\n   *   - BooleanValue\r\n   *   - NullValue\r\n   *   - EnumValue\r\n   *   - ListValue[?Const]\r\n   *   - ObjectValue[?Const]\r\n   *\r\n   * BooleanValue : one of `true` `false`\r\n   *\r\n   * NullValue : `null`\r\n   *\r\n   * EnumValue : Name but not `true`, `false` or `null`\r\n   */\r\n  ;\r\n\r\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\r\n    var token = this._lexer.token;\r\n\r\n    switch (token.kind) {\r\n      case TokenKind.BRACKET_L:\r\n        return this.parseList(isConst);\r\n\r\n      case TokenKind.BRACE_L:\r\n        return this.parseObject(isConst);\r\n\r\n      case TokenKind.INT:\r\n        this._lexer.advance();\r\n\r\n        return {\r\n          kind: Kind.INT,\r\n          value: token.value,\r\n          loc: this.loc(token)\r\n        };\r\n\r\n      case TokenKind.FLOAT:\r\n        this._lexer.advance();\r\n\r\n        return {\r\n          kind: Kind.FLOAT,\r\n          value: token.value,\r\n          loc: this.loc(token)\r\n        };\r\n\r\n      case TokenKind.STRING:\r\n      case TokenKind.BLOCK_STRING:\r\n        return this.parseStringLiteral();\r\n\r\n      case TokenKind.NAME:\r\n        this._lexer.advance();\r\n\r\n        switch (token.value) {\r\n          case 'true':\r\n            return {\r\n              kind: Kind.BOOLEAN,\r\n              value: true,\r\n              loc: this.loc(token)\r\n            };\r\n\r\n          case 'false':\r\n            return {\r\n              kind: Kind.BOOLEAN,\r\n              value: false,\r\n              loc: this.loc(token)\r\n            };\r\n\r\n          case 'null':\r\n            return {\r\n              kind: Kind.NULL,\r\n              loc: this.loc(token)\r\n            };\r\n\r\n          default:\r\n            return {\r\n              kind: Kind.ENUM,\r\n              value: token.value,\r\n              loc: this.loc(token)\r\n            };\r\n        }\r\n\r\n      case TokenKind.DOLLAR:\r\n        if (!isConst) {\r\n          return this.parseVariable();\r\n        }\r\n\r\n        break;\r\n    }\r\n\r\n    throw this.unexpected();\r\n  };\r\n\r\n  _proto.parseStringLiteral = function parseStringLiteral() {\r\n    var token = this._lexer.token;\r\n\r\n    this._lexer.advance();\r\n\r\n    return {\r\n      kind: Kind.STRING,\r\n      value: token.value,\r\n      block: token.kind === TokenKind.BLOCK_STRING,\r\n      loc: this.loc(token)\r\n    };\r\n  }\r\n  /**\r\n   * ListValue[Const] :\r\n   *   - [ ]\r\n   *   - [ Value[?Const]+ ]\r\n   */\r\n  ;\r\n\r\n  _proto.parseList = function parseList(isConst) {\r\n    var _this = this;\r\n\r\n    var start = this._lexer.token;\r\n\r\n    var item = function item() {\r\n      return _this.parseValueLiteral(isConst);\r\n    };\r\n\r\n    return {\r\n      kind: Kind.LIST,\r\n      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ObjectValue[Const] :\r\n   *   - { }\r\n   *   - { ObjectField[?Const]+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseObject = function parseObject(isConst) {\r\n    var _this2 = this;\r\n\r\n    var start = this._lexer.token;\r\n\r\n    var item = function item() {\r\n      return _this2.parseObjectField(isConst);\r\n    };\r\n\r\n    return {\r\n      kind: Kind.OBJECT,\r\n      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ObjectField[Const] : Name : Value[?Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseObjectField = function parseObjectField(isConst) {\r\n    var start = this._lexer.token;\r\n    var name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    return {\r\n      kind: Kind.OBJECT_FIELD,\r\n      name: name,\r\n      value: this.parseValueLiteral(isConst),\r\n      loc: this.loc(start)\r\n    };\r\n  } // Implements the parsing rules in the Directives section.\r\n\r\n  /**\r\n   * Directives[Const] : Directive[?Const]+\r\n   */\r\n  ;\r\n\r\n  _proto.parseDirectives = function parseDirectives(isConst) {\r\n    var directives = [];\r\n\r\n    while (this.peek(TokenKind.AT)) {\r\n      directives.push(this.parseDirective(isConst));\r\n    }\r\n\r\n    return directives;\r\n  }\r\n  /**\r\n   * Directive[Const] : @ Name Arguments[?Const]?\r\n   */\r\n  ;\r\n\r\n  _proto.parseDirective = function parseDirective(isConst) {\r\n    var start = this._lexer.token;\r\n    this.expectToken(TokenKind.AT);\r\n    return {\r\n      kind: Kind.DIRECTIVE,\r\n      name: this.parseName(),\r\n      arguments: this.parseArguments(isConst),\r\n      loc: this.loc(start)\r\n    };\r\n  } // Implements the parsing rules in the Types section.\r\n\r\n  /**\r\n   * Type :\r\n   *   - NamedType\r\n   *   - ListType\r\n   *   - NonNullType\r\n   */\r\n  ;\r\n\r\n  _proto.parseTypeReference = function parseTypeReference() {\r\n    var start = this._lexer.token;\r\n    var type;\r\n\r\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\r\n      type = this.parseTypeReference();\r\n      this.expectToken(TokenKind.BRACKET_R);\r\n      type = {\r\n        kind: Kind.LIST_TYPE,\r\n        type: type,\r\n        loc: this.loc(start)\r\n      };\r\n    } else {\r\n      type = this.parseNamedType();\r\n    }\r\n\r\n    if (this.expectOptionalToken(TokenKind.BANG)) {\r\n      return {\r\n        kind: Kind.NON_NULL_TYPE,\r\n        type: type,\r\n        loc: this.loc(start)\r\n      };\r\n    }\r\n\r\n    return type;\r\n  }\r\n  /**\r\n   * NamedType : Name\r\n   */\r\n  ;\r\n\r\n  _proto.parseNamedType = function parseNamedType() {\r\n    var start = this._lexer.token;\r\n    return {\r\n      kind: Kind.NAMED_TYPE,\r\n      name: this.parseName(),\r\n      loc: this.loc(start)\r\n    };\r\n  } // Implements the parsing rules in the Type Definition section.\r\n\r\n  /**\r\n   * TypeSystemDefinition :\r\n   *   - SchemaDefinition\r\n   *   - TypeDefinition\r\n   *   - DirectiveDefinition\r\n   *\r\n   * TypeDefinition :\r\n   *   - ScalarTypeDefinition\r\n   *   - ObjectTypeDefinition\r\n   *   - InterfaceTypeDefinition\r\n   *   - UnionTypeDefinition\r\n   *   - EnumTypeDefinition\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n  ;\r\n\r\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\r\n    // Many definitions begin with a description and require a lookahead.\r\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaDefinition();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeDefinition();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeDefinition();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeDefinition();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeDefinition();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeDefinition();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeDefinition();\r\n\r\n        case 'directive':\r\n          return this.parseDirectiveDefinition();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  };\r\n\r\n  _proto.peekDescription = function peekDescription() {\r\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\r\n  }\r\n  /**\r\n   * Description : StringValue\r\n   */\r\n  ;\r\n\r\n  _proto.parseDescription = function parseDescription() {\r\n    if (this.peekDescription()) {\r\n      return this.parseStringLiteral();\r\n    }\r\n  }\r\n  /**\r\n   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('schema');\r\n    var directives = this.parseDirectives(true);\r\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\r\n    return {\r\n      kind: Kind.SCHEMA_DEFINITION,\r\n      description: description,\r\n      directives: directives,\r\n      operationTypes: operationTypes,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * OperationTypeDefinition : OperationType : NamedType\r\n   */\r\n  ;\r\n\r\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var operation = this.parseOperationType();\r\n    this.expectToken(TokenKind.COLON);\r\n    var type = this.parseNamedType();\r\n    return {\r\n      kind: Kind.OPERATION_TYPE_DEFINITION,\r\n      operation: operation,\r\n      type: type,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?\r\n   */\r\n  ;\r\n\r\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('scalar');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    return {\r\n      kind: Kind.SCALAR_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      directives: directives,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ObjectTypeDefinition :\r\n   *   Description?\r\n   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?\r\n   */\r\n  ;\r\n\r\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('type');\r\n    var name = this.parseName();\r\n    var interfaces = this.parseImplementsInterfaces();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseFieldsDefinition();\r\n    return {\r\n      kind: Kind.OBJECT_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      interfaces: interfaces,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ImplementsInterfaces :\r\n   *   - implements `&`? NamedType\r\n   *   - ImplementsInterfaces & NamedType\r\n   */\r\n  ;\r\n\r\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\r\n    var _this$_options2;\r\n\r\n    if (!this.expectOptionalKeyword('implements')) {\r\n      return [];\r\n    }\r\n\r\n    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {\r\n      var types = []; // Optional leading ampersand\r\n\r\n      this.expectOptionalToken(TokenKind.AMP);\r\n\r\n      do {\r\n        types.push(this.parseNamedType());\r\n      } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));\r\n\r\n      return types;\r\n    }\r\n\r\n    return this.delimitedMany(TokenKind.AMP, this.parseNamedType);\r\n  }\r\n  /**\r\n   * FieldsDefinition : { FieldDefinition+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\r\n    var _this$_options3;\r\n\r\n    // Legacy support for the SDL?\r\n    if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\r\n      this._lexer.advance();\r\n\r\n      this._lexer.advance();\r\n\r\n      return [];\r\n    }\r\n\r\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\r\n  }\r\n  /**\r\n   * FieldDefinition :\r\n   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?\r\n   */\r\n  ;\r\n\r\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    var name = this.parseName();\r\n    var args = this.parseArgumentDefs();\r\n    this.expectToken(TokenKind.COLON);\r\n    var type = this.parseTypeReference();\r\n    var directives = this.parseDirectives(true);\r\n    return {\r\n      kind: Kind.FIELD_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      arguments: args,\r\n      type: type,\r\n      directives: directives,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ArgumentsDefinition : ( InputValueDefinition+ )\r\n   */\r\n  ;\r\n\r\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\r\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\r\n  }\r\n  /**\r\n   * InputValueDefinition :\r\n   *   - Description? Name : Type DefaultValue? Directives[Const]?\r\n   */\r\n  ;\r\n\r\n  _proto.parseInputValueDef = function parseInputValueDef() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    var name = this.parseName();\r\n    this.expectToken(TokenKind.COLON);\r\n    var type = this.parseTypeReference();\r\n    var defaultValue;\r\n\r\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\r\n      defaultValue = this.parseValueLiteral(true);\r\n    }\r\n\r\n    var directives = this.parseDirectives(true);\r\n    return {\r\n      kind: Kind.INPUT_VALUE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      type: type,\r\n      defaultValue: defaultValue,\r\n      directives: directives,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * InterfaceTypeDefinition :\r\n   *   - Description? interface Name Directives[Const]? FieldsDefinition?\r\n   */\r\n  ;\r\n\r\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('interface');\r\n    var name = this.parseName();\r\n    var interfaces = this.parseImplementsInterfaces();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseFieldsDefinition();\r\n    return {\r\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      interfaces: interfaces,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * UnionTypeDefinition :\r\n   *   - Description? union Name Directives[Const]? UnionMemberTypes?\r\n   */\r\n  ;\r\n\r\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('union');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var types = this.parseUnionMemberTypes();\r\n    return {\r\n      kind: Kind.UNION_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      directives: directives,\r\n      types: types,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * UnionMemberTypes :\r\n   *   - = `|`? NamedType\r\n   *   - UnionMemberTypes | NamedType\r\n   */\r\n  ;\r\n\r\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\r\n    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];\r\n  }\r\n  /**\r\n   * EnumTypeDefinition :\r\n   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?\r\n   */\r\n  ;\r\n\r\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('enum');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var values = this.parseEnumValuesDefinition();\r\n    return {\r\n      kind: Kind.ENUM_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      directives: directives,\r\n      values: values,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * EnumValuesDefinition : { EnumValueDefinition+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\r\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\r\n  }\r\n  /**\r\n   * EnumValueDefinition : Description? EnumValue Directives[Const]?\r\n   *\r\n   * EnumValue : Name\r\n   */\r\n  ;\r\n\r\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    return {\r\n      kind: Kind.ENUM_VALUE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      directives: directives,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * InputObjectTypeDefinition :\r\n   *   - Description? input Name Directives[Const]? InputFieldsDefinition?\r\n   */\r\n  ;\r\n\r\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('input');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseInputFieldsDefinition();\r\n    return {\r\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * InputFieldsDefinition : { InputValueDefinition+ }\r\n   */\r\n  ;\r\n\r\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\r\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\r\n  }\r\n  /**\r\n   * TypeSystemExtension :\r\n   *   - SchemaExtension\r\n   *   - TypeExtension\r\n   *\r\n   * TypeExtension :\r\n   *   - ScalarTypeExtension\r\n   *   - ObjectTypeExtension\r\n   *   - InterfaceTypeExtension\r\n   *   - UnionTypeExtension\r\n   *   - EnumTypeExtension\r\n   *   - InputObjectTypeDefinition\r\n   */\r\n  ;\r\n\r\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\r\n    var keywordToken = this._lexer.lookahead();\r\n\r\n    if (keywordToken.kind === TokenKind.NAME) {\r\n      switch (keywordToken.value) {\r\n        case 'schema':\r\n          return this.parseSchemaExtension();\r\n\r\n        case 'scalar':\r\n          return this.parseScalarTypeExtension();\r\n\r\n        case 'type':\r\n          return this.parseObjectTypeExtension();\r\n\r\n        case 'interface':\r\n          return this.parseInterfaceTypeExtension();\r\n\r\n        case 'union':\r\n          return this.parseUnionTypeExtension();\r\n\r\n        case 'enum':\r\n          return this.parseEnumTypeExtension();\r\n\r\n        case 'input':\r\n          return this.parseInputObjectTypeExtension();\r\n      }\r\n    }\r\n\r\n    throw this.unexpected(keywordToken);\r\n  }\r\n  /**\r\n   * SchemaExtension :\r\n   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }\r\n   *  - extend schema Directives[Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('schema');\r\n    var directives = this.parseDirectives(true);\r\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\r\n\r\n    if (directives.length === 0 && operationTypes.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.SCHEMA_EXTENSION,\r\n      directives: directives,\r\n      operationTypes: operationTypes,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ScalarTypeExtension :\r\n   *   - extend scalar Name Directives[Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('scalar');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n\r\n    if (directives.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.SCALAR_TYPE_EXTENSION,\r\n      name: name,\r\n      directives: directives,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * ObjectTypeExtension :\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend type Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend type Name ImplementsInterfaces\r\n   */\r\n  ;\r\n\r\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('type');\r\n    var name = this.parseName();\r\n    var interfaces = this.parseImplementsInterfaces();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseFieldsDefinition();\r\n\r\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.OBJECT_TYPE_EXTENSION,\r\n      name: name,\r\n      interfaces: interfaces,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * InterfaceTypeExtension :\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition\r\n   *  - extend interface Name ImplementsInterfaces? Directives[Const]\r\n   *  - extend interface Name ImplementsInterfaces\r\n   */\r\n  ;\r\n\r\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('interface');\r\n    var name = this.parseName();\r\n    var interfaces = this.parseImplementsInterfaces();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseFieldsDefinition();\r\n\r\n    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\r\n      name: name,\r\n      interfaces: interfaces,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * UnionTypeExtension :\r\n   *   - extend union Name Directives[Const]? UnionMemberTypes\r\n   *   - extend union Name Directives[Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('union');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var types = this.parseUnionMemberTypes();\r\n\r\n    if (directives.length === 0 && types.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.UNION_TYPE_EXTENSION,\r\n      name: name,\r\n      directives: directives,\r\n      types: types,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * EnumTypeExtension :\r\n   *   - extend enum Name Directives[Const]? EnumValuesDefinition\r\n   *   - extend enum Name Directives[Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('enum');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var values = this.parseEnumValuesDefinition();\r\n\r\n    if (directives.length === 0 && values.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.ENUM_TYPE_EXTENSION,\r\n      name: name,\r\n      directives: directives,\r\n      values: values,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * InputObjectTypeExtension :\r\n   *   - extend input Name Directives[Const]? InputFieldsDefinition\r\n   *   - extend input Name Directives[Const]\r\n   */\r\n  ;\r\n\r\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\r\n    var start = this._lexer.token;\r\n    this.expectKeyword('extend');\r\n    this.expectKeyword('input');\r\n    var name = this.parseName();\r\n    var directives = this.parseDirectives(true);\r\n    var fields = this.parseInputFieldsDefinition();\r\n\r\n    if (directives.length === 0 && fields.length === 0) {\r\n      throw this.unexpected();\r\n    }\r\n\r\n    return {\r\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\r\n      name: name,\r\n      directives: directives,\r\n      fields: fields,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * DirectiveDefinition :\r\n   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations\r\n   */\r\n  ;\r\n\r\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\r\n    var start = this._lexer.token;\r\n    var description = this.parseDescription();\r\n    this.expectKeyword('directive');\r\n    this.expectToken(TokenKind.AT);\r\n    var name = this.parseName();\r\n    var args = this.parseArgumentDefs();\r\n    var repeatable = this.expectOptionalKeyword('repeatable');\r\n    this.expectKeyword('on');\r\n    var locations = this.parseDirectiveLocations();\r\n    return {\r\n      kind: Kind.DIRECTIVE_DEFINITION,\r\n      description: description,\r\n      name: name,\r\n      arguments: args,\r\n      repeatable: repeatable,\r\n      locations: locations,\r\n      loc: this.loc(start)\r\n    };\r\n  }\r\n  /**\r\n   * DirectiveLocations :\r\n   *   - `|`? DirectiveLocation\r\n   *   - DirectiveLocations | DirectiveLocation\r\n   */\r\n  ;\r\n\r\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\r\n    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);\r\n  }\r\n  /*\r\n   * DirectiveLocation :\r\n   *   - ExecutableDirectiveLocation\r\n   *   - TypeSystemDirectiveLocation\r\n   *\r\n   * ExecutableDirectiveLocation : one of\r\n   *   `QUERY`\r\n   *   `MUTATION`\r\n   *   `SUBSCRIPTION`\r\n   *   `FIELD`\r\n   *   `FRAGMENT_DEFINITION`\r\n   *   `FRAGMENT_SPREAD`\r\n   *   `INLINE_FRAGMENT`\r\n   *\r\n   * TypeSystemDirectiveLocation : one of\r\n   *   `SCHEMA`\r\n   *   `SCALAR`\r\n   *   `OBJECT`\r\n   *   `FIELD_DEFINITION`\r\n   *   `ARGUMENT_DEFINITION`\r\n   *   `INTERFACE`\r\n   *   `UNION`\r\n   *   `ENUM`\r\n   *   `ENUM_VALUE`\r\n   *   `INPUT_OBJECT`\r\n   *   `INPUT_FIELD_DEFINITION`\r\n   */\r\n  ;\r\n\r\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\r\n    var start = this._lexer.token;\r\n    var name = this.parseName();\r\n\r\n    if (DirectiveLocation[name.value] !== undefined) {\r\n      return name;\r\n    }\r\n\r\n    throw this.unexpected(start);\r\n  } // Core parsing utility functions\r\n\r\n  /**\r\n   * Returns a location object, used to identify the place in the source that created a given parsed object.\r\n   */\r\n  ;\r\n\r\n  _proto.loc = function loc(startToken) {\r\n    var _this$_options4;\r\n\r\n    if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {\r\n      return new Location(startToken, this._lexer.lastToken, this._lexer.source);\r\n    }\r\n  }\r\n  /**\r\n   * Determines if the next token is of a given kind\r\n   */\r\n  ;\r\n\r\n  _proto.peek = function peek(kind) {\r\n    return this._lexer.token.kind === kind;\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n  ;\r\n\r\n  _proto.expectToken = function expectToken(kind) {\r\n    var token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this._lexer.advance();\r\n\r\n      return token;\r\n    }\r\n\r\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(getTokenKindDesc(kind), \", found \").concat(getTokenDesc(token), \".\"));\r\n  }\r\n  /**\r\n   * If the next token is of the given kind, return that token after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return undefined.\r\n   */\r\n  ;\r\n\r\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\r\n    var token = this._lexer.token;\r\n\r\n    if (token.kind === kind) {\r\n      this._lexer.advance();\r\n\r\n      return token;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, advance the lexer.\r\n   * Otherwise, do not change the parser state and throw an error.\r\n   */\r\n  ;\r\n\r\n  _proto.expectKeyword = function expectKeyword(value) {\r\n    var token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this._lexer.advance();\r\n    } else {\r\n      throw syntaxError(this._lexer.source, token.start, \"Expected \\\"\".concat(value, \"\\\", found \").concat(getTokenDesc(token), \".\"));\r\n    }\r\n  }\r\n  /**\r\n   * If the next token is a given keyword, return \"true\" after advancing the lexer.\r\n   * Otherwise, do not change the parser state and return \"false\".\r\n   */\r\n  ;\r\n\r\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\r\n    var token = this._lexer.token;\r\n\r\n    if (token.kind === TokenKind.NAME && token.value === value) {\r\n      this._lexer.advance();\r\n\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /**\r\n   * Helper function for creating an error when an unexpected lexed token is encountered.\r\n   */\r\n  ;\r\n\r\n  _proto.unexpected = function unexpected(atToken) {\r\n    var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;\r\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token), \".\"));\r\n  }\r\n  /**\r\n   * Returns a possibly empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n  ;\r\n\r\n  _proto.any = function any(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    var nodes = [];\r\n\r\n    while (!this.expectOptionalToken(closeKind)) {\r\n      nodes.push(parseFn.call(this));\r\n    }\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a list of parse nodes, determined by the parseFn.\r\n   * It can be empty only if open token is missing otherwise it will always return non-empty list\r\n   * that begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n  ;\r\n\r\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\r\n    if (this.expectOptionalToken(openKind)) {\r\n      var nodes = [];\r\n\r\n      do {\r\n        nodes.push(parseFn.call(this));\r\n      } while (!this.expectOptionalToken(closeKind));\r\n\r\n      return nodes;\r\n    }\r\n\r\n    return [];\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list begins with a lex token of openKind and ends with a lex token of closeKind.\r\n   * Advances the parser to the next lex token after the closing token.\r\n   */\r\n  ;\r\n\r\n  _proto.many = function many(openKind, parseFn, closeKind) {\r\n    this.expectToken(openKind);\r\n    var nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (!this.expectOptionalToken(closeKind));\r\n\r\n    return nodes;\r\n  }\r\n  /**\r\n   * Returns a non-empty list of parse nodes, determined by the parseFn.\r\n   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.\r\n   * Advances the parser to the next lex token after last item in the list.\r\n   */\r\n  ;\r\n\r\n  _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {\r\n    this.expectOptionalToken(delimiterKind);\r\n    var nodes = [];\r\n\r\n    do {\r\n      nodes.push(parseFn.call(this));\r\n    } while (this.expectOptionalToken(delimiterKind));\r\n\r\n    return nodes;\r\n  };\r\n\r\n  return Parser;\r\n}();\r\n/**\r\n * A helper function to describe a token as a string for debugging.\r\n */\r\n\r\nfunction getTokenDesc(token) {\r\n  var value = token.value;\r\n  return getTokenKindDesc(token.kind) + (value != null ? \" \\\"\".concat(value, \"\\\"\") : '');\r\n}\r\n/**\r\n * A helper function to describe a token kind as a string for debugging.\r\n */\r\n\r\n\r\nfunction getTokenKindDesc(kind) {\r\n  return isPunctuatorTokenKind(kind) ? \"\\\"\".concat(kind, \"\\\"\") : kind;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}