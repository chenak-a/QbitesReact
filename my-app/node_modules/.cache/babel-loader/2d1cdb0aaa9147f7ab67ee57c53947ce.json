{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.renderSVG = renderSVG;\nexports.drawOnCanvas = drawOnCanvas;\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/* eslint-disable react/prop-types */\n\n\nfunction renderSVG(props) {\n  var className = props.className;\n  var edge = helper(props);\n  if (edge === null) return null;\n  var line = void 0,\n      coordinateBase = void 0,\n      coordinate = void 0;\n\n  if ((0, _utils.isDefined)(edge.line)) {\n    line = _react2.default.createElement(\"line\", {\n      className: \"react-stockcharts-cross-hair\",\n      strokeOpacity: edge.line.opacity,\n      stroke: edge.line.stroke,\n      strokeDasharray: (0, _utils.getStrokeDasharray)(edge.line.strokeDasharray),\n      x1: edge.line.x1,\n      y1: edge.line.y1,\n      x2: edge.line.x2,\n      y2: edge.line.y2\n    });\n  }\n\n  if ((0, _utils.isDefined)(edge.coordinateBase)) {\n    var _edge$coordinateBase = edge.coordinateBase,\n        rectWidth = _edge$coordinateBase.rectWidth,\n        rectHeight = _edge$coordinateBase.rectHeight,\n        arrowWidth = _edge$coordinateBase.arrowWidth;\n    var path = edge.orient === \"left\" ? \"M0,0L0,\" + rectHeight + \"L\" + rectWidth + \",\" + rectHeight + \"L\" + (rectWidth + arrowWidth) + \",10L\" + rectWidth + \",0L0,0L0,0\" : \"M0,\" + arrowWidth + \"L\" + arrowWidth + \",\" + rectHeight + \"L\" + (rectWidth + arrowWidth) + \",\" + rectHeight + \"L\" + (rectWidth + arrowWidth) + \",0L\" + arrowWidth + \",0L0,\" + arrowWidth;\n    coordinateBase = edge.orient === \"left\" || edge.orient === \"right\" ? _react2.default.createElement(\"g\", {\n      key: 1,\n      transform: \"translate(\" + edge.coordinateBase.edgeXRect + \",\" + edge.coordinateBase.edgeYRect + \")\"\n    }, _react2.default.createElement(\"path\", {\n      d: path,\n      className: \"react-stockchart-text-background\",\n      height: rectHeight,\n      width: rectWidth,\n      stroke: edge.coordinateBase.stroke,\n      strokeLinejoin: \"miter\",\n      strokeOpacity: edge.coordinateBase.strokeOpacity,\n      strokeWidth: edge.coordinateBase.strokeWidth,\n      fill: edge.coordinateBase.fill,\n      fillOpacity: edge.coordinateBase.opacity\n    })) : _react2.default.createElement(\"rect\", {\n      key: 1,\n      className: \"react-stockchart-text-background\",\n      x: edge.coordinateBase.edgeXRect,\n      y: edge.coordinateBase.edgeYRect,\n      height: rectHeight,\n      width: rectWidth,\n      fill: edge.coordinateBase.fill,\n      opacity: edge.coordinateBase.opacity\n    });\n    coordinate = _react2.default.createElement(\"text\", {\n      key: 2,\n      x: edge.coordinate.edgeXText,\n      y: edge.coordinate.edgeYText,\n      textAnchor: edge.coordinate.textAnchor,\n      fontFamily: edge.coordinate.fontFamily,\n      fontSize: edge.coordinate.fontSize,\n      dy: \".32em\",\n      fill: edge.coordinate.textFill\n    }, edge.coordinate.displayCoordinate);\n  }\n\n  return _react2.default.createElement(\"g\", {\n    className: className\n  }, line, coordinateBase, coordinate);\n}\n/* eslint-enable react/prop-types */\n\n\nfunction helper(props) {\n  var displayCoordinate = props.coordinate,\n      show = props.show,\n      type = props.type,\n      orient = props.orient,\n      edgeAt = props.edgeAt,\n      hideLine = props.hideLine,\n      lineStrokeDasharray = props.lineStrokeDasharray;\n  var fill = props.fill,\n      opacity = props.opacity,\n      fontFamily = props.fontFamily,\n      fontSize = props.fontSize,\n      textFill = props.textFill,\n      lineStroke = props.lineStroke,\n      lineOpacity = props.lineOpacity;\n  var stroke = props.stroke,\n      strokeOpacity = props.strokeOpacity,\n      strokeWidth = props.strokeWidth;\n  var arrowWidth = props.arrowWidth,\n      rectWidth = props.rectWidth,\n      rectHeight = props.rectHeight,\n      rectRadius = props.rectRadius;\n  var x1 = props.x1,\n      y1 = props.y1,\n      x2 = props.x2,\n      y2 = props.y2,\n      dx = props.dx;\n  if (!show) return null;\n  var coordinateBase = void 0,\n      coordinate = void 0;\n\n  if ((0, _utils.isDefined)(displayCoordinate)) {\n    var textAnchor = \"middle\"; // TODO: Below it is necessary to implement logic for the possibility of alignment from the right or from the left.\n\n    var edgeXRect = void 0,\n        edgeYRect = void 0,\n        edgeXText = void 0,\n        edgeYText = void 0;\n\n    if (type === \"horizontal\") {\n      edgeXRect = dx + (orient === \"right\" ? edgeAt + 1 : edgeAt - rectWidth - 1);\n      edgeYRect = y1 - rectHeight / 2 - strokeWidth;\n      edgeXText = dx + (orient === \"right\" ? edgeAt + rectWidth / 2 : edgeAt - rectWidth / 2);\n      edgeYText = y1;\n    } else {\n      var dy = orient === \"bottom\" ? strokeWidth - 1 : -strokeWidth + 1;\n      edgeXRect = x1 - rectWidth / 2;\n      edgeYRect = (orient === \"bottom\" ? edgeAt : edgeAt - rectHeight) + dy;\n      edgeXText = x1;\n      edgeYText = (orient === \"bottom\" ? edgeAt + rectHeight / 2 : edgeAt - rectHeight / 2) + dy;\n    }\n\n    coordinateBase = {\n      edgeXRect: edgeXRect,\n      edgeYRect: edgeYRect,\n      rectHeight: rectHeight + strokeWidth,\n      rectWidth: rectWidth,\n      rectRadius: rectRadius,\n      fill: fill,\n      opacity: opacity,\n      arrowWidth: arrowWidth,\n      stroke: stroke,\n      strokeOpacity: strokeOpacity,\n      strokeWidth: strokeWidth\n    };\n    coordinate = {\n      edgeXText: edgeXText,\n      edgeYText: edgeYText,\n      textAnchor: textAnchor,\n      fontFamily: fontFamily,\n      fontSize: fontSize,\n      textFill: textFill,\n      displayCoordinate: displayCoordinate\n    };\n  }\n\n  var line = hideLine ? undefined : {\n    opacity: lineOpacity,\n    stroke: lineStroke,\n    strokeDasharray: lineStrokeDasharray,\n    x1: x1,\n    y1: y1,\n    x2: x2,\n    y2: y2\n  };\n  return {\n    coordinateBase: coordinateBase,\n    coordinate: coordinate,\n    line: line,\n    orient: orient\n  };\n}\n\nfunction drawOnCanvas(ctx, props) {\n  var fontSize = props.fontSize,\n      fontFamily = props.fontFamily;\n  ctx.font = fontSize + \"px \" + fontFamily;\n  ctx.textBaseline = \"middle\";\n  var width = Math.round(ctx.measureText(props.coordinate).width + 10);\n  var edge = helper(_extends({}, props, {\n    rectWidth: width\n  }));\n  if (edge === null) return;\n\n  if ((0, _utils.isDefined)(edge.line)) {\n    var dashArray = (0, _utils.getStrokeDasharray)(edge.line.strokeDasharray).split(\",\").map(function (d) {\n      return +d;\n    });\n    ctx.setLineDash(dashArray);\n    ctx.strokeStyle = (0, _utils.hexToRGBA)(edge.line.stroke, edge.line.opacity);\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(edge.line.x1, edge.line.y1);\n    ctx.lineTo(edge.line.x2, edge.line.y2);\n    ctx.stroke();\n  }\n\n  ctx.setLineDash([]);\n\n  if ((0, _utils.isDefined)(edge.coordinateBase)) {\n    var _edge$coordinateBase2 = edge.coordinateBase,\n        rectWidth = _edge$coordinateBase2.rectWidth,\n        rectHeight = _edge$coordinateBase2.rectHeight,\n        rectRadius = _edge$coordinateBase2.rectRadius,\n        arrowWidth = _edge$coordinateBase2.arrowWidth;\n    ctx.fillStyle = (0, _utils.hexToRGBA)(edge.coordinateBase.fill, edge.coordinateBase.opacity);\n\n    if ((0, _utils.isDefined)(edge.coordinateBase.stroke)) {\n      ctx.strokeStyle = (0, _utils.hexToRGBA)(edge.coordinateBase.stroke, edge.coordinateBase.strokeOpacity);\n      ctx.lineWidth = edge.coordinateBase.strokeWidth;\n    }\n\n    var x = edge.coordinateBase.edgeXRect;\n    var y = edge.coordinateBase.edgeYRect;\n    var halfHeight = rectHeight / 2;\n    ctx.beginPath();\n\n    if (edge.orient === \"right\") {\n      x -= arrowWidth;\n      ctx.moveTo(x, y + halfHeight);\n      ctx.lineTo(x + arrowWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y + rectHeight);\n      ctx.lineTo(x + arrowWidth, y + rectHeight);\n      ctx.closePath();\n    } else if (edge.orient === \"left\") {\n      // x += arrowWidth;\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + rectWidth, y);\n      ctx.lineTo(x + rectWidth + arrowWidth, y + halfHeight);\n      ctx.lineTo(x + rectWidth, y + rectHeight);\n      ctx.lineTo(x, y + rectHeight);\n      ctx.closePath();\n    } else {\n      // console.error(x, y, rectWidth, rectHeight)\n      if (rectRadius) {\n        roundRect(ctx, x, y, rectWidth, rectHeight, 3);\n      } else {\n        ctx.rect(x, y, rectWidth, rectHeight);\n      }\n    }\n\n    ctx.fill();\n\n    if ((0, _utils.isDefined)(edge.coordinateBase.stroke)) {\n      ctx.stroke();\n    }\n\n    ctx.fillStyle = edge.coordinate.textFill;\n    ctx.textAlign = edge.coordinate.textAnchor === \"middle\" ? \"center\" : edge.coordinate.textAnchor;\n    ctx.fillText(edge.coordinate.displayCoordinate, edge.coordinate.edgeXText, edge.coordinate.edgeYText);\n  }\n}\n\nfunction roundRect(ctx, x, y, width, height, radius) {\n  ctx.beginPath();\n  ctx.moveTo(x + radius, y);\n  ctx.lineTo(x + width - radius, y);\n  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n  ctx.lineTo(x + width, y + height - radius);\n  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n  ctx.lineTo(x + radius, y + height);\n  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n  ctx.lineTo(x, y + radius);\n  ctx.quadraticCurveTo(x, y, x + radius, y);\n  ctx.closePath();\n} // export default EdgeCoordinate;","map":{"version":3,"sources":["../../../src/lib/coordinates/EdgeCoordinateV3.js"],"names":["renderSVG","className","props","edge","helper","line","coordinateBase","coordinate","y2","rectWidth","rectHeight","arrowWidth","path","opacity","textFill","displayCoordinate","show","type","orient","edgeAt","hideLine","lineStrokeDasharray","fill","fontFamily","fontSize","lineStroke","lineOpacity","stroke","strokeOpacity","strokeWidth","rectRadius","x1","y1","x2","dx","textAnchor","edgeXRect","edgeYRect","edgeXText","edgeYText","dy","strokeDasharray","drawOnCanvas","ctx","width","Math","dashArray","x","y","halfHeight","roundRect"],"mappings":"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","sourcesContent":["\n\nimport React from \"react\";\n\nimport { hexToRGBA, isDefined, getStrokeDasharray } from \"../utils\";\n\n/* eslint-disable react/prop-types */\nexport function renderSVG(props) {\n\tconst { className } = props;\n\n\tconst edge = helper(props);\n\tif (edge === null) return null;\n\tlet line, coordinateBase, coordinate;\n\n\tif (isDefined(edge.line)) {\n\t\tline = (\n\t\t\t<line\n\t\t\t\tclassName=\"react-stockcharts-cross-hair\"\n\t\t\t\tstrokeOpacity={edge.line.opacity}\n\t\t\t\tstroke={edge.line.stroke}\n\t\t\t\tstrokeDasharray={getStrokeDasharray(edge.line.strokeDasharray)}\n\t\t\t\tx1={edge.line.x1}\n\t\t\t\ty1={edge.line.y1}\n\t\t\t\tx2={edge.line.x2}\n\t\t\t\ty2={edge.line.y2}\n\t\t\t/>\n\t\t);\n\t}\n\tif (isDefined(edge.coordinateBase)) {\n\t\tconst { rectWidth, rectHeight, arrowWidth } = edge.coordinateBase;\n\n\t\tconst path =\n\t\t\tedge.orient === \"left\"\n\t\t\t\t? `M0,0L0,${rectHeight}L${rectWidth},${rectHeight}L${rectWidth +\n\t\t\t\t\t  arrowWidth},10L${rectWidth},0L0,0L0,0`\n\t\t\t\t: `M0,${arrowWidth}L${arrowWidth},${rectHeight}L${rectWidth +\n\t\t\t\t\t  arrowWidth},${rectHeight}L${rectWidth +\n\t\t\t\t\t  arrowWidth},0L${arrowWidth},0L0,${arrowWidth}`;\n\n\t\tcoordinateBase =\n\t\t\tedge.orient === \"left\" || edge.orient === \"right\" ? (\n\t\t\t\t<g\n\t\t\t\t\tkey={1}\n\t\t\t\t\ttransform={`translate(${edge.coordinateBase.edgeXRect},${\n\t\t\t\t\t\tedge.coordinateBase.edgeYRect\n\t\t\t\t\t})`}\n\t\t\t\t>\n\t\t\t\t\t<path\n\t\t\t\t\t\td={path}\n\t\t\t\t\t\tclassName=\"react-stockchart-text-background\"\n\t\t\t\t\t\theight={rectHeight}\n\t\t\t\t\t\twidth={rectWidth}\n\t\t\t\t\t\tstroke={edge.coordinateBase.stroke}\n\t\t\t\t\t\tstrokeLinejoin=\"miter\"\n\t\t\t\t\t\tstrokeOpacity={edge.coordinateBase.strokeOpacity}\n\t\t\t\t\t\tstrokeWidth={edge.coordinateBase.strokeWidth}\n\t\t\t\t\t\tfill={edge.coordinateBase.fill}\n\t\t\t\t\t\tfillOpacity={edge.coordinateBase.opacity}\n\t\t\t\t\t/>\n\t\t\t\t</g>\n\t\t\t) : (\n\t\t\t\t<rect\n\t\t\t\t\tkey={1}\n\t\t\t\t\tclassName=\"react-stockchart-text-background\"\n\t\t\t\t\tx={edge.coordinateBase.edgeXRect}\n\t\t\t\t\ty={edge.coordinateBase.edgeYRect}\n\t\t\t\t\theight={rectHeight}\n\t\t\t\t\twidth={rectWidth}\n\t\t\t\t\tfill={edge.coordinateBase.fill}\n\t\t\t\t\topacity={edge.coordinateBase.opacity}\n\t\t\t\t/>\n\t\t\t);\n\n\t\tcoordinate = (\n\t\t\t<text\n\t\t\t\tkey={2}\n\t\t\t\tx={edge.coordinate.edgeXText}\n\t\t\t\ty={edge.coordinate.edgeYText}\n\t\t\t\ttextAnchor={edge.coordinate.textAnchor}\n\t\t\t\tfontFamily={edge.coordinate.fontFamily}\n\t\t\t\tfontSize={edge.coordinate.fontSize}\n\t\t\t\tdy=\".32em\"\n\t\t\t\tfill={edge.coordinate.textFill}\n\t\t\t>\n\t\t\t\t{edge.coordinate.displayCoordinate}\n\t\t\t</text>\n\t\t);\n\t}\n\treturn (\n\t\t<g className={className}>\n\t\t\t{line}\n\t\t\t{coordinateBase}\n\t\t\t{coordinate}\n\t\t</g>\n\t);\n}\n/* eslint-enable react/prop-types */\n\nfunction helper(props) {\n\tconst {\n\t\tcoordinate: displayCoordinate,\n\t\tshow,\n\t\ttype,\n\t\torient,\n\t\tedgeAt,\n\t\thideLine,\n\t\tlineStrokeDasharray\n\t} = props;\n\tconst {\n\t\tfill,\n\t\topacity,\n\t\tfontFamily,\n\t\tfontSize,\n\t\ttextFill,\n\t\tlineStroke,\n\t\tlineOpacity\n\t} = props;\n\tconst { stroke, strokeOpacity, strokeWidth } = props;\n\tconst { arrowWidth, rectWidth, rectHeight, rectRadius } = props;\n\tconst { x1, y1, x2, y2, dx } = props;\n\n\tif (!show) return null;\n\n\tlet coordinateBase, coordinate;\n\tif (isDefined(displayCoordinate)) {\n\t\tconst textAnchor = \"middle\"; // TODO: Below it is necessary to implement logic for the possibility of alignment from the right or from the left.\n\n\t\tlet edgeXRect, edgeYRect, edgeXText, edgeYText;\n\n\t\tif (type === \"horizontal\") {\n\t\t\tedgeXRect =\n\t\t\t\tdx + (orient === \"right\" ? edgeAt + 1 : edgeAt - rectWidth - 1);\n\t\t\tedgeYRect = y1 - rectHeight / 2 - strokeWidth;\n\t\t\tedgeXText =\n\t\t\t\tdx +\n\t\t\t\t(orient === \"right\"\n\t\t\t\t\t? edgeAt + rectWidth / 2\n\t\t\t\t\t: edgeAt - rectWidth / 2);\n\t\t\tedgeYText = y1;\n\t\t} else {\n\t\t\tconst dy = orient === \"bottom\" ? strokeWidth - 1 : -strokeWidth + 1;\n\t\t\tedgeXRect = x1 - rectWidth / 2;\n\t\t\tedgeYRect =\n\t\t\t\t(orient === \"bottom\" ? edgeAt : edgeAt - rectHeight) + dy;\n\t\t\tedgeXText = x1;\n\t\t\tedgeYText =\n\t\t\t\t(orient === \"bottom\"\n\t\t\t\t\t? edgeAt + rectHeight / 2\n\t\t\t\t\t: edgeAt - rectHeight / 2) + dy;\n\t\t}\n\n\t\tcoordinateBase = {\n\t\t\tedgeXRect,\n\t\t\tedgeYRect,\n\t\t\trectHeight: rectHeight + strokeWidth,\n\t\t\trectWidth,\n\t\t\trectRadius,\n\t\t\tfill,\n\t\t\topacity,\n\t\t\tarrowWidth,\n\t\t\tstroke,\n\t\t\tstrokeOpacity,\n\t\t\tstrokeWidth\n\t\t};\n\t\tcoordinate = {\n\t\t\tedgeXText,\n\t\t\tedgeYText,\n\t\t\ttextAnchor,\n\t\t\tfontFamily,\n\t\t\tfontSize,\n\t\t\ttextFill,\n\t\t\tdisplayCoordinate\n\t\t};\n\t}\n\n\tconst line = hideLine\n\t\t? undefined\n\t\t: {\n\t\t\topacity: lineOpacity,\n\t\t\tstroke: lineStroke,\n\t\t\tstrokeDasharray: lineStrokeDasharray,\n\t\t\tx1,\n\t\t\ty1,\n\t\t\tx2,\n\t\t\ty2\n\t\t};\n\n\treturn {\n\t\tcoordinateBase,\n\t\tcoordinate,\n\t\tline,\n\t\torient\n\t};\n}\n\nexport function drawOnCanvas(ctx, props) {\n\tconst { fontSize, fontFamily } = props;\n\n\tctx.font = `${fontSize}px ${fontFamily}`;\n\tctx.textBaseline = \"middle\";\n\tconst width = Math.round(ctx.measureText(props.coordinate).width + 10);\n\n\tconst edge = helper({ ...props, rectWidth: width });\n\n\tif (edge === null) return;\n\n\tif (isDefined(edge.line)) {\n\t\tconst dashArray = getStrokeDasharray(edge.line.strokeDasharray)\n\t\t\t.split(\",\")\n\t\t\t.map(d => +d);\n\t\tctx.setLineDash(dashArray);\n\t\tctx.strokeStyle = hexToRGBA(edge.line.stroke, edge.line.opacity);\n\t\tctx.lineWidth = 1;\n\t\tctx.beginPath();\n\t\tctx.moveTo(edge.line.x1, edge.line.y1);\n\t\tctx.lineTo(edge.line.x2, edge.line.y2);\n\t\tctx.stroke();\n\t}\n\n\tctx.setLineDash([]);\n\tif (isDefined(edge.coordinateBase)) {\n\t\tconst {\n\t\t\trectWidth,\n\t\t\trectHeight,\n\t\t\trectRadius,\n\t\t\tarrowWidth\n\t\t} = edge.coordinateBase;\n\n\t\tctx.fillStyle = hexToRGBA(\n\t\t\tedge.coordinateBase.fill,\n\t\t\tedge.coordinateBase.opacity\n\t\t);\n\t\tif (isDefined(edge.coordinateBase.stroke)) {\n\t\t\tctx.strokeStyle = hexToRGBA(\n\t\t\t\tedge.coordinateBase.stroke,\n\t\t\t\tedge.coordinateBase.strokeOpacity\n\t\t\t);\n\t\t\tctx.lineWidth = edge.coordinateBase.strokeWidth;\n\t\t}\n\n\t\tlet x = edge.coordinateBase.edgeXRect;\n\t\tconst y = edge.coordinateBase.edgeYRect;\n\t\tconst halfHeight = rectHeight / 2;\n\n\t\tctx.beginPath();\n\t\tif (edge.orient === \"right\") {\n\t\t\tx -= arrowWidth;\n\t\t\tctx.moveTo(x, y + halfHeight);\n\t\t\tctx.lineTo(x + arrowWidth, y);\n\t\t\tctx.lineTo(x + rectWidth + arrowWidth, y);\n\t\t\tctx.lineTo(x + rectWidth + arrowWidth, y + rectHeight);\n\t\t\tctx.lineTo(x + arrowWidth, y + rectHeight);\n\t\t\tctx.closePath();\n\t\t} else if (edge.orient === \"left\") {\n\t\t\t// x += arrowWidth;\n\t\t\tctx.moveTo(x, y);\n\t\t\tctx.lineTo(x + rectWidth, y);\n\t\t\tctx.lineTo(x + rectWidth + arrowWidth, y + halfHeight);\n\t\t\tctx.lineTo(x + rectWidth, y + rectHeight);\n\t\t\tctx.lineTo(x, y + rectHeight);\n\t\t\tctx.closePath();\n\t\t} else {\n\t\t\t// console.error(x, y, rectWidth, rectHeight)\n\t\t\tif (rectRadius) {\n\t\t\t\troundRect(ctx, x, y, rectWidth, rectHeight, 3);\n\t\t\t} else {\n\t\t\t\tctx.rect(x, y, rectWidth, rectHeight);\n\t\t\t}\n\t\t}\n\t\tctx.fill();\n\n\t\tif (isDefined(edge.coordinateBase.stroke)) {\n\t\t\tctx.stroke();\n\t\t}\n\n\t\tctx.fillStyle = edge.coordinate.textFill;\n\t\tctx.textAlign =\n\t\t\tedge.coordinate.textAnchor === \"middle\"\n\t\t\t\t? \"center\"\n\t\t\t\t: edge.coordinate.textAnchor;\n\t\tctx.fillText(\n\t\t\tedge.coordinate.displayCoordinate,\n\t\t\tedge.coordinate.edgeXText,\n\t\t\tedge.coordinate.edgeYText\n\t\t);\n\t}\n}\n\nfunction roundRect(ctx, x, y, width, height, radius) {\n\tctx.beginPath();\n\tctx.moveTo(x + radius, y);\n\tctx.lineTo(x + width - radius, y);\n\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n\tctx.lineTo(x + width, y + height - radius);\n\tctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\n\tctx.lineTo(x + radius, y + height);\n\tctx.quadraticCurveTo(x, y + height, x, y + height - radius);\n\tctx.lineTo(x, y + radius);\n\tctx.quadraticCurveTo(x, y, x + radius, y);\n\tctx.closePath();\n}\n\n// export default EdgeCoordinate;\n"]},"metadata":{},"sourceType":"script"}