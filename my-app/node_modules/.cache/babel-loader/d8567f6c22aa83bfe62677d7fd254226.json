{"ast":null,"code":"import { useRef } from 'react';\nexport default (function (isScrollAtTop, isScrollAtBottom) {\n  // Do lock for a wheel when scrolling\n  var lockRef = useRef(false);\n  var lockTimeoutRef = useRef(null);\n\n  function lockScroll() {\n    clearTimeout(lockTimeoutRef.current);\n    lockRef.current = true;\n    lockTimeoutRef.current = setTimeout(function () {\n      lockRef.current = false;\n    }, 50);\n  } // Pass to ref since global add is in closure\n\n\n  var scrollPingRef = useRef({\n    top: isScrollAtTop,\n    bottom: isScrollAtBottom\n  });\n  scrollPingRef.current.top = isScrollAtTop;\n  scrollPingRef.current.bottom = isScrollAtBottom;\n  return function (deltaY) {\n    var smoothOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var originScroll = // Pass origin wheel when on the top\n    deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom\n    deltaY > 0 && scrollPingRef.current.bottom;\n\n    if (smoothOffset && originScroll) {\n      // No need lock anymore when it's smooth offset from touchMove interval\n      clearTimeout(lockTimeoutRef.current);\n      lockRef.current = false;\n    } else if (!originScroll || lockRef.current) {\n      lockScroll();\n    }\n\n    return !lockRef.current && originScroll;\n  };\n});","map":{"version":3,"sources":["C:/Users/chena/QbitesReact/my-app/node_modules/rc-virtual-list/es/hooks/useOriginScroll.js"],"names":["useRef","isScrollAtTop","isScrollAtBottom","lockRef","lockTimeoutRef","lockScroll","clearTimeout","current","setTimeout","scrollPingRef","top","bottom","deltaY","smoothOffset","arguments","length","undefined","originScroll"],"mappings":"AAAA,SAASA,MAAT,QAAuB,OAAvB;AACA,gBAAgB,UAAUC,aAAV,EAAyBC,gBAAzB,EAA2C;AACzD;AACA,MAAIC,OAAO,GAAGH,MAAM,CAAC,KAAD,CAApB;AACA,MAAII,cAAc,GAAGJ,MAAM,CAAC,IAAD,CAA3B;;AAEA,WAASK,UAAT,GAAsB;AACpBC,IAAAA,YAAY,CAACF,cAAc,CAACG,OAAhB,CAAZ;AACAJ,IAAAA,OAAO,CAACI,OAAR,GAAkB,IAAlB;AACAH,IAAAA,cAAc,CAACG,OAAf,GAAyBC,UAAU,CAAC,YAAY;AAC9CL,MAAAA,OAAO,CAACI,OAAR,GAAkB,KAAlB;AACD,KAFkC,EAEhC,EAFgC,CAAnC;AAGD,GAXwD,CAWvD;;;AAGF,MAAIE,aAAa,GAAGT,MAAM,CAAC;AACzBU,IAAAA,GAAG,EAAET,aADoB;AAEzBU,IAAAA,MAAM,EAAET;AAFiB,GAAD,CAA1B;AAIAO,EAAAA,aAAa,CAACF,OAAd,CAAsBG,GAAtB,GAA4BT,aAA5B;AACAQ,EAAAA,aAAa,CAACF,OAAd,CAAsBI,MAAtB,GAA+BT,gBAA/B;AACA,SAAO,UAAUU,MAAV,EAAkB;AACvB,QAAIC,YAAY,GAAGC,SAAS,CAACC,MAAV,GAAmB,CAAnB,IAAwBD,SAAS,CAAC,CAAD,CAAT,KAAiBE,SAAzC,GAAqDF,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAvF;AACA,QAAIG,YAAY,GAAG;AACnBL,IAAAA,MAAM,GAAG,CAAT,IAAcH,aAAa,CAACF,OAAd,CAAsBG,GAApC,IAA2C;AAC3CE,IAAAA,MAAM,GAAG,CAAT,IAAcH,aAAa,CAACF,OAAd,CAAsBI,MAFpC;;AAIA,QAAIE,YAAY,IAAII,YAApB,EAAkC;AAChC;AACAX,MAAAA,YAAY,CAACF,cAAc,CAACG,OAAhB,CAAZ;AACAJ,MAAAA,OAAO,CAACI,OAAR,GAAkB,KAAlB;AACD,KAJD,MAIO,IAAI,CAACU,YAAD,IAAiBd,OAAO,CAACI,OAA7B,EAAsC;AAC3CF,MAAAA,UAAU;AACX;;AAED,WAAO,CAACF,OAAO,CAACI,OAAT,IAAoBU,YAA3B;AACD,GAfD;AAgBD,CApCD","sourcesContent":["import { useRef } from 'react';\r\nexport default (function (isScrollAtTop, isScrollAtBottom) {\r\n  // Do lock for a wheel when scrolling\r\n  var lockRef = useRef(false);\r\n  var lockTimeoutRef = useRef(null);\r\n\r\n  function lockScroll() {\r\n    clearTimeout(lockTimeoutRef.current);\r\n    lockRef.current = true;\r\n    lockTimeoutRef.current = setTimeout(function () {\r\n      lockRef.current = false;\r\n    }, 50);\r\n  } // Pass to ref since global add is in closure\r\n\r\n\r\n  var scrollPingRef = useRef({\r\n    top: isScrollAtTop,\r\n    bottom: isScrollAtBottom\r\n  });\r\n  scrollPingRef.current.top = isScrollAtTop;\r\n  scrollPingRef.current.bottom = isScrollAtBottom;\r\n  return function (deltaY) {\r\n    var smoothOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n    var originScroll = // Pass origin wheel when on the top\r\n    deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom\r\n    deltaY > 0 && scrollPingRef.current.bottom;\r\n\r\n    if (smoothOffset && originScroll) {\r\n      // No need lock anymore when it's smooth offset from touchMove interval\r\n      clearTimeout(lockTimeoutRef.current);\r\n      lockRef.current = false;\r\n    } else if (!originScroll || lockRef.current) {\r\n      lockScroll();\r\n    }\r\n\r\n    return !lockRef.current && originScroll;\r\n  };\r\n});"]},"metadata":{},"sourceType":"module"}