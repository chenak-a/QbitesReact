{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  var _super = _createSuper(Range);\n\n  function Range(props) {\n    var _this;\n\n    _classCallCheck(this, Range);\n\n    _this = _super.call(this, props);\n\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n\n      var value = _this.calcValueByPos(position);\n\n      var closestBound = _this.getClosestBound(value);\n\n      var index = _this.getBoundNeedMoving(value, closestBound);\n\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n  /**\n   * [Legacy] Used for inherit other component.\n   * It's a bad code style which should be refactor.\n   */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value: function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          onChange = _this$props.onChange,\n          value = _this$props.value,\n          min = _this$props.min,\n          max = _this$props.max;\n\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n          state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n          props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n          reverse = _this$props2.reverse,\n          vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n          bounds = _this$state.bounds,\n          recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n          marks = _this$props3.marks,\n          step = _this$props3.step,\n          min = _this$props3.min,\n          max = _this$props3.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n          handle = _this$state2.handle,\n          bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$state3 = this.state,\n          handle = _this$state3.handle,\n          bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n          prefixCls = _this$props4.prefixCls,\n          vertical = _this$props4.vertical,\n          included = _this$props4.included,\n          disabled = _this$props4.disabled,\n          min = _this$props4.min,\n          max = _this$props4.max,\n          reverse = _this$props4.reverse,\n          handleGenerator = _this$props4.handle,\n          trackStyle = _this$props4.trackStyle,\n          handleStyle = _this$props4.handleStyle,\n          tabIndex = _this$props4.tabIndex,\n          ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var mergedTabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n/* eslint-enable */\n\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_objectSpread","_toConsumableArray","_classCallCheck","_createClass","_inherits","_createSuper","React","classNames","Track","createSlider","utils","_trimAlignValue","trimAlignValue","_ref","value","handle","bounds","props","allowCross","pushable","thershold","Number","valInRange","ensureValueInRange","valNotConflict","undefined","length","ensureValuePrecision","Range","_React$Component","_super","_this","call","positionGetValue","position","getValue","calcValueByPos","closestBound","getClosestBound","index","getBoundNeedMoving","prevValue","nextBounds","onEnd","force","state","removeDocumentEvents","dragTrack","onAfterChange","setState","count","min","max","initialValue","Array","apply","map","defaultValue","v","i","recent","key","getSliderLength","calcOffset","saveHandle","h","componentDidUpdate","prevProps","prevState","_this2","_this$props","onChange","currentValue","some","isValueOutOfRange","newValues","isNotControlled","controlledState","forEach","item","Object","keys","data","changedValue","onStart","onBeforeChange","startValue","startPosition","prevMovedHandleIndex","onMove","e","startBounds","pauseEvent","maxValue","minValue","pos","vertical","reverse","Math","ratio","floor","c","oldValue","moveTo","onKeyboard","_this$props2","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","abs","_this$state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_this$props3","marks","step","cache","internalPointsCache","pointsObject","point","points","parseFloat","sort","a","b","_this3","nextHandle","pushSurroundingHandles","indexOf","handlesRefs","focus","threshold","direction","diffToNext","pushHandle","amount","originalValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","_this$state2","render","_this4","_this$state3","_this$props4","prefixCls","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","ariaLabelGroupForHandles","ariaLabelledByGroupForHandles","ariaValueTextFormatterGroupForHandles","offsets","handleClassName","concat","handles","_classNames","mergedTabIndex","dragging","className","offset","style","ref","ariaLabel","ariaLabelledBy","ariaValueTextFormatter","tracks","slice","_","_classNames2","trackClassName","createElement","getDerivedStateFromProps","every","Component","displayName","defaultProps","draggableTrack"],"sources":["/home/chenak/QbitesReact/my-app/node_modules/rc-slider/es/Range.js"],"sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nimport classNames from 'classnames';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar _trimAlignValue = function trimAlignValue(_ref) {\n  var value = _ref.value,\n      handle = _ref.handle,\n      bounds = _ref.bounds,\n      props = _ref.props;\n  var allowCross = props.allowCross,\n      pushable = props.pushable;\n  var thershold = Number(pushable);\n  var valInRange = utils.ensureValueInRange(value, props);\n  var valNotConflict = valInRange;\n\n  if (!allowCross && handle != null && bounds !== undefined) {\n    if (handle > 0 && valInRange <= bounds[handle - 1] + thershold) {\n      valNotConflict = bounds[handle - 1] + thershold;\n    }\n\n    if (handle < bounds.length - 1 && valInRange >= bounds[handle + 1] - thershold) {\n      valNotConflict = bounds[handle + 1] - thershold;\n    }\n  }\n\n  return utils.ensureValuePrecision(valNotConflict, props);\n};\n\nvar Range = /*#__PURE__*/function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  var _super = _createSuper(Range);\n\n  function Range(props) {\n    var _this;\n\n    _classCallCheck(this, Range);\n\n    _this = _super.call(this, props);\n\n    _this.positionGetValue = function (position) {\n      var bounds = _this.getValue();\n\n      var value = _this.calcValueByPos(position);\n\n      var closestBound = _this.getClosestBound(value);\n\n      var index = _this.getBoundNeedMoving(value, closestBound);\n\n      var prevValue = bounds[index];\n      if (value === prevValue) return null;\n\n      var nextBounds = _toConsumableArray(bounds);\n\n      nextBounds[index] = value;\n      return nextBounds;\n    };\n\n    _this.onEnd = function (force) {\n      var handle = _this.state.handle;\n\n      _this.removeDocumentEvents();\n\n      if (!handle) {\n        _this.dragTrack = false;\n      }\n\n      if (handle !== null || force) {\n        _this.props.onAfterChange(_this.getValue());\n      }\n\n      _this.setState({\n        handle: null\n      });\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n    var initialValue = Array.apply(void 0, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _trimAlignValue({\n        value: v,\n        handle: i,\n        props: props\n      });\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n  /**\n   * [Legacy] Used for inherit other component.\n   * It's a bad code style which should be refactor.\n   */\n\n  /* eslint-disable @typescript-eslint/no-unused-vars, class-methods-use-this */\n\n\n  _createClass(Range, [{\n    key: \"calcValueByPos\",\n    value: function calcValueByPos(value) {\n      return 0;\n    }\n  }, {\n    key: \"getSliderLength\",\n    value: function getSliderLength() {\n      return 0;\n    }\n  }, {\n    key: \"calcOffset\",\n    value: function calcOffset(value) {\n      return 0;\n    }\n  }, {\n    key: \"saveHandle\",\n    value: function saveHandle(index, h) {}\n  }, {\n    key: \"removeDocumentEvents\",\n    value: function removeDocumentEvents() {}\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          onChange = _this$props.onChange,\n          value = _this$props.value,\n          min = _this$props.min,\n          max = _this$props.max;\n\n      if (!('min' in this.props || 'max' in this.props)) {\n        return;\n      }\n\n      if (min === prevProps.min && max === prevProps.max) {\n        return;\n      }\n\n      var currentValue = value || prevState.bounds;\n\n      if (currentValue.some(function (v) {\n        return utils.isValueOutOfRange(v, _this2.props);\n      })) {\n        var newValues = currentValue.map(function (v) {\n          return utils.ensureValueInRange(v, _this2.props);\n        });\n        onChange(newValues);\n      }\n    }\n  }, {\n    key: \"onChange\",\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n\n      if (isNotControlled) {\n        this.setState(state);\n      } else {\n        var controlledState = {};\n        ['handle', 'recent'].forEach(function (item) {\n          if (state[item] !== undefined) {\n            controlledState[item] = state[item];\n          }\n        });\n\n        if (Object.keys(controlledState).length) {\n          this.setState(controlledState);\n        }\n      }\n\n      var data = _objectSpread(_objectSpread({}, this.state), state);\n\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(position) {\n      var props = this.props,\n          state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: \"onMove\",\n    value: function onMove(e, position, dragTrack, startBounds) {\n      utils.pauseEvent(e);\n      var state = this.state,\n          props = this.props;\n      var maxValue = props.max || 100;\n      var minValue = props.min || 0;\n\n      if (dragTrack) {\n        var pos = props.vertical ? -position : position;\n        pos = props.reverse ? -pos : pos;\n        var max = maxValue - Math.max.apply(Math, _toConsumableArray(startBounds));\n        var min = minValue - Math.min.apply(Math, _toConsumableArray(startBounds));\n        var ratio = Math.min(Math.max(pos / (this.getSliderLength() / 100), min), max);\n        var nextBounds = startBounds.map(function (v) {\n          return Math.floor(Math.max(Math.min(v + ratio, maxValue), minValue));\n        });\n\n        if (state.bounds.map(function (c, i) {\n          return c === nextBounds[i];\n        }).some(function (c) {\n          return !c;\n        })) {\n          this.onChange({\n            bounds: nextBounds\n          });\n        }\n\n        return;\n      }\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: \"onKeyboard\",\n    value: function onKeyboard(e) {\n      var _this$props2 = this.props,\n          reverse = _this$props2.reverse,\n          vertical = _this$props2.vertical;\n      var valueMutator = utils.getKeyboardValueMutator(e, vertical, reverse);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n        var oldValue = bounds[handle === null ? state.recent : handle];\n        var mutatedValue = valueMutator(oldValue, props);\n\n        var value = _trimAlignValue({\n          value: mutatedValue,\n          handle: handle,\n          bounds: state.bounds,\n          props: props\n        });\n\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: \"getClosestBound\",\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n\n      for (var i = 1; i < bounds.length - 1; i += 1) {\n        if (value >= bounds[i]) {\n          closestBound = i;\n        }\n      }\n\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n\n      return closestBound;\n    }\n  }, {\n    key: \"getBoundNeedMoving\",\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _this$state = this.state,\n          bounds = _this$state.bounds,\n          recent = _this$state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n\n      return boundNeedMoving;\n    }\n  }, {\n    key: \"getLowerBound\",\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: \"getUpperBound\",\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: \"getPoints\",\n    value: function getPoints() {\n      var _this$props3 = this.props,\n          marks = _this$props3.marks,\n          step = _this$props3.step,\n          min = _this$props3.min,\n          max = _this$props3.max;\n      var cache = this.internalPointsCache;\n\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _objectSpread({}, marks);\n\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this.internalPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n\n      return this.internalPointsCache.points;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = _toConsumableArray(state.bounds);\n\n      var handle = state.handle === null ? state.recent : state.handle;\n      nextBounds[handle] = value;\n      var nextHandle = handle;\n\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n\n      this.onChange({\n        recent: nextHandle,\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.props.onAfterChange(nextBounds);\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n        this.onEnd();\n      }\n    }\n  }, {\n    key: \"pushSurroundingHandles\",\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var direction = 0;\n\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        // eslint-disable-next-line no-param-reassign\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: \"pushHandle\",\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          // eslint-disable-next-line no-param-reassign\n          bounds[handle] = originalValue;\n          return false;\n        }\n\n        currentValue = bounds[handle];\n      } // the handle was pushed enough to create the needed `amount` gap\n\n\n      return true;\n    }\n  }, {\n    key: \"pushHandleOnePoint\",\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var pushable = this.props.pushable;\n      var threshold = Number(pushable);\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      } // push the handle\n      // eslint-disable-next-line no-param-reassign\n\n\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: \"trimAlignValue\",\n    value: function trimAlignValue(value) {\n      var _this$state2 = this.state,\n          handle = _this$state2.handle,\n          bounds = _this$state2.bounds;\n      return _trimAlignValue({\n        value: value,\n        handle: handle,\n        bounds: bounds,\n        props: this.props\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$state3 = this.state,\n          handle = _this$state3.handle,\n          bounds = _this$state3.bounds;\n      var _this$props4 = this.props,\n          prefixCls = _this$props4.prefixCls,\n          vertical = _this$props4.vertical,\n          included = _this$props4.included,\n          disabled = _this$props4.disabled,\n          min = _this$props4.min,\n          max = _this$props4.max,\n          reverse = _this$props4.reverse,\n          handleGenerator = _this$props4.handle,\n          trackStyle = _this$props4.trackStyle,\n          handleStyle = _this$props4.handleStyle,\n          tabIndex = _this$props4.tabIndex,\n          ariaLabelGroupForHandles = _this$props4.ariaLabelGroupForHandles,\n          ariaLabelledByGroupForHandles = _this$props4.ariaLabelledByGroupForHandles,\n          ariaValueTextFormatterGroupForHandles = _this$props4.ariaValueTextFormatterGroupForHandles;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = \"\".concat(prefixCls, \"-handle\");\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        var mergedTabIndex = tabIndex[i] || 0;\n\n        if (disabled || tabIndex[i] === null) {\n          mergedTabIndex = null;\n        }\n\n        var dragging = handle === i;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-\").concat(i + 1), true), _defineProperty(_classNames, \"\".concat(handleClassName, \"-dragging\"), dragging), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          dragging: dragging,\n          offset: offsets[i],\n          value: v,\n          index: i,\n          tabIndex: mergedTabIndex,\n          min: min,\n          max: max,\n          reverse: reverse,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          },\n          ariaLabel: ariaLabelGroupForHandles[i],\n          ariaLabelledBy: ariaLabelledByGroupForHandles[i],\n          ariaValueTextFormatter: ariaValueTextFormatterGroupForHandles[i]\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track\"), true), _defineProperty(_classNames2, \"\".concat(prefixCls, \"-track-\").concat(i), true), _classNames2));\n        return /*#__PURE__*/React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          reverse: reverse,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(props, state) {\n      if (!('value' in props || 'min' in props || 'max' in props)) {\n        return null;\n      }\n\n      var value = props.value || state.bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _trimAlignValue({\n          value: v,\n          handle: i,\n          bounds: state.bounds,\n          props: props\n        });\n      });\n\n      if (state.bounds.length === nextBounds.length) {\n        if (nextBounds.every(function (v, i) {\n          return v === state.bounds[i];\n        })) {\n          return null;\n        }\n      } else {\n        nextBounds = value.map(function (v, i) {\n          return _trimAlignValue({\n            value: v,\n            handle: i,\n            props: props\n          });\n        });\n      }\n\n      return _objectSpread(_objectSpread({}, state), {}, {\n        bounds: nextBounds\n      });\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n/* eslint-enable */\n\n\nRange.displayName = 'Range';\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  draggableTrack: false,\n  tabIndex: [],\n  ariaLabelGroupForHandles: [],\n  ariaLabelledByGroupForHandles: [],\n  ariaValueTextFormatterGroupForHandles: []\n};\nexport default createSlider(Range);"],"mappings":"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"},"metadata":{},"sourceType":"module"}