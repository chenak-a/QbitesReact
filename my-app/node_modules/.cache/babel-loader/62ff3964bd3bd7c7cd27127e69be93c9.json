{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport { head, last, getClosestItemIndexes, isDefined, isNotDefined, getLogger } from \"../utils\";\nvar log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  var lastItem = fallbackEnd.lastItem,\n      lastItemX = fallbackEnd.lastItemX;\n  var lastItemXValue = xAccessor(lastItem);\n\n  var _initialXScale$range = initialXScale.range(),\n      _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n      rangeStart = _initialXScale$range2[0],\n      rangeEnd = _initialXScale$range2[1];\n\n  var newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n  return newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n        currentPlotData = _ref.currentPlotData,\n        currentDomain = _ref.currentDomain,\n        fallbackStart = _ref.fallbackStart,\n        fallbackEnd = _ref.fallbackEnd;\n\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n\n    var left = head(inputDomain);\n    var right = last(inputDomain);\n    var clampedDomain = inputDomain;\n    var filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [Math.max(left, xAccessor(head(data))), clampedDomain[1]];\n      }\n\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], Math.min(right, xAccessor(last(data)))];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n\n    var realInputDomain = clampedDomain; // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    var xScale = initialXScale.copy().domain(realInputDomain);\n    var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData)))); // prevent negative width when flipXScale\n\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    var plotData = void 0,\n        domain = void 0;\n    var chartWidth = last(xScale.range()) - head(xScale.range());\n    log(\"Trying to show \" + filteredData.length + \" points in \" + width + \"px,\" + (\" I can show up to \" + (showMaxThreshold(width, pointsPerPxThreshold) - 1) + \" points in that width. \") + (\"Also FYI the entire chart width is \" + chartWidth + \"px and pointsPerPxThreshold is \" + pointsPerPxThreshold));\n\n    if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log(\"AND IT WORKED\");\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        var newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd]; // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var newXScale = xScale.copy().domain(domain);\n        var newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + newWidth + \"px\");\n      } else {\n        plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var _newXScale = xScale.copy().domain(domain);\n\n        var _newWidth = Math.floor(_newXScale(xAccessor(last(plotData))) - _newXScale(xAccessor(head(plotData))));\n\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + _newWidth + \"px\");\n      }\n    }\n\n    return {\n      plotData: plotData,\n      domain: domain\n    };\n  }\n\n  return {\n    filterData: filterData\n  };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  var newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n  var filteredData = data.slice(newLeftIndex, newRightIndex + 1); // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\n\nexport default function (_ref2) {\n  var xScale = _ref2.xScale,\n      useWholeData = _ref2.useWholeData,\n      clamp = _ref2.clamp,\n      pointsPerPxThreshold = _ref2.pointsPerPxThreshold,\n      minPointsPerPxThreshold = _ref2.minPointsPerPxThreshold,\n      flipXScale = _ref2.flipXScale;\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"mappings":"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","names":["head","last","getClosestItemIndexes","isDefined","isNotDefined","getLogger","log","getNewEnd","fallbackEnd","xAccessor","initialXScale","start","lastItem","lastItemX","lastItemXValue","range","rangeStart","rangeEnd","newEnd","extentsWrapper","useWholeData","clamp","pointsPerPxThreshold","minPointsPerPxThreshold","flipXScale","filterData","data","inputDomain","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","right","clampedDomain","filteredData","getFilteredResponse","length","Math","max","min","realInputDomain","xScale","copy","width","floor","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","slice","showMax","arrayLength","maxThreshold","minThreshold","showMinThreshold","threshold","ceil","newLeftIndex","newRightIndex","invert"],"sources":["../../../../src/lib/scale/evaluator.js"],"sourcesContent":["\n\nimport {\n\thead,\n\tlast,\n\tgetClosestItemIndexes,\n\tisDefined,\n\tisNotDefined,\n\tgetLogger,\n} from \"../utils\";\n\nconst log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n\tconst {\n\t\tlastItem, lastItemX\n\t} = fallbackEnd;\n\tconst lastItemXValue = xAccessor(lastItem);\n\tconst [rangeStart, rangeEnd] = initialXScale.range();\n\n\tconst newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n\treturn newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n\tfunction filterData(\n\t\tdata, inputDomain, xAccessor, initialXScale,\n\t\t{ currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n\t) {\n\t\tif (useWholeData) {\n\t\t\treturn { plotData: data, domain: inputDomain };\n\t\t}\n\n\t\tlet left = head(inputDomain);\n\t\tlet right = last(inputDomain);\n\t\tlet clampedDomain = inputDomain;\n\n\t\tlet filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n\t\tif (filteredData.length === 1 && isDefined(fallbackStart)) {\n\t\t\tleft = fallbackStart;\n\t\t\tright = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n\t\t\tclampedDomain = [\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t];\n\t\t\tfilteredData = getFilteredResponse(data, left, right, xAccessor);\n\t\t}\n\n\t\tif (typeof clamp === \"function\") {\n\t\t\tclampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n\t\t} else {\n\t\t\tif (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tMath.max(left, xAccessor(head(data))),\n\t\t\t\t\tclampedDomain[1]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tclampedDomain[0],\n\t\t\t\t\tMath.min(right, xAccessor(last(data)))\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (clampedDomain !== inputDomain) {\n\t\t\tfilteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n\t\t}\n\n\t\tconst realInputDomain = clampedDomain;\n\t\t// [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n\t\tconst xScale = initialXScale.copy().domain(realInputDomain);\n\n\t\tlet width = Math.floor(xScale(xAccessor(last(filteredData)))\n\t\t\t- xScale(xAccessor(head(filteredData))));\n\n\t\t// prevent negative width when flipXScale\n\t\tif (flipXScale && width < 0) {\n\t\t\twidth = width * -1;\n\t\t}\n\n\t\tlet plotData, domain;\n\n\t\tconst chartWidth = last(xScale.range()) - head(xScale.range());\n\n\t\tlog(`Trying to show ${filteredData.length} points in ${width}px,`\n\t\t\t+ ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. `\n\t\t\t+ `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n\n\t\tif (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n\t\t\tplotData = filteredData;\n\t\t\tdomain = realInputDomain;\n\t\t\tlog(\"AND IT WORKED\");\n\t\t} else {\n\t\t\tif (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n\t\t\t\tplotData = filteredData;\n\t\t\t\tconst newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n\t\t\t\tdomain = [\n\t\t\t\t\thead(realInputDomain),\n\t\t\t\t\tnewEnd\n\t\t\t\t];\n\t\t\t\t// plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\t// domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t} else {\n\t\t\t\tplotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\tdomain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t}\n\t\t}\n\t\treturn { plotData, domain };\n\t}\n\treturn { filterData };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n\treturn arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n\treturn Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n\treturn Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n\treturn Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n\tconst newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n\tconst newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n\tconst filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n\t// console.log(right, newRightIndex, dataForInterval.length);\n\n\treturn filteredData;\n}\n\nexport default function({\n\txScale, useWholeData, clamp,\n\tpointsPerPxThreshold, minPointsPerPxThreshold,\n\tflipXScale\n}) {\n\treturn extentsWrapper(\n\t\tuseWholeData || isNotDefined(xScale.invert),\n\t\tclamp,\n\t\tpointsPerPxThreshold,\n\t\tminPointsPerPxThreshold,\n\t\tflipXScale\n\t);\n}\n"]},"metadata":{},"sourceType":"module"}