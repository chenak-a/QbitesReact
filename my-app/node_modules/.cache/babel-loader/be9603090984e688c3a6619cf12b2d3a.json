{"ast":null,"code":"import { Selection } from \"./index\";\nimport { EnterNode } from \"./enter\";\nimport constant from \"../constant\";\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length; // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Put any non-null nodes that don’t fit into exit.\n\n\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue; // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  } // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n\n\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  } // Add any remaining nodes that were not bound to data to exit.\n\n\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function (value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function (d) {\n      data[++j] = d;\n    });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}","map":{"version":3,"names":["Selection","EnterNode","constant","keyPrefix","bindIndex","parent","group","enter","update","exit","data","i","node","groupLength","length","dataLength","__data__","bindKey","key","nodeByKeyValue","keyValues","Array","keyValue","call","value","size","j","each","d","bind","parents","_parents","groups","_groups","m","enterGroup","updateGroup","exitGroup","i0","i1","previous","next","_next","_enter","_exit"],"sources":["/home/chenak/QbitesReact/my-app/node_modules/react-stockcharts/node_modules/d3-selection/src/selection/data.js"],"sourcesContent":["import {Selection} from \"./index\";\nimport {EnterNode} from \"./enter\";\nimport constant from \"../constant\";\n\nvar keyPrefix = \"$\"; // Protect against keys like “__proto__”.\n\nfunction bindIndex(parent, group, enter, update, exit, data) {\n  var i = 0,\n      node,\n      groupLength = group.length,\n      dataLength = data.length;\n\n  // Put any non-null nodes that fit into update.\n  // Put any null nodes into enter.\n  // Put any remaining data into enter.\n  for (; i < dataLength; ++i) {\n    if (node = group[i]) {\n      node.__data__ = data[i];\n      update[i] = node;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Put any non-null nodes that don’t fit into exit.\n  for (; i < groupLength; ++i) {\n    if (node = group[i]) {\n      exit[i] = node;\n    }\n  }\n}\n\nfunction bindKey(parent, group, enter, update, exit, data, key) {\n  var i,\n      node,\n      nodeByKeyValue = {},\n      groupLength = group.length,\n      dataLength = data.length,\n      keyValues = new Array(groupLength),\n      keyValue;\n\n  // Compute the key for each node.\n  // If multiple nodes have the same key, the duplicates are added to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if (node = group[i]) {\n      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);\n      if (keyValue in nodeByKeyValue) {\n        exit[i] = node;\n      } else {\n        nodeByKeyValue[keyValue] = node;\n      }\n    }\n  }\n\n  // Compute the key for each datum.\n  // If there a node associated with this key, join and add it to update.\n  // If there is not (or the key is a duplicate), add it to enter.\n  for (i = 0; i < dataLength; ++i) {\n    keyValue = keyPrefix + key.call(parent, data[i], i, data);\n    if (node = nodeByKeyValue[keyValue]) {\n      update[i] = node;\n      node.__data__ = data[i];\n      nodeByKeyValue[keyValue] = null;\n    } else {\n      enter[i] = new EnterNode(parent, data[i]);\n    }\n  }\n\n  // Add any remaining nodes that were not bound to data to exit.\n  for (i = 0; i < groupLength; ++i) {\n    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {\n      exit[i] = node;\n    }\n  }\n}\n\nexport default function(value, key) {\n  if (!value) {\n    data = new Array(this.size()), j = -1;\n    this.each(function(d) { data[++j] = d; });\n    return data;\n  }\n\n  var bind = key ? bindKey : bindIndex,\n      parents = this._parents,\n      groups = this._groups;\n\n  if (typeof value !== \"function\") value = constant(value);\n\n  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {\n    var parent = parents[j],\n        group = groups[j],\n        groupLength = group.length,\n        data = value.call(parent, parent && parent.__data__, j, parents),\n        dataLength = data.length,\n        enterGroup = enter[j] = new Array(dataLength),\n        updateGroup = update[j] = new Array(dataLength),\n        exitGroup = exit[j] = new Array(groupLength);\n\n    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);\n\n    // Now connect the enter nodes to their following update node, such that\n    // appendChild can insert the materialized enter node before this node,\n    // rather than at the end of the parent node.\n    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {\n      if (previous = enterGroup[i0]) {\n        if (i0 >= i1) i1 = i0 + 1;\n        while (!(next = updateGroup[i1]) && ++i1 < dataLength);\n        previous._next = next || null;\n      }\n    }\n  }\n\n  update = new Selection(update, parents);\n  update._enter = enter;\n  update._exit = exit;\n  return update;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}