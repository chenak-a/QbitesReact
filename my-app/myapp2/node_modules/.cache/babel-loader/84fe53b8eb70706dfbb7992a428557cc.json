{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport { head } from \"../utils\";\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\n\nexport function plotDataLengthBarWidth(props, moreProps) {\n  var widthRatio = props.widthRatio;\n  var xScale = moreProps.xScale;\n\n  var _xScale$range = xScale.range(),\n      _xScale$range2 = _slicedToArray(_xScale$range, 2),\n      l = _xScale$range2[0],\n      r = _xScale$range2[1];\n\n  var totalWidth = Math.abs(r - l);\n\n  if (xScale.invert != null) {\n    var _xScale$domain = xScale.domain(),\n        _xScale$domain2 = _slicedToArray(_xScale$domain, 2),\n        dl = _xScale$domain2[0],\n        dr = _xScale$domain2[1];\n\n    var width = totalWidth / Math.abs(dl - dr);\n    return width * widthRatio;\n  } else {\n    var _width = totalWidth / xScale.domain().length;\n\n    return _width * widthRatio;\n  }\n}\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\n\nexport function timeIntervalBarWidth(interval) {\n  return function (props, moreProps) {\n    var widthRatio = props.widthRatio;\n    var xScale = moreProps.xScale,\n        xAccessor = moreProps.xAccessor,\n        plotData = moreProps.plotData;\n    var first = xAccessor(head(plotData));\n    return Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n  };\n}","map":{"version":3,"sources":["../../../../src/lib/utils/barWidth.js"],"names":["widthRatio","props","xScale","moreProps","l","r","totalWidth","Math","dl","dr","width","xAccessor","plotData","first","head","interval"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAAA,IAAA,QAAA,UAAA;AAEA;;;;;;;;AAOA,OAAO,SAAA,sBAAA,CAAA,KAAA,EAAA,SAAA,EAAkD;AAAA,MAChDA,UADgD,GACjCC,KADiC,CAAA,UAAA;AAAA,MAEhDC,MAFgD,GAErCC,SAFqC,CAAA,MAAA;;AAAA,MAAA,aAAA,GAIzCD,MAAAA,CAJyC,KAIzCA,EAJyC;AAAA,MAAA,cAAA,GAAA,cAAA,CAAA,aAAA,EAAA,CAAA,CAAA;AAAA,MAIjDE,CAJiD,GAAA,cAAA,CAAA,CAAA,CAAA;AAAA,MAI9CC,CAJ8C,GAAA,cAAA,CAAA,CAAA,CAAA;;AAMxD,MAAMC,UAAAA,GAAaC,IAAAA,CAAAA,GAAAA,CAASF,CAAAA,GAA5B,CAAmBE,CAAnB;;AACA,MAAIL,MAAAA,CAAAA,MAAAA,IAAJ,IAAA,EAA2B;AAAA,QAAA,cAAA,GACTA,MAAAA,CADS,MACTA,EADS;AAAA,QAAA,eAAA,GAAA,cAAA,CAAA,cAAA,EAAA,CAAA,CAAA;AAAA,QACnBM,EADmB,GAAA,eAAA,CAAA,CAAA,CAAA;AAAA,QACfC,EADe,GAAA,eAAA,CAAA,CAAA,CAAA;;AAE1B,QAAMC,KAAAA,GAAQJ,UAAAA,GAAaC,IAAAA,CAAAA,GAAAA,CAASC,EAAAA,GAApC,EAA2BD,CAA3B;AACA,WAAOG,KAAAA,GAAP,UAAA;AAHD,GAAA,MAIO;AACN,QAAMA,MAAAA,GAAQJ,UAAAA,GAAaJ,MAAAA,CAAAA,MAAAA,GAA3B,MAAA;;AACA,WAAOQ,MAAAA,GAAP,UAAA;AACA;AACD;AAED;;;;;;AAKA,OAAO,SAAA,oBAAA,CAAA,QAAA,EAAwC;AAC9C,SAAO,UAAA,KAAA,EAAA,SAAA,EAA2B;AAAA,QACzBV,UADyB,GACVC,KADU,CAAA,UAAA;AAAA,QAEzBC,MAFyB,GAEOC,SAFP,CAAA,MAAA;AAAA,QAEjBQ,SAFiB,GAEOR,SAFP,CAAA,SAAA;AAAA,QAENS,QAFM,GAEOT,SAFP,CAAA,QAAA;AAIjC,QAAMU,KAAAA,GAAQF,SAAAA,CAAUG,IAAAA,CAAxB,QAAwBA,CAAVH,CAAd;AACA,WAAOJ,IAAAA,CAAAA,GAAAA,CAASL,MAAAA,CAAOa,QAAAA,CAAAA,MAAAA,CAAAA,KAAAA,EAAPb,CAAOa,CAAPb,CAAAA,GAAoCA,MAAAA,CAA7CK,KAA6CL,CAA7CK,IAAP,UAAA;AALD,GAAA;AAOA","sourcesContent":["\n\nimport { head } from \"../utils\";\n\n/**\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\n * items.\n * @param props the props passed to the series.\n * @param moreProps an object holding the xScale, xAccessor and plotData.\n * @return {number} the bar width.\n */\nexport function plotDataLengthBarWidth(props, moreProps) {\n\tconst { widthRatio } = props;\n\tconst { xScale } = moreProps;\n\n\tconst [l, r] = xScale.range();\n\n\tconst totalWidth = Math.abs(r - l);\n\tif (xScale.invert != null) {\n\t\tconst [dl, dr] = xScale.domain();\n\t\tconst width = totalWidth / Math.abs(dl - dr);\n\t\treturn width * widthRatio;\n\t} else {\n\t\tconst width = totalWidth / xScale.domain().length;\n\t\treturn width * widthRatio;\n\t}\n}\n\n/**\n * Generates a width function that calculates the bar width based on the given time interval.\n * @param interval a d3-time time interval.\n * @return {Function} the width function.\n */\nexport function timeIntervalBarWidth(interval) {\n\treturn function(props, moreProps) {\n\t\tconst { widthRatio } = props;\n\t\tconst { xScale, xAccessor, plotData } = moreProps;\n\n\t\tconst first = xAccessor(head(plotData));\n\t\treturn Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\n\t};\n}\n"]},"metadata":{},"sourceType":"module"}