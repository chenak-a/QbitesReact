{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport { head, last, getClosestItemIndexes, isDefined, isNotDefined, getLogger } from \"../utils\";\nvar log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n  var lastItem = fallbackEnd.lastItem,\n      lastItemX = fallbackEnd.lastItemX;\n  var lastItemXValue = xAccessor(lastItem);\n\n  var _initialXScale$range = initialXScale.range(),\n      _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n      rangeStart = _initialXScale$range2[0],\n      rangeEnd = _initialXScale$range2[1];\n\n  var newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n  return newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n  function filterData(data, inputDomain, xAccessor, initialXScale) {\n    var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n        currentPlotData = _ref.currentPlotData,\n        currentDomain = _ref.currentDomain,\n        fallbackStart = _ref.fallbackStart,\n        fallbackEnd = _ref.fallbackEnd;\n\n    if (useWholeData) {\n      return {\n        plotData: data,\n        domain: inputDomain\n      };\n    }\n\n    var left = head(inputDomain);\n    var right = last(inputDomain);\n    var clampedDomain = inputDomain;\n    var filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n    if (filteredData.length === 1 && isDefined(fallbackStart)) {\n      left = fallbackStart;\n      right = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n      clampedDomain = [left, right];\n      filteredData = getFilteredResponse(data, left, right, xAccessor);\n    }\n\n    if (typeof clamp === \"function\") {\n      clampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n    } else {\n      if (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [Math.max(left, xAccessor(head(data))), clampedDomain[1]];\n      }\n\n      if (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n        clampedDomain = [clampedDomain[0], Math.min(right, xAccessor(last(data)))];\n      }\n    }\n\n    if (clampedDomain !== inputDomain) {\n      filteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n    }\n\n    var realInputDomain = clampedDomain; // [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n    var xScale = initialXScale.copy().domain(realInputDomain);\n    var width = Math.floor(xScale(xAccessor(last(filteredData))) - xScale(xAccessor(head(filteredData)))); // prevent negative width when flipXScale\n\n    if (flipXScale && width < 0) {\n      width = width * -1;\n    }\n\n    var plotData = void 0,\n        domain = void 0;\n    var chartWidth = last(xScale.range()) - head(xScale.range());\n    log(\"Trying to show \" + filteredData.length + \" points in \" + width + \"px,\" + (\" I can show up to \" + (showMaxThreshold(width, pointsPerPxThreshold) - 1) + \" points in that width. \") + (\"Also FYI the entire chart width is \" + chartWidth + \"px and pointsPerPxThreshold is \" + pointsPerPxThreshold));\n\n    if (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n      plotData = filteredData;\n      domain = realInputDomain;\n      log(\"AND IT WORKED\");\n    } else {\n      if (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n        plotData = filteredData;\n        var newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n        domain = [head(realInputDomain), newEnd]; // plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        // domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var newXScale = xScale.copy().domain(domain);\n        var newWidth = Math.floor(newXScale(xAccessor(last(plotData))) - newXScale(xAccessor(head(plotData))));\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + newWidth + \"px\");\n      } else {\n        plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n        domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n        var _newXScale = xScale.copy().domain(domain);\n\n        var _newWidth = Math.floor(_newXScale(xAccessor(last(plotData))) - _newXScale(xAccessor(head(plotData))));\n\n        log(\"and ouch, that is too much, so instead showing \" + plotData.length + \" in \" + _newWidth + \"px\");\n      }\n    }\n\n    return {\n      plotData: plotData,\n      domain: domain\n    };\n  }\n\n  return {\n    filterData: filterData\n  };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n  return arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n  return Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n  return Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n  return Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n  var newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n  var newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n  var filteredData = data.slice(newLeftIndex, newRightIndex + 1); // console.log(right, newRightIndex, dataForInterval.length);\n\n  return filteredData;\n}\n\nexport default function (_ref2) {\n  var xScale = _ref2.xScale,\n      useWholeData = _ref2.useWholeData,\n      clamp = _ref2.clamp,\n      pointsPerPxThreshold = _ref2.pointsPerPxThreshold,\n      minPointsPerPxThreshold = _ref2.minPointsPerPxThreshold,\n      flipXScale = _ref2.flipXScale;\n  return extentsWrapper(useWholeData || isNotDefined(xScale.invert), clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale);\n}","map":{"version":3,"sources":["../../../../src/lib/scale/evaluator.js"],"names":["log","getLogger","lastItem","lastItemX","fallbackEnd","lastItemXValue","xAccessor","rangeStart","rangeEnd","initialXScale","newEnd","currentPlotData","currentDomain","fallbackStart","plotData","domain","left","head","right","last","clampedDomain","filteredData","getFilteredResponse","isDefined","getNewEnd","clamp","Math","realInputDomain","xScale","width","flipXScale","chartWidth","showMaxThreshold","canShowTheseManyPeriods","newXScale","newWidth","showMax","filterData","arrayLength","showMinThreshold","newLeftIndex","getClosestItemIndexes","newRightIndex","data","useWholeData","pointsPerPxThreshold","minPointsPerPxThreshold","extentsWrapper","isNotDefined"],"mappings":"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","sourcesContent":["\n\nimport {\n\thead,\n\tlast,\n\tgetClosestItemIndexes,\n\tisDefined,\n\tisNotDefined,\n\tgetLogger,\n} from \"../utils\";\n\nconst log = getLogger(\"evaluator\");\n\nfunction getNewEnd(fallbackEnd, xAccessor, initialXScale, start) {\n\tconst {\n\t\tlastItem, lastItemX\n\t} = fallbackEnd;\n\tconst lastItemXValue = xAccessor(lastItem);\n\tconst [rangeStart, rangeEnd] = initialXScale.range();\n\n\tconst newEnd = (rangeEnd - rangeStart) / (lastItemX - rangeStart) * (lastItemXValue - start) + start;\n\treturn newEnd;\n}\n\nfunction extentsWrapper(useWholeData, clamp, pointsPerPxThreshold, minPointsPerPxThreshold, flipXScale) {\n\tfunction filterData(\n\t\tdata, inputDomain, xAccessor, initialXScale,\n\t\t{ currentPlotData, currentDomain, fallbackStart, fallbackEnd } = {}\n\t) {\n\t\tif (useWholeData) {\n\t\t\treturn { plotData: data, domain: inputDomain };\n\t\t}\n\n\t\tlet left = head(inputDomain);\n\t\tlet right = last(inputDomain);\n\t\tlet clampedDomain = inputDomain;\n\n\t\tlet filteredData = getFilteredResponse(data, left, right, xAccessor);\n\n\t\tif (filteredData.length === 1 && isDefined(fallbackStart)) {\n\t\t\tleft = fallbackStart;\n\t\t\tright = getNewEnd(fallbackEnd, xAccessor, initialXScale, left);\n\n\t\t\tclampedDomain = [\n\t\t\t\tleft,\n\t\t\t\tright,\n\t\t\t];\n\t\t\tfilteredData = getFilteredResponse(data, left, right, xAccessor);\n\t\t}\n\n\t\tif (typeof clamp === \"function\") {\n\t\t\tclampedDomain = clamp(clampedDomain, [xAccessor(head(data)), xAccessor(last(data))]);\n\t\t} else {\n\t\t\tif (clamp === \"left\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tMath.max(left, xAccessor(head(data))),\n\t\t\t\t\tclampedDomain[1]\n\t\t\t\t];\n\t\t\t}\n\n\t\t\tif (clamp === \"right\" || clamp === \"both\" || clamp === true) {\n\t\t\t\tclampedDomain = [\n\t\t\t\t\tclampedDomain[0],\n\t\t\t\t\tMath.min(right, xAccessor(last(data)))\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tif (clampedDomain !== inputDomain) {\n\t\t\tfilteredData = getFilteredResponse(data, clampedDomain[0], clampedDomain[1], xAccessor);\n\t\t}\n\n\t\tconst realInputDomain = clampedDomain;\n\t\t// [xAccessor(head(filteredData)), xAccessor(last(filteredData))];\n\n\t\tconst xScale = initialXScale.copy().domain(realInputDomain);\n\n\t\tlet width = Math.floor(xScale(xAccessor(last(filteredData)))\n\t\t\t- xScale(xAccessor(head(filteredData))));\n\n\t\t// prevent negative width when flipXScale\n\t\tif (flipXScale && width < 0) {\n\t\t\twidth = width * -1;\n\t\t}\n\n\t\tlet plotData, domain;\n\n\t\tconst chartWidth = last(xScale.range()) - head(xScale.range());\n\n\t\tlog(`Trying to show ${filteredData.length} points in ${width}px,`\n\t\t\t+ ` I can show up to ${showMaxThreshold(width, pointsPerPxThreshold) - 1} points in that width. `\n\t\t\t+ `Also FYI the entire chart width is ${chartWidth}px and pointsPerPxThreshold is ${pointsPerPxThreshold}`);\n\n\t\tif (canShowTheseManyPeriods(width, filteredData.length, pointsPerPxThreshold, minPointsPerPxThreshold)) {\n\t\t\tplotData = filteredData;\n\t\t\tdomain = realInputDomain;\n\t\t\tlog(\"AND IT WORKED\");\n\t\t} else {\n\t\t\tif (chartWidth > showMaxThreshold(width, pointsPerPxThreshold) && isDefined(fallbackEnd)) {\n\t\t\t\tplotData = filteredData;\n\t\t\t\tconst newEnd = getNewEnd(fallbackEnd, xAccessor, initialXScale, head(realInputDomain));\n\t\t\t\tdomain = [\n\t\t\t\t\thead(realInputDomain),\n\t\t\t\t\tnewEnd\n\t\t\t\t];\n\t\t\t\t// plotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\t// domain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t} else {\n\t\t\t\tplotData = currentPlotData || filteredData.slice(filteredData.length - showMax(width, pointsPerPxThreshold));\n\t\t\t\tdomain = currentDomain || [xAccessor(head(plotData)), xAccessor(last(plotData))];\n\n\t\t\t\tconst newXScale = xScale.copy().domain(domain);\n\t\t\t\tconst newWidth = Math.floor(newXScale(xAccessor(last(plotData)))\n\t\t\t\t\t- newXScale(xAccessor(head(plotData))));\n\n\t\t\t\tlog(`and ouch, that is too much, so instead showing ${plotData.length} in ${newWidth}px`);\n\t\t\t}\n\t\t}\n\t\treturn { plotData, domain };\n\t}\n\treturn { filterData };\n}\n\nfunction canShowTheseManyPeriods(width, arrayLength, maxThreshold, minThreshold) {\n\treturn arrayLength > showMinThreshold(width, minThreshold) && arrayLength < showMaxThreshold(width, maxThreshold);\n}\n\nfunction showMinThreshold(width, threshold) {\n\treturn Math.max(1, Math.ceil(width * threshold));\n}\n\nfunction showMaxThreshold(width, threshold) {\n\treturn Math.floor(width * threshold);\n}\n\nfunction showMax(width, threshold) {\n\treturn Math.floor(showMaxThreshold(width, threshold) * 0.97);\n}\n\nfunction getFilteredResponse(data, left, right, xAccessor) {\n\tconst newLeftIndex = getClosestItemIndexes(data, left, xAccessor).right;\n\tconst newRightIndex = getClosestItemIndexes(data, right, xAccessor).left;\n\n\tconst filteredData = data.slice(newLeftIndex, newRightIndex + 1);\n\t// console.log(right, newRightIndex, dataForInterval.length);\n\n\treturn filteredData;\n}\n\nexport default function({\n\txScale, useWholeData, clamp,\n\tpointsPerPxThreshold, minPointsPerPxThreshold,\n\tflipXScale\n}) {\n\treturn extentsWrapper(\n\t\tuseWholeData || isNotDefined(xScale.invert),\n\t\tclamp,\n\t\tpointsPerPxThreshold,\n\t\tminPointsPerPxThreshold,\n\t\tflipXScale\n\t);\n}\n"]},"metadata":{},"sourceType":"module"}