{"ast":null,"code":";\n\n(function () {\n  /* UNBUILD */\n  function USE(arg, req) {\n    return req ? require(arg) : arg.slice ? USE[R(arg)] : function (mod, path) {\n      arg(mod = {\n        exports: {}\n      });\n      USE[R(path)] = mod.exports;\n    };\n\n    function R(p) {\n      return p.split('/').slice(-1).toString().replace('.js', '');\n    }\n  }\n\n  if (typeof module !== \"undefined\") {\n    var MODULE = module;\n  }\n  /* UNBUILD */\n\n\n  ;\n  USE(function (module) {\n    // Security, Encryption, and Authorization: SEA.js\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\n    // THIS IS AN EARLY ALPHA!\n    if (typeof window !== \"undefined\") {\n      module.window = window;\n    }\n\n    var tmp = module.window || module;\n    var SEA = tmp.SEA || {};\n\n    if (SEA.window = module.window) {\n      SEA.window.SEA = SEA;\n    }\n\n    try {\n      if (typeof MODULE !== \"undefined\") {\n        MODULE.exports = SEA;\n      }\n    } catch (e) {}\n\n    module.exports = SEA;\n  })(USE, './root');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n\n    try {\n      if (SEA.window) {\n        if (location.protocol.indexOf('s') < 0 && location.host.indexOf('localhost') < 0 && !/^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname) && location.protocol.indexOf('file:') < 0) {\n          console.warn('WebCrypto used by GUN SEA implementation does not work without HTTPS. Will automatically redirect.');\n          location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\n        }\n      }\n    } catch (e) {}\n  })(USE, './https');\n  ;\n  USE(function (module) {\n    if (typeof btoa === \"undefined\") {\n      if (typeof Buffer === \"undefined\") {\n        global.Buffer = require(\"buffer\").Buffer;\n      }\n\n      global.btoa = function (data) {\n        return Buffer.from(data, \"binary\").toString(\"base64\");\n      };\n\n      global.atob = function (data) {\n        return Buffer.from(data, \"base64\").toString(\"binary\");\n      };\n    }\n  })(USE, './base64');\n  ;\n  USE(function (module) {\n    USE('./base64'); // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\n\n    function SeaArray() {}\n\n    Object.assign(SeaArray, {\n      from: Array.from\n    });\n    SeaArray.prototype = Object.create(Array.prototype);\n\n    SeaArray.prototype.toString = function (enc, start, end) {\n      enc = enc || 'utf8';\n      start = start || 0;\n      const length = this.length;\n\n      if (enc === 'hex') {\n        const buf = new Uint8Array(this);\n        return [...Array((end && end + 1 || length) - start).keys()].map(i => buf[i + start].toString(16).padStart(2, '0')).join('');\n      }\n\n      if (enc === 'utf8') {\n        return Array.from({\n          length: (end || length) - start\n        }, (_, i) => String.fromCharCode(this[i + start])).join('');\n      }\n\n      if (enc === 'base64') {\n        return btoa(this);\n      }\n    };\n\n    module.exports = SeaArray;\n  })(USE, './array');\n  ;\n  USE(function (module) {\n    USE('./base64'); // This is Buffer implementation used in SEA. Functionality is mostly\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\n    // between binary and 'hex' | 'utf8' | 'base64'\n    // See documentation and validation for safe implementation in:\n    // https://github.com/feross/safe-buffer#update\n\n    var SeaArray = USE('./array');\n\n    function SafeBuffer(...props) {\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()');\n      return SafeBuffer.from(...props);\n    }\n\n    SafeBuffer.prototype = Object.create(Array.prototype);\n    Object.assign(SafeBuffer, {\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\n      from() {\n        if (!Object.keys(arguments).length || arguments[0] == null) {\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');\n        }\n\n        const input = arguments[0];\n        let buf;\n\n        if (typeof input === 'string') {\n          const enc = arguments[1] || 'utf8';\n\n          if (enc === 'hex') {\n            const bytes = input.match(/([\\da-fA-F]{2})/g).map(byte => parseInt(byte, 16));\n\n            if (!bytes || !bytes.length) {\n              throw new TypeError('Invalid first argument for type \\'hex\\'.');\n            }\n\n            buf = SeaArray.from(bytes);\n          } else if (enc === 'utf8') {\n            const length = input.length;\n            const words = new Uint16Array(length);\n            Array.from({\n              length: length\n            }, (_, i) => words[i] = input.charCodeAt(i));\n            buf = SeaArray.from(words);\n          } else if (enc === 'base64') {\n            const dec = atob(input);\n            const length = dec.length;\n            const bytes = new Uint8Array(length);\n            Array.from({\n              length: length\n            }, (_, i) => bytes[i] = dec.charCodeAt(i));\n            buf = SeaArray.from(bytes);\n          } else if (enc === 'binary') {\n            buf = SeaArray.from(input);\n          } else {\n            console.info('SafeBuffer.from unknown encoding: ' + enc);\n          }\n\n          return buf;\n        }\n\n        const byteLength = input.byteLength; // what is going on here? FOR MARTTI\n\n        const length = input.byteLength ? input.byteLength : input.length;\n\n        if (length) {\n          let buf;\n\n          if (input instanceof ArrayBuffer) {\n            buf = new Uint8Array(input);\n          }\n\n          return SeaArray.from(buf || input);\n        }\n      },\n\n      // This is 'safe-buffer.alloc' sans encoding support\n      alloc(length, fill = 0\n      /*, enc*/\n      ) {\n        return SeaArray.from(new Uint8Array(Array.from({\n          length: length\n        }, () => fill)));\n      },\n\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\n      allocUnsafe(length) {\n        return SeaArray.from(new Uint8Array(Array.from({\n          length: length\n        })));\n      },\n\n      // This puts together array of array like members\n      concat(arr) {\n        // octet array\n        if (!Array.isArray(arr)) {\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.');\n        }\n\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []));\n      }\n\n    });\n    SafeBuffer.prototype.from = SafeBuffer.from;\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString;\n    module.exports = SafeBuffer;\n  })(USE, './buffer');\n  ;\n  USE(function (module) {\n    const SEA = USE('./root');\n    const Buffer = USE('./buffer');\n    const api = {\n      Buffer: Buffer\n    };\n    var o = {};\n\n    if (SEA.window) {\n      api.crypto = window.crypto || window.msCrypto;\n      api.subtle = (api.crypto || o).subtle || (api.crypto || o).webkitSubtle;\n      api.TextEncoder = window.TextEncoder;\n      api.TextDecoder = window.TextDecoder;\n\n      api.random = len => Buffer.from(api.crypto.getRandomValues(new Uint8Array(Buffer.alloc(len))));\n    }\n\n    if (!api.TextDecoder) {\n      const {\n        TextEncoder,\n        TextDecoder\n      } = require('text-encoding');\n\n      api.TextDecoder = TextDecoder;\n      api.TextEncoder = TextEncoder;\n    }\n\n    if (!api.crypto) {\n      try {\n        var crypto = USE('crypto', 1);\n        Object.assign(api, {\n          crypto,\n          random: len => Buffer.from(crypto.randomBytes(len))\n        });\n        const {\n          Crypto: WebCrypto\n        } = USE('@peculiar/webcrypto', 1);\n        api.ossl = api.subtle = new WebCrypto({\n          directory: 'ossl'\n        }).subtle; // ECDH\n      } catch (e) {\n        console.log(\"text-encoding and @peculiar/webcrypto may not be included by default, please add it to your package.json!\");\n      }\n    }\n\n    module.exports = api;\n  })(USE, './shim');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var Buffer = USE('./buffer');\n    var s = {};\n    s.pbkdf2 = {\n      hash: {\n        name: 'SHA-256'\n      },\n      iter: 100000,\n      ks: 64\n    };\n    s.ecdsa = {\n      pair: {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      },\n      sign: {\n        name: 'ECDSA',\n        hash: {\n          name: 'SHA-256'\n        }\n      }\n    };\n    s.ecdh = {\n      name: 'ECDH',\n      namedCurve: 'P-256'\n    }; // This creates Web Cryptography API compliant JWK for sign/verify purposes\n\n    s.jwk = function (pub, d) {\n      // d === priv\n      pub = pub.split('.');\n      var x = pub[0],\n          y = pub[1];\n      var jwk = {\n        kty: \"EC\",\n        crv: \"P-256\",\n        x: x,\n        y: y,\n        ext: true\n      };\n      jwk.key_ops = d ? ['sign'] : ['verify'];\n\n      if (d) {\n        jwk.d = d;\n      }\n\n      return jwk;\n    };\n\n    s.keyToJwk = function (keyBytes) {\n      const keyB64 = keyBytes.toString('base64');\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n      return {\n        kty: 'oct',\n        k: k,\n        ext: false,\n        alg: 'A256GCM'\n      };\n    };\n\n    s.recall = {\n      validity: 12 * 60 * 60,\n      // internally in seconds : 12 hours\n      hook: function (props) {\n        return props;\n      } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\n\n    };\n\n    s.check = function (t) {\n      return typeof t == 'string' && 'SEA{' === t.slice(0, 4);\n    };\n\n    s.parse = function p(t) {\n      try {\n        var yes = typeof t == 'string';\n\n        if (yes && 'SEA{' === t.slice(0, 4)) {\n          t = t.slice(3);\n        }\n\n        return yes ? JSON.parse(t) : t;\n      } catch (e) {}\n\n      return t;\n    };\n\n    SEA.opt = s;\n    module.exports = s;\n  })(USE, './settings');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim');\n\n    module.exports = async function (d, o) {\n      var t = typeof d == 'string' ? d : JSON.stringify(d);\n      var hash = await shim.subtle.digest({\n        name: o || 'SHA-256'\n      }, new shim.TextEncoder().encode(t));\n      return shim.Buffer.from(hash);\n    };\n  })(USE, './sha256');\n  ;\n  USE(function (module) {\n    // This internal func returns SHA-1 hashed data for KeyID generation\n    const __shim = USE('./shim');\n\n    const subtle = __shim.subtle;\n    const ossl = __shim.ossl ? __shim.ossl : subtle;\n\n    const sha1hash = b => ossl.digest({\n      name: 'SHA-1'\n    }, new ArrayBuffer(b));\n\n    module.exports = sha1hash;\n  })(USE, './sha1');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => {\n      try {\n        // used to be named `proof`\n        var salt = (pair || {}).epub || pair; // epub not recommended, salt should be random!\n\n        opt = opt || {};\n\n        if (salt instanceof Function) {\n          cb = salt;\n          salt = u;\n        }\n\n        data = typeof data == 'string' ? data : JSON.stringify(data);\n\n        if ('sha' === (opt.name || '').toLowerCase().slice(0, 3)) {\n          var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64');\n\n          if (cb) {\n            try {\n              cb(rsha);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return rsha;\n        }\n\n        salt = salt || shim.random(9);\n        var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {\n          name: opt.name || 'PBKDF2'\n        }, false, ['deriveBits']);\n        var work = await (shim.ossl || shim.subtle).deriveBits({\n          name: opt.name || 'PBKDF2',\n          iterations: opt.iterations || S.pbkdf2.iter,\n          salt: new shim.TextEncoder().encode(opt.salt || salt),\n          hash: opt.hash || S.pbkdf2.hash\n        }, key, opt.length || S.pbkdf2.ks * 8);\n        data = shim.random(data.length); // Erase data in case of passphrase\n\n        var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64');\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.work;\n  })(USE, './work');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n\n    SEA.name = SEA.name || (async (cb, opt) => {\n      try {\n        if (cb) {\n          try {\n            cb();\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    }); //SEA.pair = async (data, proof, cb) => { try {\n\n\n    SEA.pair = SEA.pair || (async (cb, opt) => {\n      try {\n        var ecdhSubtle = shim.ossl || shim.subtle; // First: ECDSA keys for signing/verifying...\n\n        var sa = await shim.subtle.generateKey({\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, true, ['sign', 'verify']).then(async keys => {\n          // privateKey scope doesn't leak out from here!\n          //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\n          var key = {};\n          key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\n          var pub = await shim.subtle.exportKey('jwk', keys.publicKey); //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\n\n          key.pub = pub.x + '.' + pub.y; // new\n          // x and y are already base64\n          // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n          // but split on a non-base64 letter.\n\n          return key;\n        }); // To include PGPv4 kind of keyId:\n        // const pubId = await SEA.keyid(keys.pub)\n        // Next: ECDH keys for encryption/decryption...\n\n        try {\n          var dh = await ecdhSubtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256'\n          }, true, ['deriveKey']).then(async keys => {\n            // privateKey scope doesn't leak out from here!\n            var key = {};\n            key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\n            var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey); //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\n\n            key.epub = pub.x + '.' + pub.y; // new\n            // ex and ey are already base64\n            // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n            // but split on a non-base64 letter.\n\n            return key;\n          });\n        } catch (e) {\n          if (SEA.window) {\n            throw e;\n          }\n\n          if (e == 'Error: ECDH is not a supported algorithm') {\n            console.log('Ignoring ECDH...');\n          } else {\n            throw e;\n          }\n        }\n\n        dh = dh || {};\n        var r = {\n          pub: sa.pub,\n          priv: sa.priv,\n\n          /* pubId, */\n          epub: dh.epub,\n          epriv: dh.epriv\n        };\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.pair;\n  })(USE, './pair');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n\n        if (!(pair || opt).priv) {\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'sign',\n            why: opt.why\n          });\n        }\n\n        if (u === data) {\n          throw '`undefined` not allowed.';\n        }\n\n        var json = S.parse(data);\n        var check = opt.check = opt.check || json;\n\n        if (SEA.verify && (SEA.opt.check(check) || check && check.s && check.m) && u !== (await SEA.verify(check, pair))) {\n          // don't sign if we already signed it.\n          var r = S.parse(check);\n\n          if (!opt.raw) {\n            r = 'SEA' + JSON.stringify(r);\n          }\n\n          if (cb) {\n            try {\n              cb(r);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return r;\n        }\n\n        var pub = pair.pub;\n        var priv = pair.priv;\n        var jwk = S.jwk(pub, priv);\n        var hash = await sha(json);\n        var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, false, ['sign']).then(key => (shim.ossl || shim.subtle).sign({\n          name: 'ECDSA',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, key, new Uint8Array(hash))); // privateKey scope doesn't leak out from here!\n\n        var r = {\n          m: json,\n          s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')\n        };\n\n        if (!opt.raw) {\n          r = 'SEA' + JSON.stringify(r);\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.sign;\n  })(USE, './sign');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => {\n      try {\n        var json = S.parse(data);\n\n        if (false === pair) {\n          // don't verify!\n          var raw = S.parse(json.m);\n\n          if (cb) {\n            try {\n              cb(raw);\n            } catch (e) {\n              console.log(e);\n            }\n          }\n\n          return raw;\n        }\n\n        opt = opt || {}; // SEA.I // verify is free! Requires no user permission.\n\n        var pub = pair.pub || pair;\n        var key = SEA.opt.slow_leak ? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {\n          name: 'ECDSA',\n          namedCurve: 'P-256'\n        }, false, ['verify']);\n        var hash = await sha(json.m);\n        var buf, sig, check, tmp;\n\n        try {\n          buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n\n          sig = new Uint8Array(buf);\n          check = await (shim.ossl || shim.subtle).verify({\n            name: 'ECDSA',\n            hash: {\n              name: 'SHA-256'\n            }\n          }, key, sig, new Uint8Array(hash));\n\n          if (!check) {\n            throw \"Signature did not match.\";\n          }\n        } catch (e) {\n          if (SEA.opt.fallback) {\n            return await SEA.opt.fall_verify(data, pair, cb, opt);\n          }\n        }\n\n        var r = check ? S.parse(json.m) : u;\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e); // mismatched owner FOR MARTTI\n\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.verify; // legacy & ossl leak mitigation:\n\n    var knownKeys = {};\n\n    var keyForPair = SEA.opt.slow_leak = pair => {\n      if (knownKeys[pair]) return knownKeys[pair];\n      var jwk = S.jwk(pair);\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      }, false, [\"verify\"]);\n      return knownKeys[pair];\n    };\n\n    var O = SEA.opt;\n\n    SEA.opt.fall_verify = async function (data, pair, cb, opt, f) {\n      if (f === SEA.opt.fallback) {\n        throw \"Signature did not match\";\n      }\n\n      f = f || 1;\n      var tmp = data || '';\n      data = SEA.opt.unpack(data) || data;\n      var json = S.parse(data),\n          pub = pair.pub || pair,\n          key = await SEA.opt.slow_leak(pub);\n      var hash = f <= SEA.opt.fallback ? shim.Buffer.from(await shim.subtle.digest({\n        name: 'SHA-256'\n      }, new shim.TextEncoder().encode(S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\n\n      var buf;\n      var sig;\n      var check;\n\n      try {\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({\n          name: 'ECDSA',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, key, sig, new Uint8Array(hash));\n\n        if (!check) {\n          throw \"Signature did not match.\";\n        }\n      } catch (e) {\n        buf = shim.Buffer.from(json.s, 'utf8'); // AUTO BACKWARD OLD UTF8 DATA!\n\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({\n          name: 'ECDSA',\n          hash: {\n            name: 'SHA-256'\n          }\n        }, key, sig, new Uint8Array(hash));\n\n        if (!check) {\n          throw \"Signature did not match.\";\n        }\n      }\n\n      var r = check ? S.parse(json.m) : u;\n      O.fall_soul = tmp['#'];\n      O.fall_key = tmp['.'];\n      O.fall_val = data;\n      O.fall_state = tmp['>'];\n\n      if (cb) {\n        try {\n          cb(r);\n        } catch (e) {\n          console.log(e);\n        }\n      }\n\n      return r;\n    };\n\n    SEA.opt.fallback = 2;\n  })(USE, './verify');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha256hash = USE('./sha256');\n\n    const importGen = async (key, salt, opt) => {\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\n      opt = opt || {};\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\n\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary');\n      const jwkKey = S.keyToJwk(hash);\n      return await shim.subtle.importKey('jwk', jwkKey, {\n        name: 'AES-GCM'\n      }, false, ['encrypt', 'decrypt']);\n    };\n\n    module.exports = importGen;\n  })(USE, './aeskey');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n    var u;\n\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n        var key = (pair || opt).epriv || pair;\n\n        if (u === data) {\n          throw '`undefined` not allowed.';\n        }\n\n        if (!key) {\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'encrypt',\n            why: opt.why\n          });\n          key = pair.epriv || pair;\n        }\n\n        var msg = typeof data == 'string' ? data : JSON.stringify(data);\n        var rand = {\n          s: shim.random(9),\n          iv: shim.random(15)\n        }; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\n\n        var ct = await aeskey(key, rand.s, opt).then(aes =>\n        /*shim.ossl ||*/\n        shim.subtle.encrypt({\n          // Keeping the AES key scope as private as possible...\n          name: opt.name || 'AES-GCM',\n          iv: new Uint8Array(rand.iv)\n        }, aes, new shim.TextEncoder().encode(msg)));\n        var r = {\n          ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\n          iv: rand.iv.toString(opt.encode || 'base64'),\n          s: rand.s.toString(opt.encode || 'base64')\n        };\n\n        if (!opt.raw) {\n          r = 'SEA' + JSON.stringify(r);\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.encrypt;\n  })(USE, './encrypt');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n        var key = (pair || opt).epriv || pair;\n\n        if (!key) {\n          pair = await SEA.I(null, {\n            what: data,\n            how: 'decrypt',\n            why: opt.why\n          });\n          key = pair.epriv || pair;\n        }\n\n        var json = S.parse(data);\n        var buf, bufiv, bufct;\n\n        try {\n          buf = shim.Buffer.from(json.s, opt.encode || 'base64');\n          bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\n          bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\n          var ct = await aeskey(key, buf, opt).then(aes =>\n          /*shim.ossl ||*/\n          shim.subtle.decrypt({\n            // Keeping aesKey scope as private as possible...\n            name: opt.name || 'AES-GCM',\n            iv: new Uint8Array(bufiv),\n            tagLength: 128\n          }, aes, new Uint8Array(bufct)));\n        } catch (e) {\n          if ('utf8' === opt.encode) {\n            throw \"Could not decrypt\";\n          }\n\n          if (SEA.opt.fallback) {\n            opt.encode = 'utf8';\n            return await SEA.decrypt(data, pair, cb, opt);\n          }\n        }\n\n        var r = S.parse(new shim.TextDecoder('utf8').decode(ct));\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.decrypt;\n  })(USE, './decrypt');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings'); // Derive shared secret from other's pub and my epub/epriv \n\n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => {\n      try {\n        opt = opt || {};\n\n        if (!pair || !pair.epriv || !pair.epub) {\n          pair = await SEA.I(null, {\n            what: key,\n            how: 'secret',\n            why: opt.why\n          });\n        }\n\n        var pub = key.epub || key;\n        var epub = pair.epub;\n        var epriv = pair.epriv;\n        var ecdhSubtle = shim.ossl || shim.subtle;\n        var pubKeyData = keysToEcdhJwk(pub);\n        var props = Object.assign({\n          public: await ecdhSubtle.importKey(...pubKeyData, true, [])\n        }, {\n          name: 'ECDH',\n          namedCurve: 'P-256'\n        }); // Thanks to @sirpy !\n\n        var privKeyData = keysToEcdhJwk(epub, epriv);\n        var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async privKey => {\n          // privateKey scope doesn't leak out from here!\n          var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\n          var rawBits = new Uint8Array(derivedBits);\n          var derivedKey = await ecdhSubtle.importKey('raw', rawBits, {\n            name: 'AES-GCM',\n            length: 256\n          }, true, ['encrypt', 'decrypt']);\n          return ecdhSubtle.exportKey('jwk', derivedKey).then(({\n            k\n          }) => k);\n        });\n        var r = derived;\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        console.log(e);\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    }); // can this be replaced with settings.jwk?\n\n\n    var keysToEcdhJwk = (pub, d) => {\n      // d === priv\n      //var [ x, y ] = Buffer.from(pub, 'base64').toString('utf8').split(':') // old\n      var [x, y] = pub.split('.'); // new\n\n      var jwk = d ? {\n        d: d\n      } : {};\n      return [// Use with spread returned value...\n      'jwk', Object.assign(jwk, {\n        x: x,\n        y: y,\n        kty: 'EC',\n        crv: 'P-256',\n        ext: true\n      }), // ??? refactor\n      {\n        name: 'ECDH',\n        namedCurve: 'P-256'\n      }];\n    };\n\n    module.exports = SEA.secret;\n  })(USE, './secret');\n  ;\n  USE(function (module) {\n    var SEA = USE('./root'); // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\n\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => {\n      try {\n        /*\n        IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\n        \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\n        \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\n        \"authority\": Key pair or priv of the certificate authority.\n        \"cb\": A callback function after all things are done.\n        \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.blacklist is set, SEA will look for blacklist before syncing.\n        */\n        console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.');\n\n        certificants = (() => {\n          var data = [];\n\n          if (certificants) {\n            if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') !== -1) return '*';\n\n            if (typeof certificants === 'string') {\n              return certificants;\n            }\n\n            if (Array.isArray(certificants)) {\n              if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null;\n              certificants.map(certificant => {\n                if (typeof certificant === 'string') data.push(certificant);else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub);\n              });\n            }\n\n            if (typeof certificants === 'object' && certificants.pub) return certificants.pub;\n            return data.length > 0 ? data : null;\n          }\n\n          return null;\n        })();\n\n        if (!certificants) return console.log(\"No certificant found.\");\n        const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null;\n        const readPolicy = (policy || {}).read ? policy.read : null;\n        const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null;\n        const readBlacklist = ((opt || {}).blacklist || {}).read && (typeof opt.blacklist.read === 'string' || opt.blacklist.read['#']) ? opt.blacklist.read : null;\n        const writeBlacklist = typeof (opt || {}).blacklist === 'string' || (((opt || {}).blacklist || {}).write || {})['#'] ? opt.blacklist : ((opt || {}).blacklist || {}).write && (typeof opt.blacklist.write === 'string' || opt.blacklist.write['#']) ? opt.blacklist.write : null;\n        if (!readPolicy && !writePolicy) return console.log(\"No policy found.\"); // reserved keys: c, e, r, w, rb, wb\n\n        const data = JSON.stringify({\n          c: certificants,\n          ...(expiry ? {\n            e: expiry\n          } : {}),\n          // inject expiry if possible\n          ...(readPolicy ? {\n            r: readPolicy\n          } : {}),\n          // \"r\" stands for read, which means read permission.\n          ...(writePolicy ? {\n            w: writePolicy\n          } : {}),\n          // \"w\" stands for write, which means write permission.\n          ...(readBlacklist ? {\n            rb: readBlacklist\n          } : {}),\n          // inject READ blacklist if possible\n          ...(writeBlacklist ? {\n            wb: writeBlacklist\n          } : {}) // inject WRITE blacklist if possible\n\n        });\n        const certificate = await SEA.sign(data, authority, null, {\n          raw: 1\n        });\n        var r = certificate;\n\n        if (!opt.raw) {\n          r = 'SEA' + JSON.stringify(r);\n        }\n\n        if (cb) {\n          try {\n            cb(r);\n          } catch (e) {\n            console.log(e);\n          }\n        }\n\n        return r;\n      } catch (e) {\n        SEA.err = e;\n\n        if (SEA.throw) {\n          throw e;\n        }\n\n        if (cb) {\n          cb();\n        }\n\n        return;\n      }\n    });\n\n    module.exports = SEA.certify;\n  })(USE, './certify');\n  ;\n  USE(function (module) {\n    var shim = USE('./shim'); // Practical examples about usage found in tests.\n\n    var SEA = USE('./root');\n    SEA.work = USE('./work');\n    SEA.sign = USE('./sign');\n    SEA.verify = USE('./verify');\n    SEA.encrypt = USE('./encrypt');\n    SEA.decrypt = USE('./decrypt');\n    SEA.certify = USE('./certify'); //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\n\n    SEA.random = SEA.random || shim.random; // This is Buffer used in SEA and usable from Gun/SEA application also.\n    // For documentation see https://nodejs.org/api/buffer.html\n\n    SEA.Buffer = SEA.Buffer || USE('./buffer'); // These SEA functions support now ony Promises or\n    // async/await (compatible) code, use those like Promises.\n    //\n    // Creates a wrapper library around Web Crypto API\n    // for various AES, ECDSA, PBKDF2 functions we called above.\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\n\n    SEA.keyid = SEA.keyid || (async pub => {\n      try {\n        // base64('base64(x):base64(y)') => Buffer(xy)\n        const pb = Buffer.concat(pub.replace(/-/g, '+').replace(/_/g, '/').split('.').map(t => Buffer.from(t, 'base64'))); // id is PGPv4 compliant raw key\n\n        const id = Buffer.concat([Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb]);\n        const sha1 = await sha1hash(id);\n        const hash = Buffer.from(sha1, 'binary');\n        return hash.toString('hex', hash.length - 8); // 16-bit ID as hex\n      } catch (e) {\n        console.log(e);\n        throw e;\n      }\n    }); // all done!\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\n    // SEA should be a full suite that is easy and seamless to use.\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\n    // But all other behavior needs to be equally easy, like opinionated ways of\n    // Adding friends (trusted public keys), sending private messages, etc.\n    // Cheers! Tell me what you think.\n\n\n    var Gun = (SEA.window || {}).Gun || USE((typeof MODULE == \"undefined\" ? '.' : '') + './gun', 1);\n    Gun.SEA = SEA;\n    SEA.GUN = SEA.Gun = Gun;\n    module.exports = SEA;\n  })(USE, './sea');\n  ;\n  USE(function (module) {\n    var Gun = USE('./sea').Gun;\n\n    Gun.chain.then = function (cb, opt) {\n      var gun = this,\n          p = new Promise(function (res, rej) {\n        gun.once(res, opt);\n      });\n      return cb ? p.then(cb) : p;\n    };\n  })(USE, './then');\n  ;\n  USE(function (module) {\n    var SEA = USE('./sea');\n    var Gun = SEA.Gun;\n    var then = USE('./then');\n\n    function User(root) {\n      this._ = {\n        $: this\n      };\n    }\n\n    User.prototype = function () {\n      function F() {}\n\n      ;\n      F.prototype = Gun.chain;\n      return new F();\n    }(); // Object.create polyfill\n\n\n    User.prototype.constructor = User; // let's extend the gun chain with a `user` function.\n    // only one user can be logged in at a time, per gun instance.\n\n    Gun.chain.user = function (pub) {\n      var gun = this,\n          root = gun.back(-1),\n          user;\n\n      if (pub) {\n        return root.get('~' + pub);\n      }\n\n      if (user = root.back('user')) {\n        return user;\n      }\n\n      var root = root._,\n          at = root,\n          uuid = at.opt.uuid || Gun.state.lex;\n      (at = (user = at.user = gun.chain(new User()))._).opt = {};\n\n      at.opt.uuid = function (cb) {\n        var id = uuid(),\n            pub = root.user;\n\n        if (!pub || !(pub = pub.is) || !(pub = pub.pub)) {\n          return id;\n        }\n\n        id = id + '~' + pub + '/';\n\n        if (cb && cb.call) {\n          cb(null, id);\n        }\n\n        return id;\n      };\n\n      return user;\n    };\n\n    Gun.User = User;\n    module.exports = User;\n  })(USE, './user');\n  ;\n  USE(function (module) {\n    // TODO: This needs to be split into all separate functions.\n    // Not just everything thrown into 'create'.\n    var SEA = USE('./sea');\n    var User = USE('./user');\n    var authsettings = USE('./settings');\n    var Gun = SEA.Gun;\n\n    var noop = function () {}; // Well first we have to actually create a user. That is what this function does.\n\n\n    User.prototype.create = function (...args) {\n      const pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      const alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\n      const pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\n      const cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n\n      const opt = args && args.length > 1 && typeof args[args.length - 1] === 'object' ? args[args.length - 1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n\n      var gun = this,\n          cat = gun._,\n          root = gun.back(-1);\n\n      if (cat.ing) {\n        (cb || noop)({\n          err: Gun.log(\"User is already being created or authenticated!\"),\n          wait: true\n        });\n        return gun;\n      }\n\n      cat.ing = true;\n      var act = {},\n          u;\n\n      act.a = function (pubs) {\n        act.pubs = pubs;\n\n        if (pubs && !opt.already) {\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\n          var ack = {\n            err: Gun.log('User already created!')\n          };\n          cat.ing = false;\n          (cb || noop)(ack);\n          gun.leave();\n          return;\n        }\n\n        act.salt = Gun.text.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\n\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\n      };\n\n      act.b = function (proof) {\n        act.proof = proof;\n        pair ? act.c(pair) : SEA.pair(act.c); // generate a brand new key pair or use the existing.\n      };\n\n      act.c = function (pair) {\n        var tmp;\n        act.pair = pair || {};\n\n        if (tmp = cat.root.user) {\n          tmp._.sea = pair;\n          tmp.is = {\n            pub: pair.pub,\n            epub: pair.epub,\n            alias: alias\n          };\n        } // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\n\n\n        act.data = {\n          pub: pair.pub\n        };\n        act.d();\n      };\n\n      act.d = function () {\n        act.data.alias = alias;\n        act.e();\n      };\n\n      act.e = function () {\n        act.data.epub = act.pair.epub;\n        SEA.encrypt({\n          priv: act.pair.priv,\n          epriv: act.pair.epriv\n        }, act.proof, act.f, {\n          raw: 1\n        }); // to keep the private key safe, we AES encrypt it with the proof of work!\n      };\n\n      act.f = function (auth) {\n        act.data.auth = JSON.stringify({\n          ek: auth,\n          s: act.salt\n        });\n        act.g(act.data.auth);\n      };\n\n      act.g = function (auth) {\n        var tmp;\n        act.data.auth = act.data.auth || auth;\n        root.get(tmp = '~' + act.pair.pub).put(act.data); // awesome, now we can actually save the user with their public key as their ID.\n\n        root.get('~@' + alias).put(Gun.obj.put({}, tmp, Gun.val.link.ify(tmp)), act.h); // next up, we want to associate the alias with the public key. So we add it to the alias list.\n      };\n\n      act.h = function () {\n        cat.ing = false;\n        (cb || noop)({\n          ok: 0,\n          pub: act.pair.pub\n        }); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\n\n        if (!cb) {\n          pair ? gun.auth(pair) : gun.auth(alias, pass);\n        } // if no callback is passed, auto-login after signing up.\n\n      };\n\n      root.get('~@' + alias).once(act.a);\n      return gun;\n    }; // now that we have created a user, we want to authenticate them!\n\n\n    User.prototype.auth = function (...args) {\n      const pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      const alias = !pair && typeof args[0] === 'string' ? args[0] : null;\n      const pass = alias && typeof args[1] === 'string' ? args[1] : null;\n      const cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n\n      const opt = args && args.length > 1 && typeof args[args.length - 1] === 'object' ? args[args.length - 1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n\n      var gun = this,\n          cat = gun._,\n          root = gun.back(-1);\n\n      if (cat.ing) {\n        (cb || noop)({\n          err: Gun.log(\"User is already being created or authenticated!\"),\n          wait: true\n        });\n        return gun;\n      }\n\n      cat.ing = true;\n      var act = {},\n          u;\n\n      act.a = function (data) {\n        if (!data) {\n          return act.b();\n        }\n\n        if (!data.pub) {\n          var tmp = [];\n          Gun.node.is(data, function (v) {\n            tmp.push(v);\n          });\n          return act.b(tmp);\n        }\n\n        if (act.name) {\n          return act.f(data);\n        }\n\n        act.c((act.data = data).auth);\n      };\n\n      act.b = function (list) {\n        var get = (act.list = (act.list || []).concat(list || [])).shift();\n\n        if (u === get) {\n          if (act.name) {\n            return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.');\n          }\n\n          return act.err('Wrong user or password.');\n        }\n\n        root.get(get).once(act.a);\n      };\n\n      act.c = function (auth) {\n        if (u === auth) {\n          return act.b();\n        }\n\n        if (Gun.text.is(auth)) {\n          return act.c(Gun.obj.ify(auth));\n        } // in case of legacy\n\n\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\n      };\n\n      act.d = function (proof) {\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\n      };\n\n      act.e = function (half) {\n        if (u === half) {\n          if (!act.enc) {\n            // try old format\n            act.enc = {\n              encode: 'utf8'\n            };\n            return act.c(act.auth);\n          }\n\n          act.enc = null; // end backwards\n\n          return act.b();\n        }\n\n        act.half = half;\n        act.f(act.data);\n      };\n\n      act.f = function (data) {\n        if (!data || !data.pub) {\n          return act.b();\n        }\n\n        var tmp = act.half || {};\n        act.g({\n          pub: data.pub,\n          epub: data.epub,\n          priv: tmp.priv,\n          epriv: tmp.epriv\n        });\n      };\n\n      act.g = function (pair) {\n        act.pair = pair;\n        var user = root._.user,\n            at = user._;\n        var tmp = at.tag;\n        var upt = at.opt;\n        at = user._ = root.get('~' + pair.pub)._;\n        at.opt = upt; // add our credentials in-memory only to our root user instance\n\n        user.is = {\n          pub: pair.pub,\n          epub: pair.epub,\n          alias: alias || pair\n        };\n        at.sea = act.pair;\n        cat.ing = false;\n\n        try {\n          if (pass && !Gun.obj.has(Gun.obj.ify(cat.root.graph['~' + pair.pub].auth), ':')) {\n            opt.shuffle = opt.change = pass;\n          }\n        } catch (e) {} // migrate UTF8 & Shuffle!\n\n\n        opt.change ? act.z() : (cb || noop)(at);\n\n        if (SEA.window && (gun.back('user')._.opt || opt).remember) {\n          // TODO: this needs to be modular.\n          try {\n            var sS = {};\n            sS = window.sessionStorage;\n            sS.recall = true;\n            sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\n          } catch (e) {}\n        }\n\n        try {\n          root._.on('auth', at); // TODO: Deprecate this, emit on user instead! Update docs when you do.\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\n\n        } catch (e) {\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\n        }\n      };\n\n      act.z = function () {\n        // password update so encrypt private key using new pwd + salt\n        act.salt = Gun.text.random(64); // pseudo-random\n\n        SEA.work(opt.change, act.salt, act.y);\n      };\n\n      act.y = function (proof) {\n        SEA.encrypt({\n          priv: act.pair.priv,\n          epriv: act.pair.epriv\n        }, proof, act.x, {\n          raw: 1\n        });\n      };\n\n      act.x = function (auth) {\n        act.w(JSON.stringify({\n          ek: auth,\n          s: act.salt\n        }));\n      };\n\n      act.w = function (auth) {\n        if (opt.shuffle) {\n          // delete in future!\n          console.log('migrate core account from UTF8 & shuffle');\n          var tmp = Gun.obj.to(act.data);\n          Gun.obj.del(tmp, '_');\n          tmp.auth = auth;\n          root.get('~' + act.pair.pub).put(tmp);\n        } // end delete\n\n\n        root.get('~' + act.pair.pub).get('auth').put(auth, cb || noop);\n      };\n\n      act.err = function (e) {\n        var ack = {\n          err: Gun.log(e || 'User cannot be found!')\n        };\n        cat.ing = false;\n        (cb || noop)(ack);\n      };\n\n      act.plugin = function (name) {\n        if (!(act.name = name)) {\n          return act.err();\n        }\n\n        var tmp = [name];\n\n        if ('~' !== name[0]) {\n          tmp[1] = '~' + name;\n          tmp[2] = '~@' + name;\n        }\n\n        act.b(tmp);\n      };\n\n      if (pair) {\n        act.g(pair);\n      } else if (alias) {\n        root.get('~@' + alias).once(act.a);\n      } else if (!alias && !pass) {\n        SEA.name(act.plugin);\n      }\n\n      return gun;\n    };\n\n    User.prototype.pair = function () {\n      console.log(\"user.pair() IS DEPRECATED AND WILL BE DELETED!!!\");\n      var user = this;\n\n      if (!user.is) {\n        return false;\n      }\n\n      return user._.sea;\n    };\n\n    User.prototype.leave = function (opt, cb) {\n      var gun = this,\n          user = gun.back(-1)._.user;\n\n      if (user) {\n        delete user.is;\n        delete user._.is;\n        delete user._.sea;\n      }\n\n      if (SEA.window) {\n        try {\n          var sS = {};\n          sS = window.sessionStorage;\n          delete sS.recall;\n          delete sS.pair;\n        } catch (e) {}\n\n        ;\n      }\n\n      return gun;\n    }; // If authenticated user wants to delete his/her account, let's support it!\n\n\n    User.prototype.delete = async function (alias, pass, cb) {\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\n      var gun = this,\n          root = gun.back(-1),\n          user = gun.back('user');\n\n      try {\n        user.auth(alias, pass, function (ack) {\n          var pub = (user.is || {}).pub; // Delete user data\n\n          user.map().once(function () {\n            this.put(null);\n          }); // Wipe user data from memory\n\n          user.leave();\n          (cb || noop)({\n            ok: 0\n          });\n        });\n      } catch (e) {\n        Gun.log('User.delete failed! Error:', e);\n      }\n\n      return gun;\n    };\n\n    User.prototype.recall = function (opt, cb) {\n      var gun = this,\n          root = gun.back(-1),\n          tmp;\n      opt = opt || {};\n\n      if (opt && opt.sessionStorage) {\n        if (SEA.window) {\n          try {\n            var sS = {};\n            sS = window.sessionStorage;\n\n            if (sS) {\n              root._.opt.remember = true;\n              (gun.back('user')._.opt || opt).remember = true;\n              if (sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\n            }\n          } catch (e) {}\n        }\n\n        return gun;\n      }\n      /*\n        TODO: copy mhelander's expiry code back in.\n        Although, we should check with community,\n        should expiry be core or a plugin?\n      */\n\n\n      return gun;\n    };\n\n    User.prototype.alive = async function () {\n      console.log(\"user.alive() IS DEPRECATED!!!\");\n      const gunRoot = this.back(-1);\n\n      try {\n        // All is good. Should we do something more with actual recalled data?\n        await authRecall(gunRoot);\n        return gunRoot._.user._;\n      } catch (e) {\n        const err = 'No session!';\n        Gun.log(err);\n        throw {\n          err\n        };\n      }\n    };\n\n    User.prototype.trust = async function (user) {\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\n      //gun.get('alice').get('age').trust(bob);\n      if (Gun.is(user)) {\n        user.get('pub').get((ctx, ev) => {\n          console.log(ctx, ev);\n        });\n      }\n\n      user.get('trust').get(path).put(theirPubkey); // do a lookup on this gun chain directly (that gets bob's copy of the data)\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\n      // THEN you perform Jachen's mix operation\n      // and return the result of that to...\n    };\n\n    User.prototype.grant = function (to, cb) {\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this,\n          user = gun.back(-1).user(),\n          pair = user._.sea,\n          path = '';\n      gun.back(function (at) {\n        if (at.is) {\n          return;\n        }\n\n        path += at.get || '';\n      });\n\n      (async function () {\n        var enc,\n            sec = await user.get('grant').get(pair.pub).get(path).then();\n        sec = await SEA.decrypt(sec, pair);\n\n        if (!sec) {\n          sec = SEA.random(16).toString();\n          enc = await SEA.encrypt(sec, pair);\n          user.get('grant').get(pair.pub).get(path).put(enc);\n        }\n\n        var pub = to.get('pub').then();\n        var epub = to.get('epub').then();\n        pub = await pub;\n        epub = await epub;\n        var dh = await SEA.secret(epub, pair);\n        enc = await SEA.encrypt(sec, dh);\n        user.get('grant').get(pub).get(path).put(enc, cb);\n      })();\n\n      return gun;\n    };\n\n    User.prototype.secret = function (data, cb) {\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this,\n          user = gun.back(-1).user(),\n          pair = user.pair(),\n          path = '';\n      gun.back(function (at) {\n        if (at.is) {\n          return;\n        }\n\n        path += at.get || '';\n      });\n\n      (async function () {\n        var enc,\n            sec = await user.get('trust').get(pair.pub).get(path).then();\n        sec = await SEA.decrypt(sec, pair);\n\n        if (!sec) {\n          sec = SEA.random(16).toString();\n          enc = await SEA.encrypt(sec, pair);\n          user.get('trust').get(pair.pub).get(path).put(enc);\n        }\n\n        enc = await SEA.encrypt(data, sec);\n        gun.put(enc, cb);\n      })();\n\n      return gun;\n    };\n    /**\n     * returns the decrypted value, encrypted by secret\n     * @returns {Promise<any>}\n     // Mark needs to review 1st before officially supported\n    User.prototype.decrypt = function(cb) {\n      let gun = this,\n        path = ''\n      gun.back(function(at) {\n        if (at.is) {\n          return\n        }\n        path += at.get || ''\n      })\n      return gun\n        .then(async data => {\n          if (data == null) {\n            return\n          }\n          const user = gun.back(-1).user()\n          const pair = user.pair()\n          let sec = await user\n            .get('trust')\n            .get(pair.pub)\n            .get(path)\n          sec = await SEA.decrypt(sec, pair)\n          if (!sec) {\n            return data\n          }\n          let decrypted = await SEA.decrypt(data, sec)\n          return decrypted\n        })\n        .then(res => {\n          cb && cb(res)\n          return res\n        })\n    }\n    */\n\n\n    module.exports = User;\n  })(USE, './create');\n  ;\n  USE(function (module) {\n    var SEA = USE('./sea');\n    var S = USE('./settings');\n    var Gun = SEA.Gun; // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\n\n    Gun.on('opt', function (at) {\n      if (!at.sea) {\n        // only add SEA once per instance, on the \"at\" context.\n        at.sea = {\n          own: {}\n        }; //at.on('in', security, at); // now listen to all input data, acting as a firewall.\n        //at.on('out', signature, at); // and output listeners, to encrypt outgoing data.\n\n        at.on('put', check, at);\n      }\n\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\n    }); // Alright, this next adapter gets run at the per node level in the graph database.\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\n\n    function each(msg) {\n      // TODO: Warning: Need to switch to `gun.on('node')`! Do not use `Gun.on('node'` in your apps!\n      // NOTE: THE SECURITY FUNCTION HAS ALREADY VERIFIED THE DATA!!!\n      // WE DO NOT NEED TO RE-VERIFY AGAIN, JUST TRANSFORM IT TO PLAINTEXT.\n      var to = this.to,\n          vertex = msg.$._.put,\n          c = 0,\n          d;\n      Gun.node.is(msg.put, function (val, key, node) {\n        // only process if SEA formatted?\n        var tmp = Gun.obj.ify(val) || noop;\n\n        if (u !== tmp[':']) {\n          node[key] = SEA.opt.unpack(tmp);\n          return;\n        }\n\n        if (!SEA.opt.check(val)) {\n          return;\n        }\n\n        c++; // for each property on the node\n\n        SEA.verify(val, false, function (data) {\n          c--; // false just extracts the plain data.\n\n          node[key] = SEA.opt.unpack(data, key, node);\n          ; // transform to plain value.\n\n          if (d && !c && (c = -1)) {\n            to.next(msg);\n          }\n        });\n      });\n\n      if ((d = true) && !c) {\n        to.next(msg);\n      }\n    } // signature handles data output, it is a proxy to the security function.\n\n\n    function signature(msg) {\n      if ((msg._ || noop).user) {\n        return this.to.next(msg);\n      }\n\n      var ctx = this.as;\n      (msg._ || (msg._ = function () {})).user = ctx.user;\n      security.call(this, msg);\n    }\n\n    var u;\n\n    function check(msg) {\n      // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\n      var eve = this,\n          at = eve.as,\n          put = msg.put,\n          soul = put['#'],\n          key = put['.'],\n          val = put[':'],\n          state = put['>'],\n          id = msg['#'],\n          tmp;\n\n      if (!soul || !key) {\n        return;\n      }\n\n      if ((msg._ || '').faith && (at.opt || '').faith && 'function' == typeof msg._) {\n        SEA.verify(SEA.opt.pack(put), false, function (data) {\n          // this is synchronous if false\n          put['='] = SEA.opt.unpack(data);\n          eve.to.next(msg);\n        });\n        return;\n      }\n\n      var no = function (why) {\n        at.on('in', {\n          '@': id,\n          err: why\n        });\n      }; //var no = function(why){ msg.ack(why) };\n\n\n      (msg._ || '').DBG && ((msg._ || '').DBG.c = +new Date());\n\n      if (0 <= soul.indexOf('<?')) {\n        // special case for \"do not sync data X old\"\n        // 'a~pub.key/b<?9'\n        tmp = parseFloat(soul.split('<?')[1] || '');\n\n        if (tmp && state < Gun.state() - tmp * 1000) {\n          // sec to ms\n          (tmp = msg._) && (tmp = tmp.lot) && tmp.more--; // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\n\n          return; // omit!\n        }\n      }\n\n      if ('~@' === soul) {\n        // special case for shared system data, the list of aliases.\n        check.alias(eve, msg, val, key, soul, at, no);\n        return;\n      }\n\n      if ('~@' === soul.slice(0, 2)) {\n        // special case for shared system data, the list of public keys for an alias.\n        check.pubs(eve, msg, val, key, soul, at, no);\n        return;\n      } //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n\n\n      if (tmp = SEA.opt.pub(soul)) {\n        // special case, account data for a public key.\n        check.pub(eve, msg, val, key, soul, at, no, at.user || '', tmp);\n        return;\n      }\n\n      if (0 <= soul.indexOf('#')) {\n        // special case for content addressing immutable hashed data.\n        check.hash(eve, msg, val, key, soul, at, no);\n        return;\n      }\n\n      check.any(eve, msg, val, key, soul, at, no, at.user || '');\n      return;\n      eve.to.next(msg); // not handled\n    }\n\n    check.hash = function (eve, msg, val, key, soul, at, no) {\n      SEA.work(val, null, function (data) {\n        if (data && data === key.split('#').slice(-1)[0]) {\n          return eve.to.next(msg);\n        }\n\n        no(\"Data hash not same as hash!\");\n      }, {\n        name: 'SHA-256'\n      });\n    };\n\n    check.alias = function (eve, msg, val, key, soul, at, no) {\n      // Example: {_:#~@, ~@alice: {#~@alice}}\n      if (!val) {\n        return no(\"Data must exist!\");\n      } // data MUST exist\n\n\n      if ('~@' + key === link_is(val)) {\n        return eve.to.next(msg);\n      } // in fact, it must be EXACTLY equal to itself\n\n\n      no(\"Alias not same!\"); // if it isn't, reject.\n    };\n\n    check.pubs = function (eve, msg, val, key, soul, at, no) {\n      // Example: {_:#~@alice, ~asdf: {#~asdf}}\n      if (!val) {\n        return no(\"Alias must exist!\");\n      } // data MUST exist\n\n\n      if (key === link_is(val)) {\n        return eve.to.next(msg);\n      } // and the ID must be EXACTLY equal to its property\n\n\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\n    };\n\n    check.pub = function (eve, msg, val, key, soul, at, no, user, pub) {\n      var tmp; // Example: {_:#~asdf, hello:'world'~fdsa}}\n\n      const raw = S.parse(val) || {};\n\n      const verify = (certificate, certificant, cb) => {\n        if (certificate.m && certificate.s && certificant && pub) // now verify certificate\n          return SEA.verify(certificate, pub, data => {\n            // check if \"pub\" (of the graph owner) really issued this cert\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\"); // certificate expired\n            // \"data.c\" = a list of certificants/certified users\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\n\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : '';\n              String.match = String.match || Gun.text.match;\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : [];\n\n              for (const lex of w) {\n                if (String.match(path, lex['#']) && String.match(key, lex['.']) || !lex['.'] && String.match(path, lex['#']) || !lex['#'] && String.match(key, lex['.']) || String.match(path ? path + '/' + key : key, lex['#'] || lex)) {\n                  // is Certificant forced to present in Path\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`); // path is allowed, but is there any WRITE blacklist? Check it out\n\n                  if (data.wb && (typeof data.wb === 'string' || (data.wb || {})['#'])) {\n                    // \"data.wb\" = path to the WRITE blacklist\n                    var root = at.$.back(-1);\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub);\n                    return root.get(data.wb).get(certificant).once(value => {\n                      if (value && (value === 1 || value === true)) return no(\"Certificant blacklisted.\");\n                      return cb(data);\n                    });\n                  }\n\n                  return cb(data);\n                }\n              }\n\n              return no(\"Certificate verification fail.\");\n            }\n          });\n        return;\n      };\n\n      if ('pub' === key && '~' + pub === soul) {\n        if (val === pub) return eve.to.next(msg); // the account MUST match `pub` property that equals the ID of the public key.\n\n        return no(\"Account not same!\");\n      }\n\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || pub !== tmp.pub && ((msg._.out || {}).opt || {}).cert)) {\n        SEA.sign(SEA.opt.pack(msg.put), user._.sea, function (data) {\n          if (u === data) return no(SEA.err || 'Signature fail.');\n          msg.put[':'] = {\n            ':': tmp = SEA.opt.unpack(data.m),\n            '~': data.s\n          };\n          msg.put['='] = tmp; // if writing to own graph, just allow it\n\n          if (pub === user.is.pub) {\n            if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1;\n            msg.put[':'] = JSON.stringify(msg.put[':']);\n            return eve.to.next(msg);\n          } // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\n\n\n          if (pub !== user.is.pub && ((msg._.out || {}).opt || {}).cert) {\n            const cert = S.parse(msg._.out.opt.cert); // even if cert exists, we must verify it\n\n            if (cert && cert.m && cert.s) verify(cert, user.is.pub, _ => {\n              msg.put[':']['+'] = cert; // '+' is a certificate\n\n              msg.put[':']['*'] = user.is.pub; // '*' is pub of the user who puts\n\n              msg.put[':'] = JSON.stringify(msg.put[':']);\n              return eve.to.next(msg);\n            });\n          }\n        }, {\n          raw: 1\n        });\n        return;\n      }\n\n      SEA.verify(SEA.opt.pack(msg.put), raw['*'] || pub, function (data) {\n        var tmp;\n        data = SEA.opt.unpack(data);\n        if (u === data) return no(\"Unverified data.\"); // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\n\n        if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1; // check if cert ('+') and putter's pub ('*') exist\n\n        if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*']) // now verify certificate\n          verify(raw['+'], raw['*'], _ => {\n            msg.put['='] = data;\n            return eve.to.next(msg);\n          });else {\n          msg.put['='] = data;\n          return eve.to.next(msg);\n        }\n      });\n    };\n\n    check.any = function (eve, msg, val, key, soul, at, no, user) {\n      var tmp, pub;\n\n      if (at.opt.secure) {\n        return no(\"Soul missing public key at '\" + key + \"'.\");\n      } // TODO: Ask community if should auto-sign non user-graph data.\n\n\n      at.on('secure', function (msg) {\n        this.off();\n\n        if (!at.opt.secure) {\n          return eve.to.next(msg);\n        }\n\n        no(\"Data cannot be changed.\");\n      }).on.on('secure', msg);\n      return;\n    };\n\n    var link_is = Gun.val.link.is,\n        state_ify = Gun.state.ify; // okay! The security function handles all the heavy lifting.\n    // It needs to deal read and write of input and output of system data, account/public key data, and regular data.\n    // This is broken down into some pretty clear edge cases, let's go over them:\n\n    function security(msg) {\n      var at = this.as,\n          sea = at.sea,\n          to = this.to;\n\n      if (at.opt.faith && (msg._ || noop).faith) {\n        // you probably shouldn't have faith in this!\n        this.to.next(msg); // why do we allow skipping security? I'm very scared about it actually.\n\n        return; // but so that way storage adapters that already verified something can get performance boost. This was a community requested feature. If anybody finds an exploit with it, please report immediately. It should only be exploitable if you have XSS control anyways, which if you do, you can bypass security regardless of this.\n      }\n\n      if (msg.get) {\n        // if there is a request to read data from us, then...\n        var soul = msg.get['#'];\n\n        if (soul) {\n          // for now, only allow direct IDs to be read.\n          if (typeof soul !== 'string') {\n            return to.next(msg);\n          } // do not handle lexical cursors.\n\n\n          if ('alias' === soul) {\n            // Allow reading the list of usernames/aliases in the system?\n            return to.next(msg); // yes.\n          } else if ('~@' === soul.slice(0, 2)) {\n            // Allow reading the list of public keys associated with an alias?\n            return to.next(msg); // yes.\n          } else {\n            // Allow reading everything?\n            return to.next(msg); // yes // TODO: No! Make this a callback/event that people can filter on.\n          }\n        }\n      }\n\n      if (msg.put) {\n        /*\n          NOTICE: THIS IS OLD AND GETTING DEPRECATED.\n          ANY SECURITY CHANGES SHOULD HAPPEN ABOVE FIRST\n          THEN PORTED TO HERE.\n        */\n        // potentially parallel async operations!!!\n        var check = {},\n            each = {},\n            u;\n\n        each.node = function (node, soul) {\n          if (Gun.obj.empty(node, '_')) {\n            return check['node' + soul] = 0;\n          } // ignore empty updates, don't reject them.\n\n\n          Gun.obj.map(node, each.way, {\n            soul: soul,\n            node: node\n          });\n        };\n\n        each.way = function (val, key) {\n          var soul = this.soul,\n              node = this.node,\n              tmp;\n\n          if ('_' === key) {\n            return;\n          } // ignore meta data\n\n\n          if ('~@' === soul) {\n            // special case for shared system data, the list of aliases.\n            each.alias(val, key, node, soul);\n            return;\n          }\n\n          if ('~@' === soul.slice(0, 2)) {\n            // special case for shared system data, the list of public keys for an alias.\n            each.pubs(val, key, node, soul);\n            return;\n          }\n\n          if ('~' === soul.slice(0, 1) && 2 === (tmp = soul.slice(1)).split('.').length) {\n            // special case, account data for a public key.\n            each.pub(val, key, node, soul, tmp, (msg._ || noop).user);\n            return;\n          }\n\n          each.any(val, key, node, soul, (msg._ || noop).user);\n          return;\n          return each.end({\n            err: \"No other data allowed!\"\n          });\n        };\n\n        each.alias = function (val, key, node, soul) {\n          // Example: {_:#~@, ~@alice: {#~@alice}}\n          if (!val) {\n            return each.end({\n              err: \"Data must exist!\"\n            });\n          } // data MUST exist\n\n\n          if ('~@' + key === Gun.val.link.is(val)) {\n            return check['alias' + key] = 0;\n          } // in fact, it must be EXACTLY equal to itself\n\n\n          each.end({\n            err: \"Mismatching alias.\"\n          }); // if it isn't, reject.\n        };\n\n        each.pubs = function (val, key, node, soul) {\n          // Example: {_:#~@alice, ~asdf: {#~asdf}}\n          if (!val) {\n            return each.end({\n              err: \"Alias must exist!\"\n            });\n          } // data MUST exist\n\n\n          if (key === Gun.val.link.is(val)) {\n            return check['pubs' + soul + key] = 0;\n          } // and the ID must be EXACTLY equal to its property\n\n\n          each.end({\n            err: \"Alias must match!\"\n          }); // that way nobody can tamper with the list of public keys.\n        };\n\n        each.pub = function (val, key, node, soul, pub, user) {\n          var tmp; // Example: {_:#~asdf, hello:'world'~fdsa}}\n\n          if ('pub' === key) {\n            if (val === pub) {\n              return check['pub' + soul + key] = 0;\n            } // the account MUST match `pub` property that equals the ID of the public key.\n\n\n            return each.end({\n              err: \"Account must match!\"\n            });\n          }\n\n          check['user' + soul + key] = 1;\n\n          if (Gun.is(msg.$) && user && user.is && pub === user.is.pub) {\n            SEA.sign(SEA.opt.prep(tmp = SEA.opt.parse(val), key, node, soul), user._.sea, function (data) {\n              var rel;\n\n              if (u === data) {\n                return each.end({\n                  err: SEA.err || 'Pub signature fail.'\n                });\n              }\n\n              if (rel = Gun.val.link.is(val)) {\n                (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n              }\n\n              node[key] = JSON.stringify({\n                ':': SEA.opt.unpack(data.m),\n                '~': data.s\n              });\n              check['user' + soul + key] = 0;\n              each.end({\n                ok: 1\n              });\n            }, {\n              check: SEA.opt.pack(tmp, key, node, soul),\n              raw: 1\n            });\n            return;\n          }\n\n          SEA.verify(SEA.opt.pack(val, key, node, soul), pub, function (data) {\n            var rel, tmp;\n            data = SEA.opt.unpack(data, key, node);\n\n            if (u === data) {\n              // make sure the signature matches the account it claims to be on.\n              return each.end({\n                err: \"Unverified data.\"\n              }); // reject any updates that are signed with a mismatched account.\n            }\n\n            if ((rel = Gun.val.link.is(data)) && pub === SEA.opt.pub(rel)) {\n              (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n            }\n\n            check['user' + soul + key] = 0;\n            each.end({\n              ok: 1\n            });\n          });\n        };\n\n        each.any = function (val, key, node, soul, user) {\n          var tmp, pub;\n\n          if (!(pub = SEA.opt.pub(soul))) {\n            if (at.opt.secure) {\n              each.end({\n                err: \"Soul is missing public key at '\" + key + \"'.\"\n              });\n              return;\n            } // TODO: Ask community if should auto-sign non user-graph data.\n\n\n            check['any' + soul + key] = 1;\n            at.on('secure', function (msg) {\n              this.off();\n              check['any' + soul + key] = 0;\n\n              if (at.opt.secure) {\n                msg = null;\n              }\n\n              each.end(msg || {\n                err: \"Data cannot be modified.\"\n              });\n            }).on.on('secure', msg); //each.end({err: \"Data cannot be modified.\"});\n\n            return;\n          }\n\n          if (Gun.is(msg.$) && user && user.is && pub === user.is.pub) {\n            /*var other = Gun.obj.map(at.sea.own[soul], function(v, p){\n              if((user.is||{}).pub !== p){ return p }\n            });\n            if(other){\n              each.any(val, key, node, soul);\n              return;\n            }*/\n            check['any' + soul + key] = 1;\n            SEA.sign(SEA.opt.prep(tmp = SEA.opt.parse(val), key, node, soul), user._.sea, function (data) {\n              if (u === data) {\n                return each.end({\n                  err: 'My signature fail.'\n                });\n              }\n\n              node[key] = JSON.stringify({\n                ':': SEA.opt.unpack(data.m),\n                '~': data.s\n              });\n              check['any' + soul + key] = 0;\n              each.end({\n                ok: 1\n              });\n            }, {\n              check: SEA.opt.pack(tmp, key, node, soul),\n              raw: 1\n            });\n            return;\n          }\n\n          check['any' + soul + key] = 1;\n          SEA.verify(SEA.opt.pack(val, key, node, soul), pub, function (data) {\n            var rel;\n            data = SEA.opt.unpack(data, key, node);\n\n            if (u === data) {\n              return each.end({\n                err: \"Mismatched owner on '\" + key + \"'.\"\n              });\n            } // thanks @rogowski !\n\n\n            if ((rel = Gun.val.link.is(data)) && pub === SEA.opt.pub(rel)) {\n              (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n            }\n\n            check['any' + soul + key] = 0;\n            each.end({\n              ok: 1\n            });\n          });\n        };\n\n        each.end = function (ctx) {\n          // TODO: Can't you just switch this to each.end = cb?\n          if (each.err) {\n            return;\n          }\n\n          if ((each.err = ctx.err) || ctx.no) {\n            console.log('NO!', each.err, msg.put); // 451 mistmached data FOR MARTTI\n\n            return;\n          }\n\n          if (!each.end.ed) {\n            return;\n          }\n\n          if (Gun.obj.map(check, function (no) {\n            if (no) {\n              return true;\n            }\n          })) {\n            return;\n          }\n\n          (msg._ || {}).user = at.user || security; // already been through firewall, does not need to again on out.\n\n          to.next(msg);\n        };\n\n        Gun.obj.map(msg.put, each.node);\n        each.end({\n          end: each.end.ed = true\n        });\n        return; // need to manually call next after async.\n      }\n\n      to.next(msg); // pass forward any data we do not know how to handle or process (this allows custom security protocols).\n    }\n\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\n\n    SEA.opt.pub = function (s) {\n      if (!s) {\n        return;\n      }\n\n      s = s.split('~');\n\n      if (!s || !(s = s[1])) {\n        return;\n      }\n\n      s = s.split(pubcut).slice(0, 2);\n\n      if (!s || 2 != s.length) {\n        return;\n      }\n\n      if ('@' === (s[0] || '')[0]) {\n        return;\n      }\n\n      s = s.slice(0, 2).join('.');\n      return s;\n    };\n\n    SEA.opt.prep = function (d, k, n, s) {\n      // prep for signing\n      return {\n        '#': s,\n        '.': k,\n        ':': SEA.opt.parse(d),\n        '>': Gun.state.is(n, k)\n      };\n    };\n\n    SEA.opt.pack = function (d, k, n, s) {\n      // pack for verifying\n      if (SEA.opt.check(d)) {\n        return d;\n      }\n\n      var meta = Gun.obj.ify(d && d[':'] || d) || '',\n          sig = meta['~'];\n      return sig ? {\n        m: {\n          '#': s || d['#'],\n          '.': k || d['.'],\n          ':': meta[':'],\n          '>': d['>'] || Gun.state.is(n, k)\n        },\n        s: sig\n      } : d;\n    };\n\n    var O = SEA.opt;\n\n    SEA.opt.unpack = function (d, k, n) {\n      var tmp;\n\n      if (u === d) {\n        return;\n      }\n\n      if (d && u !== (tmp = d[':'])) {\n        return tmp;\n      }\n\n      k = k || O.fall_key;\n\n      if (!n && O.fall_val) {\n        n = {};\n        n[k] = O.fall_val;\n      }\n\n      if (!k || !n) {\n        return;\n      }\n\n      if (d === n[k]) {\n        return d;\n      }\n\n      if (!SEA.opt.check(n[k])) {\n        return d;\n      }\n\n      var soul = Gun.node.soul(n) || O.fall_soul,\n          s = Gun.state.is(n, k) || O.fall_state;\n\n      if (d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])) {\n        return d[2];\n      }\n\n      if (s < SEA.opt.shuffle_attack) {\n        return d;\n      }\n    };\n\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\n\n    var noop = function () {},\n        u;\n\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\n\n    var rel_is = Gun.val.rel.is;\n    var obj_ify = Gun.obj.ify; // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\n  })(USE, './index');\n})();","map":{"version":3,"sources":["C:/Users/chena/reactgun/my-app/node_modules/gun/sea.js"],"names":["USE","arg","req","require","slice","R","mod","path","exports","p","split","toString","replace","module","MODULE","window","tmp","SEA","e","location","protocol","indexOf","host","test","hostname","console","warn","btoa","Buffer","global","data","from","atob","SeaArray","Object","assign","Array","prototype","create","enc","start","end","length","buf","Uint8Array","keys","map","i","padStart","join","_","String","fromCharCode","SafeBuffer","props","arguments","TypeError","input","bytes","match","byte","parseInt","words","Uint16Array","charCodeAt","dec","info","byteLength","ArrayBuffer","alloc","fill","allocUnsafe","concat","arr","isArray","reduce","ret","item","api","o","crypto","msCrypto","subtle","webkitSubtle","TextEncoder","TextDecoder","random","len","getRandomValues","randomBytes","Crypto","WebCrypto","ossl","directory","log","s","pbkdf2","hash","name","iter","ks","ecdsa","pair","namedCurve","sign","ecdh","jwk","pub","d","x","y","kty","crv","ext","key_ops","keyToJwk","keyBytes","keyB64","k","alg","recall","validity","hook","check","t","parse","yes","JSON","opt","shim","stringify","digest","encode","__shim","sha1hash","b","S","sha","u","work","cb","salt","epub","Function","toLowerCase","rsha","key","importKey","deriveBits","iterations","r","err","throw","ecdhSubtle","sa","generateKey","then","priv","exportKey","privateKey","publicKey","dh","epriv","I","what","how","why","json","verify","m","raw","sig","slow_leak","fallback","fall_verify","knownKeys","keyForPair","O","f","unpack","fall_soul","fall_key","fall_val","fall_state","sha256hash","importGen","combo","jwkKey","aeskey","encrypt","msg","rand","iv","ct","aes","decrypt","bufiv","bufct","tagLength","decode","secret","pubKeyData","keysToEcdhJwk","public","privKeyData","derived","privKey","derivedBits","rawBits","derivedKey","certify","certificants","policy","authority","certificant","push","expiry","parseFloat","readPolicy","read","writePolicy","write","readBlacklist","blacklist","writeBlacklist","c","w","rb","wb","certificate","keyid","pb","id","sha1","Gun","GUN","chain","gun","Promise","res","rej","once","User","root","$","F","constructor","user","back","get","at","uuid","state","lex","is","call","authsettings","noop","args","alias","pass","filter","cat","ing","wait","act","a","pubs","already","ack","leave","text","proof","sea","auth","ek","g","put","obj","val","link","ify","h","ok","node","v","list","shift","half","tag","upt","has","graph","shuffle","change","z","remember","sS","sessionStorage","on","to","del","plugin","delete","alive","gunRoot","authRecall","trust","ctx","ev","theirPubkey","grant","sec","own","next","each","vertex","signature","as","security","eve","soul","faith","pack","no","DBG","Date","lot","more","any","link_is","substring","value","out","cert","secure","off","state_ify","empty","way","prep","rel","ed","pubcut","n","meta","fl","shuffle_attack","Math","floor","rel_is","obj_ify"],"mappings":"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","sourcesContent":[";(function(){\n\n  /* UNBUILD */\n  function USE(arg, req){\n    return req? require(arg) : arg.slice? USE[R(arg)] : function(mod, path){\n      arg(mod = {exports: {}});\n      USE[R(path)] = mod.exports;\n    }\n    function R(p){\n      return p.split('/').slice(-1).toString().replace('.js','');\n    }\n  }\n  if(typeof module !== \"undefined\"){ var MODULE = module }\n  /* UNBUILD */\n\n  ;USE(function(module){\n    // Security, Encryption, and Authorization: SEA.js\n    // MANDATORY READING: https://gun.eco/explainers/data/security.html\n    // IT IS IMPLEMENTED IN A POLYFILL/SHIM APPROACH.\n    // THIS IS AN EARLY ALPHA!\n\n    if(typeof window !== \"undefined\"){ module.window = window }\n\n    var tmp = module.window || module;\n    var SEA = tmp.SEA || {};\n\n    if(SEA.window = module.window){ SEA.window.SEA = SEA }\n\n    try{ if(typeof MODULE !== \"undefined\"){ MODULE.exports = SEA } }catch(e){}\n    module.exports = SEA;\n  })(USE, './root');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    try{ if(SEA.window){\n      if(location.protocol.indexOf('s') < 0\n      && location.host.indexOf('localhost') < 0\n      && ! /^127\\.\\d+\\.\\d+\\.\\d+$/.test(location.hostname)\n      && location.protocol.indexOf('file:') < 0){\n        console.warn('WebCrypto used by GUN SEA implementation does not work without HTTPS. Will automatically redirect.')\n        location.protocol = 'https:'; // WebCrypto does NOT work without HTTPS!\n      }\n    } }catch(e){}\n  })(USE, './https');\n\n  ;USE(function(module){\n    if(typeof btoa === \"undefined\"){\n      if(typeof Buffer === \"undefined\") {\n        global.Buffer = require(\"buffer\").Buffer\n      }\n      global.btoa = function (data) { return Buffer.from(data, \"binary\").toString(\"base64\"); };\n      global.atob = function (data) { return Buffer.from(data, \"base64\").toString(\"binary\"); };\n    }\n  })(USE, './base64');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Array extended to have .toString(['utf8'|'hex'|'base64'])\n    function SeaArray() {}\n    Object.assign(SeaArray, { from: Array.from })\n    SeaArray.prototype = Object.create(Array.prototype)\n    SeaArray.prototype.toString = function(enc, start, end) { enc = enc || 'utf8'; start = start || 0;\n      const length = this.length\n      if (enc === 'hex') {\n        const buf = new Uint8Array(this)\n        return [ ...Array(((end && (end + 1)) || length) - start).keys()]\n        .map((i) => buf[ i + start ].toString(16).padStart(2, '0')).join('')\n      }\n      if (enc === 'utf8') {\n        return Array.from(\n          { length: (end || length) - start },\n          (_, i) => String.fromCharCode(this[ i + start])\n        ).join('')\n      }\n      if (enc === 'base64') {\n        return btoa(this)\n      }\n    }\n    module.exports = SeaArray;\n  })(USE, './array');\n\n  ;USE(function(module){\n    USE('./base64');\n    // This is Buffer implementation used in SEA. Functionality is mostly\n    // compatible with NodeJS 'safe-buffer' and is used for encoding conversions\n    // between binary and 'hex' | 'utf8' | 'base64'\n    // See documentation and validation for safe implementation in:\n    // https://github.com/feross/safe-buffer#update\n    var SeaArray = USE('./array');\n    function SafeBuffer(...props) {\n      console.warn('new SafeBuffer() is depreciated, please use SafeBuffer.from()')\n      return SafeBuffer.from(...props)\n    }\n    SafeBuffer.prototype = Object.create(Array.prototype)\n    Object.assign(SafeBuffer, {\n      // (data, enc) where typeof data === 'string' then enc === 'utf8'|'hex'|'base64'\n      from() {\n        if (!Object.keys(arguments).length || arguments[0]==null) {\n          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n        }\n        const input = arguments[0]\n        let buf\n        if (typeof input === 'string') {\n          const enc = arguments[1] || 'utf8'\n          if (enc === 'hex') {\n            const bytes = input.match(/([\\da-fA-F]{2})/g)\n            .map((byte) => parseInt(byte, 16))\n            if (!bytes || !bytes.length) {\n              throw new TypeError('Invalid first argument for type \\'hex\\'.')\n            }\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'utf8') {\n            const length = input.length\n            const words = new Uint16Array(length)\n            Array.from({ length: length }, (_, i) => words[i] = input.charCodeAt(i))\n            buf = SeaArray.from(words)\n          } else if (enc === 'base64') {\n            const dec = atob(input)\n            const length = dec.length\n            const bytes = new Uint8Array(length)\n            Array.from({ length: length }, (_, i) => bytes[i] = dec.charCodeAt(i))\n            buf = SeaArray.from(bytes)\n          } else if (enc === 'binary') {\n            buf = SeaArray.from(input)\n          } else {\n            console.info('SafeBuffer.from unknown encoding: '+enc)\n          }\n          return buf\n        }\n        const byteLength = input.byteLength // what is going on here? FOR MARTTI\n        const length = input.byteLength ? input.byteLength : input.length\n        if (length) {\n          let buf\n          if (input instanceof ArrayBuffer) {\n            buf = new Uint8Array(input)\n          }\n          return SeaArray.from(buf || input)\n        }\n      },\n      // This is 'safe-buffer.alloc' sans encoding support\n      alloc(length, fill = 0 /*, enc*/ ) {\n        return SeaArray.from(new Uint8Array(Array.from({ length: length }, () => fill)))\n      },\n      // This is normal UNSAFE 'buffer.alloc' or 'new Buffer(length)' - don't use!\n      allocUnsafe(length) {\n        return SeaArray.from(new Uint8Array(Array.from({ length : length })))\n      },\n      // This puts together array of array like members\n      concat(arr) { // octet array\n        if (!Array.isArray(arr)) {\n          throw new TypeError('First argument must be Array containing ArrayBuffer or Uint8Array instances.')\n        }\n        return SeaArray.from(arr.reduce((ret, item) => ret.concat(Array.from(item)), []))\n      }\n    })\n    SafeBuffer.prototype.from = SafeBuffer.from\n    SafeBuffer.prototype.toString = SeaArray.prototype.toString\n\n    module.exports = SafeBuffer;\n  })(USE, './buffer');\n\n  ;USE(function(module){\n    const SEA = USE('./root')\n    const Buffer = USE('./buffer')\n    const api = {Buffer: Buffer}\n    var o = {};\n\n    if(SEA.window){\n      api.crypto = window.crypto || window.msCrypto\n      api.subtle = (api.crypto||o).subtle || (api.crypto||o).webkitSubtle;\n      api.TextEncoder = window.TextEncoder;\n      api.TextDecoder = window.TextDecoder;\n      api.random = (len) => Buffer.from(api.crypto.getRandomValues(new Uint8Array(Buffer.alloc(len))));\n    }\n    if(!api.TextDecoder)\n    {\n      const { TextEncoder, TextDecoder } = require('text-encoding');\n      api.TextDecoder = TextDecoder;\n      api.TextEncoder = TextEncoder;\n    }\n    if(!api.crypto)\n    {\n      try\n      {\n      var crypto = USE('crypto', 1);\n      Object.assign(api, {\n        crypto,\n        random: (len) => Buffer.from(crypto.randomBytes(len))\n      });      \n      const { Crypto: WebCrypto } = USE('@peculiar/webcrypto', 1);\n      api.ossl = api.subtle = new WebCrypto({directory: 'ossl'}).subtle // ECDH\n    }\n    catch(e){\n      console.log(\"text-encoding and @peculiar/webcrypto may not be included by default, please add it to your package.json!\");\n    }}\n\n    module.exports = api\n  })(USE, './shim');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var Buffer = USE('./buffer');\n    var s = {};\n    s.pbkdf2 = {hash: {name : 'SHA-256'}, iter: 100000, ks: 64};\n    s.ecdsa = {\n      pair: {name: 'ECDSA', namedCurve: 'P-256'},\n      sign: {name: 'ECDSA', hash: {name: 'SHA-256'}}\n    };\n    s.ecdh = {name: 'ECDH', namedCurve: 'P-256'};\n\n    // This creates Web Cryptography API compliant JWK for sign/verify purposes\n    s.jwk = function(pub, d){  // d === priv\n      pub = pub.split('.');\n      var x = pub[0], y = pub[1];\n      var jwk = {kty: \"EC\", crv: \"P-256\", x: x, y: y, ext: true};\n      jwk.key_ops = d ? ['sign'] : ['verify'];\n      if(d){ jwk.d = d }\n      return jwk;\n    };\n    \n    s.keyToJwk = function(keyBytes) {\n      const keyB64 = keyBytes.toString('base64');\n      const k = keyB64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/\\=/g, '');\n      return { kty: 'oct', k: k, ext: false, alg: 'A256GCM' };\n    }\n\n    s.recall = {\n      validity: 12 * 60 * 60, // internally in seconds : 12 hours\n      hook: function(props){ return props } // { iat, exp, alias, remember } // or return new Promise((resolve, reject) => resolve(props)\n    };\n\n    s.check = function(t){ return (typeof t == 'string') && ('SEA{' === t.slice(0,4)) }\n    s.parse = function p(t){ try {\n      var yes = (typeof t == 'string');\n      if(yes && 'SEA{' === t.slice(0,4)){ t = t.slice(3) }\n      return yes ? JSON.parse(t) : t;\n      } catch (e) {}\n      return t;\n    }\n\n    SEA.opt = s;\n    module.exports = s\n  })(USE, './settings');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    module.exports = async function(d, o){\n      var t = (typeof d == 'string')? d : JSON.stringify(d);\n      var hash = await shim.subtle.digest({name: o||'SHA-256'}, new shim.TextEncoder().encode(t));\n      return shim.Buffer.from(hash);\n    }\n  })(USE, './sha256');\n\n  ;USE(function(module){\n    // This internal func returns SHA-1 hashed data for KeyID generation\n    const __shim = USE('./shim')\n    const subtle = __shim.subtle\n    const ossl = __shim.ossl ? __shim.ossl : subtle\n    const sha1hash = (b) => ossl.digest({name: 'SHA-1'}, new ArrayBuffer(b))\n    module.exports = sha1hash\n  })(USE, './sha1');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.work = SEA.work || (async (data, pair, cb, opt) => { try { // used to be named `proof`\n      var salt = (pair||{}).epub || pair; // epub not recommended, salt should be random!\n      opt = opt || {};\n      if(salt instanceof Function){\n        cb = salt;\n        salt = u;\n      }\n      data = (typeof data == 'string')? data : JSON.stringify(data);\n      if('sha' === (opt.name||'').toLowerCase().slice(0,3)){\n        var rsha = shim.Buffer.from(await sha(data, opt.name), 'binary').toString(opt.encode || 'base64')\n        if(cb){ try{ cb(rsha) }catch(e){console.log(e)} }\n        return rsha;\n      }\n      salt = salt || shim.random(9);\n      var key = await (shim.ossl || shim.subtle).importKey('raw', new shim.TextEncoder().encode(data), {name: opt.name || 'PBKDF2'}, false, ['deriveBits']);\n      var work = await (shim.ossl || shim.subtle).deriveBits({\n        name: opt.name || 'PBKDF2',\n        iterations: opt.iterations || S.pbkdf2.iter,\n        salt: new shim.TextEncoder().encode(opt.salt || salt),\n        hash: opt.hash || S.pbkdf2.hash,\n      }, key, opt.length || (S.pbkdf2.ks * 8))\n      data = shim.random(data.length)  // Erase data in case of passphrase\n      var r = shim.Buffer.from(work, 'binary').toString(opt.encode || 'base64')\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.work;\n  })(USE, './work');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n\n    SEA.name = SEA.name || (async (cb, opt) => { try {\n      if(cb){ try{ cb() }catch(e){console.log(e)} }\n      return;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    //SEA.pair = async (data, proof, cb) => { try {\n    SEA.pair = SEA.pair || (async (cb, opt) => { try {\n\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      // First: ECDSA keys for signing/verifying...\n      var sa = await shim.subtle.generateKey({name: 'ECDSA', namedCurve: 'P-256'}, true, [ 'sign', 'verify' ])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        //const { d: priv } = await shim.subtle.exportKey('jwk', keys.privateKey)\n        var key = {};\n        key.priv = (await shim.subtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await shim.subtle.exportKey('jwk', keys.publicKey);\n        //const pub = Buff.from([ x, y ].join(':')).toString('base64') // old\n        key.pub = pub.x+'.'+pub.y; // new\n        // x and y are already base64\n        // pub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      \n      // To include PGPv4 kind of keyId:\n      // const pubId = await SEA.keyid(keys.pub)\n      // Next: ECDH keys for encryption/decryption...\n\n      try{\n      var dh = await ecdhSubtle.generateKey({name: 'ECDH', namedCurve: 'P-256'}, true, ['deriveKey'])\n      .then(async (keys) => {\n        // privateKey scope doesn't leak out from here!\n        var key = {};\n        key.epriv = (await ecdhSubtle.exportKey('jwk', keys.privateKey)).d;\n        var pub = await ecdhSubtle.exportKey('jwk', keys.publicKey);\n        //const epub = Buff.from([ ex, ey ].join(':')).toString('base64') // old\n        key.epub = pub.x+'.'+pub.y; // new\n        // ex and ey are already base64\n        // epub is UTF8 but filename/URL safe (https://www.ietf.org/rfc/rfc3986.txt)\n        // but split on a non-base64 letter.\n        return key;\n      })\n      }catch(e){\n        if(SEA.window){ throw e }\n        if(e == 'Error: ECDH is not a supported algorithm'){ console.log('Ignoring ECDH...') }\n        else { throw e }\n      } dh = dh || {};\n\n      var r = { pub: sa.pub, priv: sa.priv, /* pubId, */ epub: dh.epub, epriv: dh.epriv }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.pair;\n  })(USE, './pair');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.sign = SEA.sign || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!(pair||opt).priv){\n        pair = await SEA.I(null, {what: data, how: 'sign', why: opt.why});\n      }\n      if(u === data){ throw '`undefined` not allowed.' }\n      var json = S.parse(data);\n      var check = opt.check = opt.check || json;\n      if(SEA.verify && (SEA.opt.check(check) || (check && check.s && check.m))\n      && u !== await SEA.verify(check, pair)){ // don't sign if we already signed it.\n        var r = S.parse(check);\n        if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n        if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n        return r;\n      }\n      var pub = pair.pub;\n      var priv = pair.priv;\n      var jwk = S.jwk(pub, priv);\n      var hash = await sha(json);\n      var sig = await (shim.ossl || shim.subtle).importKey('jwk', jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, ['sign'])\n      .then((key) => (shim.ossl || shim.subtle).sign({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, new Uint8Array(hash))) // privateKey scope doesn't leak out from here!\n      var r = {m: json, s: shim.Buffer.from(sig, 'binary').toString(opt.encode || 'base64')}\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.sign;\n  })(USE, './sign');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha = USE('./sha256');\n    var u;\n\n    SEA.verify = SEA.verify || (async (data, pair, cb, opt) => { try {\n      var json = S.parse(data);\n      if(false === pair){ // don't verify!\n        var raw = S.parse(json.m);\n        if(cb){ try{ cb(raw) }catch(e){console.log(e)} }\n        return raw;\n      }\n      opt = opt || {};\n      // SEA.I // verify is free! Requires no user permission.\n      var pub = pair.pub || pair;\n      var key = SEA.opt.slow_leak? await SEA.opt.slow_leak(pub) : await (shim.ossl || shim.subtle).importKey('jwk', S.jwk(pub), {name: 'ECDSA', namedCurve: 'P-256'}, false, ['verify']);\n      var hash = await sha(json.m);\n      var buf, sig, check, tmp; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64'); // NEW DEFAULT!\n        sig = new Uint8Array(buf);\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash));\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){\n        if(SEA.opt.fallback){\n          return await SEA.opt.fall_verify(data, pair, cb, opt);\n        }\n      }\n      var r = check? S.parse(json.m) : u;\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e); // mismatched owner FOR MARTTI\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.verify;\n    // legacy & ossl leak mitigation:\n\n    var knownKeys = {};\n    var keyForPair = SEA.opt.slow_leak = pair => {\n      if (knownKeys[pair]) return knownKeys[pair];\n      var jwk = S.jwk(pair);\n      knownKeys[pair] = (shim.ossl || shim.subtle).importKey(\"jwk\", jwk, {name: 'ECDSA', namedCurve: 'P-256'}, false, [\"verify\"]);\n      return knownKeys[pair];\n    };\n\n    var O = SEA.opt;\n    SEA.opt.fall_verify = async function(data, pair, cb, opt, f){\n      if(f === SEA.opt.fallback){ throw \"Signature did not match\" } f = f || 1;\n      var tmp = data||'';\n      data = SEA.opt.unpack(data) || data;\n      var json = S.parse(data), pub = pair.pub || pair, key = await SEA.opt.slow_leak(pub);\n      var hash = (f <= SEA.opt.fallback)? shim.Buffer.from(await shim.subtle.digest({name: 'SHA-256'}, new shim.TextEncoder().encode(S.parse(json.m)))) : await sha(json.m); // this line is old bad buggy code but necessary for old compatibility.\n      var buf; var sig; var check; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64') // NEW DEFAULT!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        if(!check){ throw \"Signature did not match.\" }\n      }catch(e){\n        buf = shim.Buffer.from(json.s, 'utf8') // AUTO BACKWARD OLD UTF8 DATA!\n        sig = new Uint8Array(buf)\n        check = await (shim.ossl || shim.subtle).verify({name: 'ECDSA', hash: {name: 'SHA-256'}}, key, sig, new Uint8Array(hash))\n        if(!check){ throw \"Signature did not match.\" }\n      }\n      var r = check? S.parse(json.m) : u;\n      O.fall_soul = tmp['#']; O.fall_key = tmp['.']; O.fall_val = data; O.fall_state = tmp['>'];\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    }\n    SEA.opt.fallback = 2;\n\n  })(USE, './verify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var sha256hash = USE('./sha256');\n\n    const importGen = async (key, salt, opt) => {\n      //const combo = shim.Buffer.concat([shim.Buffer.from(key, 'utf8'), salt || shim.random(8)]).toString('utf8') // old\n      opt = opt || {};\n      const combo = key + (salt || shim.random(8)).toString('utf8'); // new\n      const hash = shim.Buffer.from(await sha256hash(combo), 'binary')\n      \n      const jwkKey = S.keyToJwk(hash)      \n      return await shim.subtle.importKey('jwk', jwkKey, {name:'AES-GCM'}, false, ['encrypt', 'decrypt'])\n    }\n    module.exports = importGen;\n  })(USE, './aeskey');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n    var u;\n\n    SEA.encrypt = SEA.encrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(u === data){ throw '`undefined` not allowed.' }\n      if(!key){\n        pair = await SEA.I(null, {what: data, how: 'encrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var msg = (typeof data == 'string')? data : JSON.stringify(data);\n      var rand = {s: shim.random(9), iv: shim.random(15)}; // consider making this 9 and 15 or 18 or 12 to reduce == padding.\n      var ct = await aeskey(key, rand.s, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).encrypt({ // Keeping the AES key scope as private as possible...\n        name: opt.name || 'AES-GCM', iv: new Uint8Array(rand.iv)\n      }, aes, new shim.TextEncoder().encode(msg)));\n      var r = {\n        ct: shim.Buffer.from(ct, 'binary').toString(opt.encode || 'base64'),\n        iv: rand.iv.toString(opt.encode || 'base64'),\n        s: rand.s.toString(opt.encode || 'base64')\n      }\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.encrypt;\n  })(USE, './encrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    var aeskey = USE('./aeskey');\n\n    SEA.decrypt = SEA.decrypt || (async (data, pair, cb, opt) => { try {\n      opt = opt || {};\n      var key = (pair||opt).epriv || pair;\n      if(!key){\n        pair = await SEA.I(null, {what: data, how: 'decrypt', why: opt.why});\n        key = pair.epriv || pair;\n      }\n      var json = S.parse(data);\n      var buf, bufiv, bufct; try{\n        buf = shim.Buffer.from(json.s, opt.encode || 'base64');\n        bufiv = shim.Buffer.from(json.iv, opt.encode || 'base64');\n        bufct = shim.Buffer.from(json.ct, opt.encode || 'base64');\n        var ct = await aeskey(key, buf, opt).then((aes) => (/*shim.ossl ||*/ shim.subtle).decrypt({  // Keeping aesKey scope as private as possible...\n          name: opt.name || 'AES-GCM', iv: new Uint8Array(bufiv), tagLength: 128\n        }, aes, new Uint8Array(bufct)));\n      }catch(e){\n        if('utf8' === opt.encode){ throw \"Could not decrypt\" }\n        if(SEA.opt.fallback){\n          opt.encode = 'utf8';\n          return await SEA.decrypt(data, pair, cb, opt);\n        }\n      }\n      var r = S.parse(new shim.TextDecoder('utf8').decode(ct));\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) { \n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.decrypt;\n  })(USE, './decrypt');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    var shim = USE('./shim');\n    var S = USE('./settings');\n    // Derive shared secret from other's pub and my epub/epriv \n    SEA.secret = SEA.secret || (async (key, pair, cb, opt) => { try {\n      opt = opt || {};\n      if(!pair || !pair.epriv || !pair.epub){\n        pair = await SEA.I(null, {what: key, how: 'secret', why: opt.why});\n      }\n      var pub = key.epub || key;\n      var epub = pair.epub;\n      var epriv = pair.epriv;\n      var ecdhSubtle = shim.ossl || shim.subtle;\n      var pubKeyData = keysToEcdhJwk(pub);\n      var props = Object.assign({ public: await ecdhSubtle.importKey(...pubKeyData, true, []) },{name: 'ECDH', namedCurve: 'P-256'}); // Thanks to @sirpy !\n      var privKeyData = keysToEcdhJwk(epub, epriv);\n      var derived = await ecdhSubtle.importKey(...privKeyData, false, ['deriveBits']).then(async (privKey) => {\n        // privateKey scope doesn't leak out from here!\n        var derivedBits = await ecdhSubtle.deriveBits(props, privKey, 256);\n        var rawBits = new Uint8Array(derivedBits);\n        var derivedKey = await ecdhSubtle.importKey('raw', rawBits,{ name: 'AES-GCM', length: 256 }, true, [ 'encrypt', 'decrypt' ]);\n        return ecdhSubtle.exportKey('jwk', derivedKey).then(({ k }) => k);\n      })\n      var r = derived;\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      console.log(e);\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    // can this be replaced with settings.jwk?\n    var keysToEcdhJwk = (pub, d) => { // d === priv\n      //var [ x, y ] = Buffer.from(pub, 'base64').toString('utf8').split(':') // old\n      var [ x, y ] = pub.split('.') // new\n      var jwk = d ? { d: d } : {}\n      return [  // Use with spread returned value...\n        'jwk',\n        Object.assign(\n          jwk,\n          { x: x, y: y, kty: 'EC', crv: 'P-256', ext: true }\n        ), // ??? refactor\n        {name: 'ECDH', namedCurve: 'P-256'}\n      ]\n    }\n\n    module.exports = SEA.secret;\n  })(USE, './secret');\n\n  ;USE(function(module){\n    var SEA = USE('./root');\n    \n    // This is to certify that a group of \"certificants\" can \"put\" anything at a group of matched \"paths\" to the certificate authority's graph\n    SEA.certify = SEA.certify || (async (certificants, policy = {}, authority, cb, opt = {}) => { try {\n      /*\n      IMPORTANT: A Certificate is like a Signature. No one knows who (authority) created/signed a cert until you put it into their graph.\n      \"certificants\": '*' or a String (Bob.pub) || an Object that contains \"pub\" as a key || an array of [object || string]. These people will have the rights.\n      \"policy\": A string ('inbox'), or a RAD/LEX object {'*': 'inbox'}, or an Array of RAD/LEX objects or strings. RAD/LEX object can contain key \"?\" with indexOf(\"*\") > -1 to force key equals certificant pub. This rule is used to check against soul+'/'+key using Gun.text.match or String.match.\n      \"authority\": Key pair or priv of the certificate authority.\n      \"cb\": A callback function after all things are done.\n      \"opt\": If opt.expiry (a timestamp) is set, SEA won't sync data after opt.expiry. If opt.blacklist is set, SEA will look for blacklist before syncing.\n      */\n      \n      console.log('SEA.certify() is an early experimental community supported method that may change API behavior without warning in any future version.')\n\n      certificants = (() => {\n        var data = []\n        if (certificants) {\n          if ((typeof certificants === 'string' || Array.isArray(certificants)) && certificants.indexOf('*') !== -1) return '*'\n          \n          if (typeof certificants === 'string') {\n            return certificants\n          }\n\n          if (Array.isArray(certificants)) {\n            if (certificants.length === 1 && certificants[0]) return typeof certificants[0] === 'object' && certificants[0].pub ? certificants[0].pub : typeof certificants[0] === 'string' ? certificants[0] : null\n            certificants.map(certificant => {\n              if (typeof certificant ==='string') data.push(certificant)\n              else if (typeof certificant === 'object' && certificant.pub) data.push(certificant.pub)\n            })\n          }\n\n          if (typeof certificants === 'object' && certificants.pub) return certificants.pub\n          \n          return data.length > 0 ? data : null\n        }\n        return null\n      })()\n\n      if (!certificants) return console.log(\"No certificant found.\")\n\n      const expiry = opt.expiry && (typeof opt.expiry === 'number' || typeof opt.expiry === 'string') ? parseFloat(opt.expiry) : null\n      const readPolicy = (policy || {}).read ? policy.read : null\n      const writePolicy = (policy || {}).write ? policy.write : typeof policy === 'string' || Array.isArray(policy) || policy[\"+\"] || policy[\"#\"] || policy[\".\"] || policy[\"=\"] || policy[\"*\"] || policy[\">\"] || policy[\"<\"] ? policy : null\n      const readBlacklist = ((opt || {}).blacklist || {}).read && (typeof opt.blacklist.read === 'string' || opt.blacklist.read['#']) ? opt.blacklist.read : null\n      const writeBlacklist = typeof (opt || {}).blacklist === 'string' || (((opt || {}).blacklist || {}).write || {})['#'] ? opt.blacklist : ((opt || {}).blacklist || {}).write && (typeof opt.blacklist.write === 'string' || opt.blacklist.write['#']) ? opt.blacklist.write : null\n\n      if (!readPolicy && !writePolicy) return console.log(\"No policy found.\")\n\n      // reserved keys: c, e, r, w, rb, wb\n      const data = JSON.stringify({\n        c: certificants,\n        ...(expiry ? {e: expiry} : {}), // inject expiry if possible\n        ...(readPolicy ? {r: readPolicy }  : {}), // \"r\" stands for read, which means read permission.\n        ...(writePolicy ? {w: writePolicy} : {}), // \"w\" stands for write, which means write permission.\n        ...(readBlacklist ? {rb: readBlacklist} : {}), // inject READ blacklist if possible\n        ...(writeBlacklist ? {wb: writeBlacklist} : {}), // inject WRITE blacklist if possible\n      })\n\n      const certificate = await SEA.sign(data, authority, null, {raw:1})\n\n      var r = certificate\n      if(!opt.raw){ r = 'SEA'+JSON.stringify(r) }\n      if(cb){ try{ cb(r) }catch(e){console.log(e)} }\n      return r;\n    } catch(e) {\n      SEA.err = e;\n      if(SEA.throw){ throw e }\n      if(cb){ cb() }\n      return;\n    }});\n\n    module.exports = SEA.certify;\n  })(USE, './certify');\n\n  ;USE(function(module){\n    var shim = USE('./shim');\n    // Practical examples about usage found in tests.\n    var SEA = USE('./root');\n    SEA.work = USE('./work');\n    SEA.sign = USE('./sign');\n    SEA.verify = USE('./verify');\n    SEA.encrypt = USE('./encrypt');\n    SEA.decrypt = USE('./decrypt');\n    SEA.certify = USE('./certify');\n    //SEA.opt.aeskey = USE('./aeskey'); // not official! // this causes problems in latest WebCrypto.\n\n    SEA.random = SEA.random || shim.random;\n\n    // This is Buffer used in SEA and usable from Gun/SEA application also.\n    // For documentation see https://nodejs.org/api/buffer.html\n    SEA.Buffer = SEA.Buffer || USE('./buffer');\n\n    // These SEA functions support now ony Promises or\n    // async/await (compatible) code, use those like Promises.\n    //\n    // Creates a wrapper library around Web Crypto API\n    // for various AES, ECDSA, PBKDF2 functions we called above.\n    // Calculate public key KeyID aka PGPv4 (result: 8 bytes as hex string)\n    SEA.keyid = SEA.keyid || (async (pub) => {\n      try {\n        // base64('base64(x):base64(y)') => Buffer(xy)\n        const pb = Buffer.concat(\n          pub.replace(/-/g, '+').replace(/_/g, '/').split('.')\n          .map((t) => Buffer.from(t, 'base64'))\n        )\n        // id is PGPv4 compliant raw key\n        const id = Buffer.concat([\n          Buffer.from([0x99, pb.length / 0x100, pb.length % 0x100]), pb\n        ])\n        const sha1 = await sha1hash(id)\n        const hash = Buffer.from(sha1, 'binary')\n        return hash.toString('hex', hash.length - 8)  // 16-bit ID as hex\n      } catch (e) {\n        console.log(e)\n        throw e\n      }\n    });\n    // all done!\n    // Obviously it is missing MANY necessary features. This is only an alpha release.\n    // Please experiment with it, audit what I've done so far, and complain about what needs to be added.\n    // SEA should be a full suite that is easy and seamless to use.\n    // Again, scroll naer the top, where I provide an EXAMPLE of how to create a user and sign in.\n    // Once logged in, the rest of the code you just read handled automatically signing/validating data.\n    // But all other behavior needs to be equally easy, like opinionated ways of\n    // Adding friends (trusted public keys), sending private messages, etc.\n    // Cheers! Tell me what you think.\n    var Gun = (SEA.window||{}).Gun || USE((typeof MODULE == \"undefined\"?'.':'')+'./gun', 1);\n    Gun.SEA = SEA;\n    SEA.GUN = SEA.Gun = Gun;\n\n    module.exports = SEA\n  })(USE, './sea');\n\n  ;USE(function(module){\n    var Gun = USE('./sea').Gun;\n    Gun.chain.then = function(cb, opt){\n      var gun = this, p = (new Promise(function(res, rej){\n        gun.once(res, opt);\n      }));\n      return cb? p.then(cb) : p;\n    }\n  })(USE, './then');\n\n  ;USE(function(module){\n    var SEA = USE('./sea');\n    var Gun = SEA.Gun;\n    var then = USE('./then');\n\n    function User(root){ \n      this._ = {$: this};\n    }\n    User.prototype = (function(){ function F(){}; F.prototype = Gun.chain; return new F() }()) // Object.create polyfill\n    User.prototype.constructor = User;\n\n    // let's extend the gun chain with a `user` function.\n    // only one user can be logged in at a time, per gun instance.\n    Gun.chain.user = function(pub){\n      var gun = this, root = gun.back(-1), user;\n      if(pub){ return root.get('~'+pub) }\n      if(user = root.back('user')){ return user }\n      var root = (root._), at = root, uuid = at.opt.uuid || Gun.state.lex;\n      (at = (user = at.user = gun.chain(new User))._).opt = {};\n      at.opt.uuid = function(cb){\n        var id = uuid(), pub = root.user;\n        if(!pub || !(pub = pub.is) || !(pub = pub.pub)){ return id }\n        id = id + '~' + pub + '/';\n        if(cb && cb.call){ cb(null, id) }\n        return id;\n      }\n      return user;\n    }\n    Gun.User = User;\n    module.exports = User;\n  })(USE, './user');\n\n  ;USE(function(module){\n    // TODO: This needs to be split into all separate functions.\n    // Not just everything thrown into 'create'.\n\n    var SEA = USE('./sea');\n    var User = USE('./user');\n    var authsettings = USE('./settings');\n    var Gun = SEA.Gun;\n\n    var noop = function(){};\n\n    // Well first we have to actually create a user. That is what this function does.\n    User.prototype.create = function(...args){\n      const pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      const alias = pair && (pair.pub || pair.epub) ? pair.pub : typeof args[0] === 'string' ? args[0] : null;\n      const pass = pair && (pair.pub || pair.epub) ? pair : alias && typeof args[1] === 'string' ? args[1] : null;\n      const cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      const opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      \n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      var act = {}, u;\n      act.a = function(pubs){\n        act.pubs = pubs;\n        if(pubs && !opt.already){\n          // If we can enforce that a user name is already taken, it might be nice to try, but this is not guaranteed.\n          var ack = {err: Gun.log('User already created!')};\n          cat.ing = false;\n          (cb || noop)(ack);\n          gun.leave();\n          return;\n        }\n        act.salt = Gun.text.random(64); // pseudo-randomly create a salt, then use PBKDF2 function to extend the password with it.\n        SEA.work(pass, act.salt, act.b); // this will take some short amount of time to produce a proof, which slows brute force attacks.\n      }\n      act.b = function(proof){\n        act.proof = proof;\n        pair ? act.c(pair) : SEA.pair(act.c) // generate a brand new key pair or use the existing.\n      }\n      act.c = function(pair){\n        var tmp\n        act.pair = pair || {};\n        if(tmp = cat.root.user){\n          tmp._.sea = pair;\n          tmp.is = {pub: pair.pub, epub: pair.epub, alias: alias};\n        }\n        // the user's public key doesn't need to be signed. But everything else needs to be signed with it! // we have now automated it! clean up these extra steps now!\n        act.data = {pub: pair.pub};\n        act.d();\n      }\n      act.d = function(){\n        act.data.alias = alias;\n        act.e();\n      }\n      act.e = function(){\n        act.data.epub = act.pair.epub; \n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, act.proof, act.f, {raw:1}); // to keep the private key safe, we AES encrypt it with the proof of work!\n      }\n      act.f = function(auth){\n        act.data.auth = JSON.stringify({ek: auth, s: act.salt}); \n        act.g(act.data.auth);\n      }\n      act.g = function(auth){ var tmp;\n        act.data.auth = act.data.auth || auth;\n        root.get(tmp = '~'+act.pair.pub).put(act.data); // awesome, now we can actually save the user with their public key as their ID.\n        root.get('~@'+alias).put(Gun.obj.put({}, tmp, Gun.val.link.ify(tmp)), act.h); // next up, we want to associate the alias with the public key. So we add it to the alias list.\n      }\n      act.h = function(){\n        cat.ing = false;\n        (cb || noop)({ok: 0, pub: act.pair.pub}); // callback that the user has been created. (Note: ok = 0 because we didn't wait for disk to ack)\n        if(!cb) {pair ? gun.auth(pair) : gun.auth(alias, pass)} // if no callback is passed, auto-login after signing up.\n      }\n      root.get('~@'+alias).once(act.a);\n      return gun;\n    }\n    // now that we have created a user, we want to authenticate them!\n    User.prototype.auth = function(...args){\n      const pair = typeof args[0] === 'object' && (args[0].pub || args[0].epub) ? args[0] : typeof args[1] === 'object' && (args[1].pub || args[1].epub) ? args[1] : null;\n      const alias = !pair && typeof args[0] === 'string' ? args[0] : null;\n      const pass = alias && typeof args[1] === 'string' ? args[1] : null;\n      const cb = args.filter(arg => typeof arg === 'function')[0] || null; // cb now can stand anywhere, after alias/pass or pair\n      const opt = args && args.length > 1 && typeof args[args.length-1] === 'object' ? args[args.length-1] : {}; // opt is always the last parameter which typeof === 'object' and stands after cb\n      \n      var gun = this, cat = (gun._), root = gun.back(-1);\n      \n      if(cat.ing){\n        (cb || noop)({err: Gun.log(\"User is already being created or authenticated!\"), wait: true});\n        return gun;\n      }\n      cat.ing = true;\n      \n      var act = {}, u;\n      act.a = function(data){\n        if(!data){ return act.b() }\n        if(!data.pub){\n          var tmp = [];\n          Gun.node.is(data, function(v){ tmp.push(v) })\n          return act.b(tmp);\n        }\n        if(act.name){ return act.f(data) }\n        act.c((act.data = data).auth);\n      }\n      act.b = function(list){\n        var get = (act.list = (act.list||[]).concat(list||[])).shift();\n        if(u === get){\n          if(act.name){ return act.err('Your user account is not published for dApps to access, please consider syncing it online, or allowing local access by adding your device as a peer.') }\n          return act.err('Wrong user or password.') \n        }\n        root.get(get).once(act.a);\n      }\n      act.c = function(auth){\n        if(u === auth){ return act.b() }\n        if(Gun.text.is(auth)){ return act.c(Gun.obj.ify(auth)) } // in case of legacy\n        SEA.work(pass, (act.auth = auth).s, act.d, act.enc); // the proof of work is evidence that we've spent some time/effort trying to log in, this slows brute force.\n      }\n      act.d = function(proof){\n        SEA.decrypt(act.auth.ek, proof, act.e, act.enc);\n      }\n      act.e = function(half){\n        if(u === half){\n          if(!act.enc){ // try old format\n            act.enc = {encode: 'utf8'};\n            return act.c(act.auth);\n          } act.enc = null; // end backwards\n          return act.b();\n        }\n        act.half = half;\n        act.f(act.data);\n      }\n      act.f = function(data){\n        if(!data || !data.pub){ return act.b() }\n        var tmp = act.half || {};\n        act.g({pub: data.pub, epub: data.epub, priv: tmp.priv, epriv: tmp.epriv});\n      }\n      act.g = function(pair){\n        act.pair = pair;\n        var user = (root._).user, at = (user._);\n        var tmp = at.tag;\n        var upt = at.opt;\n        at = user._ = root.get('~'+pair.pub)._;\n        at.opt = upt;\n        // add our credentials in-memory only to our root user instance\n        user.is = {pub: pair.pub, epub: pair.epub, alias: alias || pair};\n        at.sea = act.pair;\n        cat.ing = false;\n        try{if(pass && !Gun.obj.has(Gun.obj.ify(cat.root.graph['~'+pair.pub].auth), ':')){ opt.shuffle = opt.change = pass; } }catch(e){} // migrate UTF8 & Shuffle!\n        opt.change? act.z() : (cb || noop)(at);\n        if(SEA.window && ((gun.back('user')._).opt||opt).remember){\n          // TODO: this needs to be modular.\n          try{var sS = {};\n          sS = window.sessionStorage;\n          sS.recall = true;\n          sS.pair = JSON.stringify(pair); // auth using pair is more reliable than alias/pass\n          }catch(e){}\n        }\n        try{\n          (root._).on('auth', at) // TODO: Deprecate this, emit on user instead! Update docs when you do.\n          //at.on('auth', at) // Arrgh, this doesn't work without event \"merge\" code, but \"merge\" code causes stack overflow and crashes after logging in & trying to write data.\n        }catch(e){\n          Gun.log(\"Your 'auth' callback crashed with:\", e);\n        }\n      }\n      act.z = function(){\n        // password update so encrypt private key using new pwd + salt\n        act.salt = Gun.text.random(64); // pseudo-random\n        SEA.work(opt.change, act.salt, act.y);\n      }\n      act.y = function(proof){\n        SEA.encrypt({priv: act.pair.priv, epriv: act.pair.epriv}, proof, act.x, {raw:1});\n      }\n      act.x = function(auth){\n        act.w(JSON.stringify({ek: auth, s: act.salt}));\n      }\n      act.w = function(auth){\n        if(opt.shuffle){ // delete in future!\n          console.log('migrate core account from UTF8 & shuffle');\n          var tmp = Gun.obj.to(act.data);\n          Gun.obj.del(tmp, '_');\n          tmp.auth = auth;\n          root.get('~'+act.pair.pub).put(tmp);\n        } // end delete\n        root.get('~'+act.pair.pub).get('auth').put(auth, cb || noop);\n      }\n      act.err = function(e){\n        var ack = {err: Gun.log(e || 'User cannot be found!')};\n        cat.ing = false;\n        (cb || noop)(ack);\n      }\n      act.plugin = function(name){\n        if(!(act.name = name)){ return act.err() }\n        var tmp = [name];\n        if('~' !== name[0]){\n          tmp[1] = '~'+name;\n          tmp[2] = '~@'+name;\n        }\n        act.b(tmp);\n      }\n      if(pair){\n        act.g(pair);\n      } else\n      if(alias){\n        root.get('~@'+alias).once(act.a);\n      } else\n      if(!alias && !pass){\n        SEA.name(act.plugin);\n      }\n      return gun;\n    }\n    User.prototype.pair = function(){\n      console.log(\"user.pair() IS DEPRECATED AND WILL BE DELETED!!!\");\n      var user = this;\n      if(!user.is){ return false }\n      return user._.sea;\n    }\n    User.prototype.leave = function(opt, cb){\n      var gun = this, user = (gun.back(-1)._).user;\n      if(user){\n        delete user.is;\n        delete user._.is;\n        delete user._.sea;\n      }\n      if(SEA.window){\n        try{var sS = {};\n        sS = window.sessionStorage;\n        delete sS.recall;\n        delete sS.pair;\n        }catch(e){};\n      }\n      return gun;\n    }\n    // If authenticated user wants to delete his/her account, let's support it!\n    User.prototype.delete = async function(alias, pass, cb){\n      console.log(\"user.delete() IS DEPRECATED AND WILL BE MOVED TO A MODULE!!!\");\n      var gun = this, root = gun.back(-1), user = gun.back('user');\n      try {\n        user.auth(alias, pass, function(ack){\n          var pub = (user.is||{}).pub;\n          // Delete user data\n          user.map().once(function(){ this.put(null) });\n          // Wipe user data from memory\n          user.leave();\n          (cb || noop)({ok: 0});\n        });\n      } catch (e) {\n        Gun.log('User.delete failed! Error:', e);\n      }\n      return gun;\n    }\n    User.prototype.recall = function(opt, cb){\n      var gun = this, root = gun.back(-1), tmp;\n      opt = opt || {};\n      if(opt && opt.sessionStorage){\n        if(SEA.window){\n          try{\n            var sS = {};\n            sS = window.sessionStorage;\n            if(sS){\n              (root._).opt.remember = true;\n              ((gun.back('user')._).opt||opt).remember = true;\n              if(sS.recall || sS.pair) root.user().auth(JSON.parse(sS.pair), cb); // pair is more reliable than alias/pass\n            }\n          }catch(e){}\n        }\n        return gun;\n      }\n      /*\n        TODO: copy mhelander's expiry code back in.\n        Although, we should check with community,\n        should expiry be core or a plugin?\n      */\n      return gun;\n    }\n    User.prototype.alive = async function(){\n      console.log(\"user.alive() IS DEPRECATED!!!\");\n      const gunRoot = this.back(-1)\n      try {\n        // All is good. Should we do something more with actual recalled data?\n        await authRecall(gunRoot)\n        return gunRoot._.user._\n      } catch (e) {\n        const err = 'No session!'\n        Gun.log(err)\n        throw { err }\n      }\n    }\n    User.prototype.trust = async function(user){\n      // TODO: BUG!!! SEA `node` read listener needs to be async, which means core needs to be async too.\n      //gun.get('alice').get('age').trust(bob);\n      if (Gun.is(user)) {\n        user.get('pub').get((ctx, ev) => {\n          console.log(ctx, ev)\n        })\n      }\n      user.get('trust').get(path).put(theirPubkey);\n\n      // do a lookup on this gun chain directly (that gets bob's copy of the data)\n      // do a lookup on the metadata trust table for this path (that gets all the pubkeys allowed to write on this path)\n      // do a lookup on each of those pubKeys ON the path (to get the collab data \"layers\")\n      // THEN you perform Jachen's mix operation\n      // and return the result of that to...\n    }\n    User.prototype.grant = function(to, cb){\n      console.log(\"`.grant` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user._.sea, path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('grant').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('grant').get(pair.pub).get(path).put(enc);\n      }\n      var pub = to.get('pub').then();\n      var epub = to.get('epub').then();\n      pub = await pub; epub = await epub;\n      var dh = await SEA.secret(epub, pair);\n      enc = await SEA.encrypt(sec, dh);\n      user.get('grant').get(pub).get(path).put(enc, cb);\n      }());\n      return gun;\n    }\n    User.prototype.secret = function(data, cb){\n      console.log(\"`.secret` API MAY BE DELETED OR CHANGED OR RENAMED, DO NOT USE!\");\n      var gun = this, user = gun.back(-1).user(), pair = user.pair(), path = '';\n      gun.back(function(at){ if(at.is){ return } path += (at.get||'') });\n      (async function(){\n      var enc, sec = await user.get('trust').get(pair.pub).get(path).then();\n      sec = await SEA.decrypt(sec, pair);\n      if(!sec){\n        sec = SEA.random(16).toString();\n        enc = await SEA.encrypt(sec, pair);\n        user.get('trust').get(pair.pub).get(path).put(enc);\n      }\n      enc = await SEA.encrypt(data, sec);\n      gun.put(enc, cb);\n      }());\n      return gun;\n    }\n\n    /**\n     * returns the decrypted value, encrypted by secret\n     * @returns {Promise<any>}\n     // Mark needs to review 1st before officially supported\n    User.prototype.decrypt = function(cb) {\n      let gun = this,\n        path = ''\n      gun.back(function(at) {\n        if (at.is) {\n          return\n        }\n        path += at.get || ''\n      })\n      return gun\n        .then(async data => {\n          if (data == null) {\n            return\n          }\n          const user = gun.back(-1).user()\n          const pair = user.pair()\n          let sec = await user\n            .get('trust')\n            .get(pair.pub)\n            .get(path)\n          sec = await SEA.decrypt(sec, pair)\n          if (!sec) {\n            return data\n          }\n          let decrypted = await SEA.decrypt(data, sec)\n          return decrypted\n        })\n        .then(res => {\n          cb && cb(res)\n          return res\n        })\n    }\n    */\n    module.exports = User\n  })(USE, './create');\n\n  ;USE(function(module){\n    var SEA = USE('./sea')\n    var S = USE('./settings')\n    var Gun = SEA.Gun;\n    // After we have a GUN extension to make user registration/login easy, we then need to handle everything else.\n\n    // We do this with a GUN adapter, we first listen to when a gun instance is created (and when its options change)\n    Gun.on('opt', function(at){\n      if(!at.sea){ // only add SEA once per instance, on the \"at\" context.\n        at.sea = {own: {}};\n        //at.on('in', security, at); // now listen to all input data, acting as a firewall.\n        //at.on('out', signature, at); // and output listeners, to encrypt outgoing data.\n        at.on('put', check, at);\n      }\n      this.to.next(at); // make sure to call the \"next\" middleware adapter.\n    });\n\n    // Alright, this next adapter gets run at the per node level in the graph database.\n    // This will let us verify that every property on a node has a value signed by a public key we trust.\n    // If the signature does not match, the data is just `undefined` so it doesn't get passed on.\n    // If it does match, then we transform the in-memory \"view\" of the data into its plain value (without the signature).\n    // Now NOTE! Some data is \"system\" data, not user data. Example: List of public keys, aliases, etc.\n    // This data is self-enforced (the value can only match its ID), but that is handled in the `security` function.\n    // From the self-enforced data, we can see all the edges in the graph that belong to a public key.\n    // Example: ~ASDF is the ID of a node with ASDF as its public key, signed alias and salt, and\n    // its encrypted private key, but it might also have other signed values on it like `profile = <ID>` edge.\n    // Using that directed edge's ID, we can then track (in memory) which IDs belong to which keys.\n    // Here is a problem: Multiple public keys can \"claim\" any node's ID, so this is dangerous!\n    // This means we should ONLY trust our \"friends\" (our key ring) public keys, not any ones.\n    // I have not yet added that to SEA yet in this alpha release. That is coming soon, but beware in the meanwhile!\n    function each(msg){ // TODO: Warning: Need to switch to `gun.on('node')`! Do not use `Gun.on('node'` in your apps!\n      // NOTE: THE SECURITY FUNCTION HAS ALREADY VERIFIED THE DATA!!!\n      // WE DO NOT NEED TO RE-VERIFY AGAIN, JUST TRANSFORM IT TO PLAINTEXT.\n      var to = this.to, vertex = (msg.$._).put, c = 0, d;\n      Gun.node.is(msg.put, function(val, key, node){\n        // only process if SEA formatted?\n        var tmp = Gun.obj.ify(val) || noop;\n        if(u !== tmp[':']){\n          node[key] = SEA.opt.unpack(tmp);\n          return;\n        }\n        if(!SEA.opt.check(val)){ return }\n        c++; // for each property on the node\n        SEA.verify(val, false, function(data){ c--; // false just extracts the plain data.\n          node[key] = SEA.opt.unpack(data, key, node);; // transform to plain value.\n          if(d && !c && (c = -1)){ to.next(msg) }\n        });\n      });\n      if((d = true) && !c){ to.next(msg) }\n    }\n\n    // signature handles data output, it is a proxy to the security function.\n    function signature(msg){\n      if((msg._||noop).user){\n        return this.to.next(msg);\n      }\n      var ctx = this.as;\n      (msg._||(msg._=function(){})).user = ctx.user;\n      security.call(this, msg);\n    }\n\n    var u;\n    function check(msg){ // REVISE / IMPROVE, NO NEED TO PASS MSG/EVE EACH SUB?\n      var eve = this, at = eve.as, put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], id = msg['#'], tmp;\n      if(!soul || !key){ return }\n      if((msg._||'').faith && (at.opt||'').faith && 'function' == typeof msg._){\n        SEA.verify(SEA.opt.pack(put), false, function(data){ // this is synchronous if false\n          put['='] = SEA.opt.unpack(data);\n          eve.to.next(msg);\n        });\n        return \n      }\n      var no = function(why){ at.on('in', {'@': id, err: why}) };\n      //var no = function(why){ msg.ack(why) };\n      (msg._||'').DBG && ((msg._||'').DBG.c = +new Date);\n      if(0 <= soul.indexOf('<?')){ // special case for \"do not sync data X old\"\n        // 'a~pub.key/b<?9'\n        tmp = parseFloat(soul.split('<?')[1]||'');\n        if(tmp && (state < (Gun.state() - (tmp * 1000)))){ // sec to ms\n          (tmp = msg._) && (tmp = tmp.lot) && (tmp.more--); // THIS IS BAD CODE! It assumes GUN internals do something that will probably change in future, but hacking in now.\n          return; // omit!\n        }\n      }\n      \n      if('~@' === soul){  // special case for shared system data, the list of aliases.\n        check.alias(eve, msg, val, key, soul, at, no); return;\n      }\n      if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\n        check.pubs(eve, msg, val, key, soul, at, no); return;\n      }\n      //if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n      if(tmp = SEA.opt.pub(soul)){ // special case, account data for a public key.\n        check.pub(eve, msg, val, key, soul, at, no, at.user||'', tmp); return;\n      }\n      if(0 <= soul.indexOf('#')){ // special case for content addressing immutable hashed data.\n        check.hash(eve, msg, val, key, soul, at, no); return;\n      } \n      check.any(eve, msg, val, key, soul, at, no, at.user||''); return;\n      eve.to.next(msg); // not handled\n    }\n    check.hash = function(eve, msg, val, key, soul, at, no){\n      SEA.work(val, null, function(data){\n        if(data && data === key.split('#').slice(-1)[0]){ return eve.to.next(msg) }\n        no(\"Data hash not same as hash!\");\n      }, {name: 'SHA-256'});\n    }\n    check.alias = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@, ~@alice: {#~@alice}}\n      if(!val){ return no(\"Data must exist!\") } // data MUST exist\n      if('~@'+key === link_is(val)){ return eve.to.next(msg) } // in fact, it must be EXACTLY equal to itself\n      no(\"Alias not same!\"); // if it isn't, reject.\n    };\n    check.pubs = function(eve, msg, val, key, soul, at, no){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\n      if(!val){ return no(\"Alias must exist!\") } // data MUST exist\n      if(key === link_is(val)){ return eve.to.next(msg) } // and the ID must be EXACTLY equal to its property\n      no(\"Alias not same!\"); // that way nobody can tamper with the list of public keys.\n    };\n    check.pub = function(eve, msg, val, key, soul, at, no, user, pub){ var tmp // Example: {_:#~asdf, hello:'world'~fdsa}}\n      const raw = S.parse(val) || {}\n      const verify = (certificate, certificant, cb) => {\n        if (certificate.m && certificate.s && certificant && pub)\n          // now verify certificate\n          return SEA.verify(certificate, pub, data => { // check if \"pub\" (of the graph owner) really issued this cert\n            if (u !== data && u !== data.e && msg.put['>'] && msg.put['>'] > parseFloat(data.e)) return no(\"Certificate expired.\") // certificate expired\n            // \"data.c\" = a list of certificants/certified users\n            // \"data.w\" = lex WRITE permission, in the future, there will be \"data.r\" which means lex READ permission\n            if (u !== data && data.c && data.w && (data.c === certificant || data.c.indexOf('*' || certificant) > -1)) {\n              // ok, now \"certificant\" is in the \"certificants\" list, but is \"path\" allowed? Check path\n              let path = soul.indexOf('/') > -1 ? soul.replace(soul.substring(0, soul.indexOf('/') + 1), '') : ''\n              String.match = String.match || Gun.text.match\n              const w = Array.isArray(data.w) ? data.w : typeof data.w === 'object' || typeof data.w === 'string' ? [data.w] : []\n              for (const lex of w) {\n                if ((String.match(path, lex['#']) && String.match(key, lex['.'])) || (!lex['.'] && String.match(path, lex['#'])) || (!lex['#'] && String.match(key, lex['.'])) || String.match((path ? path + '/' + key : key), lex['#'] || lex)) {\n                  // is Certificant forced to present in Path\n                  if (lex['+'] && lex['+'].indexOf('*') > -1 && path && path.indexOf(certificant) == -1 && key.indexOf(certificant) == -1) return no(`Path \"${path}\" or key \"${key}\" must contain string \"${certificant}\".`)\n                  // path is allowed, but is there any WRITE blacklist? Check it out\n                  if (data.wb && (typeof data.wb === 'string' || ((data.wb || {})['#']))) { // \"data.wb\" = path to the WRITE blacklist\n                    var root = at.$.back(-1)\n                    if (typeof data.wb === 'string' && '~' !== data.wb.slice(0, 1)) root = root.get('~' + pub)\n                    return root.get(data.wb).get(certificant).once(value => {\n                      if (value && (value === 1 || value === true)) return no(\"Certificant blacklisted.\")\n                      return cb(data)\n                    })\n                  }\n                  return cb(data)\n                }\n              }\n              return no(\"Certificate verification fail.\")\n            }\n          })\n        return\n      }\n      \n      if ('pub' === key && '~' + pub === soul) {\n        if (val === pub) return eve.to.next(msg) // the account MUST match `pub` property that equals the ID of the public key.\n        return no(\"Account not same!\")\n      }\n\n      if ((tmp = user.is) && tmp.pub && !raw['*'] && !raw['+'] && (pub === tmp.pub || (pub !== tmp.pub && ((msg._.out || {}).opt || {}).cert))){\n        SEA.sign(SEA.opt.pack(msg.put), (user._).sea, function(data){\n          if (u === data) return no(SEA.err || 'Signature fail.')\n          msg.put[':'] = {':': tmp = SEA.opt.unpack(data.m), '~': data.s}\n          msg.put['='] = tmp\n\n          // if writing to own graph, just allow it\n          if (pub === user.is.pub) {\n            if (tmp = link_is(val)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n            msg.put[':'] = JSON.stringify(msg.put[':'])\n            return eve.to.next(msg)\n          }\n\n          // if writing to other's graph, check if cert exists then try to inject cert into put, also inject self pub so that everyone can verify the put\n          if (pub !== user.is.pub && ((msg._.out || {}).opt || {}).cert) {\n            const cert = S.parse(msg._.out.opt.cert)\n            // even if cert exists, we must verify it\n            if (cert && cert.m && cert.s)\n              verify(cert, user.is.pub, _ => {\n                msg.put[':']['+'] = cert // '+' is a certificate\n                msg.put[':']['*'] = user.is.pub // '*' is pub of the user who puts\n                msg.put[':'] = JSON.stringify(msg.put[':'])\n                return eve.to.next(msg)\n              })\n          }\n        }, {raw: 1})\n        return;\n      }\n\n      SEA.verify(SEA.opt.pack(msg.put), raw['*'] || pub, function(data){ var tmp;\n        data = SEA.opt.unpack(data);\n        if (u === data) return no(\"Unverified data.\") // make sure the signature matches the account it claims to be on. // reject any updates that are signed with a mismatched account.\n        if ((tmp = link_is(data)) && pub === SEA.opt.pub(tmp)) (at.sea.own[tmp] = at.sea.own[tmp] || {})[pub] = 1\n        \n        // check if cert ('+') and putter's pub ('*') exist\n        if (raw['+'] && raw['+']['m'] && raw['+']['s'] && raw['*'])\n          // now verify certificate\n          verify(raw['+'], raw['*'], _ => {\n            msg.put['='] = data;\n            return eve.to.next(msg);\n          })\n        else {\n          msg.put['='] = data;\n          return eve.to.next(msg);\n        }\n      });\n    };\n    check.any = function(eve, msg, val, key, soul, at, no, user){ var tmp, pub;\n      if(at.opt.secure){ return no(\"Soul missing public key at '\" + key + \"'.\") }\n      // TODO: Ask community if should auto-sign non user-graph data.\n      at.on('secure', function(msg){ this.off();\n        if(!at.opt.secure){ return eve.to.next(msg) }\n        no(\"Data cannot be changed.\");\n      }).on.on('secure', msg);\n      return;\n    }\n    var link_is = Gun.val.link.is, state_ify = Gun.state.ify;\n\n    // okay! The security function handles all the heavy lifting.\n    // It needs to deal read and write of input and output of system data, account/public key data, and regular data.\n    // This is broken down into some pretty clear edge cases, let's go over them:\n    function security(msg){\n      var at = this.as, sea = at.sea, to = this.to;\n      if(at.opt.faith && (msg._||noop).faith){ // you probably shouldn't have faith in this!\n        this.to.next(msg); // why do we allow skipping security? I'm very scared about it actually.\n        return; // but so that way storage adapters that already verified something can get performance boost. This was a community requested feature. If anybody finds an exploit with it, please report immediately. It should only be exploitable if you have XSS control anyways, which if you do, you can bypass security regardless of this.\n      }\n      if(msg.get){\n        // if there is a request to read data from us, then...\n        var soul = msg.get['#'];\n        if(soul){ // for now, only allow direct IDs to be read.\n          if(typeof soul !== 'string'){ return to.next(msg) } // do not handle lexical cursors.\n          if('alias' === soul){ // Allow reading the list of usernames/aliases in the system?\n            return to.next(msg); // yes.\n          } else\n          if('~@' === soul.slice(0,2)){ // Allow reading the list of public keys associated with an alias?\n            return to.next(msg); // yes.\n          } else { // Allow reading everything?\n            return to.next(msg); // yes // TODO: No! Make this a callback/event that people can filter on.\n          }\n        }\n      }\n      if(msg.put){\n        /*\n          NOTICE: THIS IS OLD AND GETTING DEPRECATED.\n          ANY SECURITY CHANGES SHOULD HAPPEN ABOVE FIRST\n          THEN PORTED TO HERE.\n        */\n        // potentially parallel async operations!!!\n        var check = {}, each = {}, u;\n        each.node = function(node, soul){\n          if(Gun.obj.empty(node, '_')){ return check['node'+soul] = 0 } // ignore empty updates, don't reject them.\n          Gun.obj.map(node, each.way, {soul: soul, node: node});\n        };\n        each.way = function(val, key){\n          var soul = this.soul, node = this.node, tmp;\n          if('_' === key){ return } // ignore meta data\n          if('~@' === soul){  // special case for shared system data, the list of aliases.\n            each.alias(val, key, node, soul); return;\n          }\n          if('~@' === soul.slice(0,2)){ // special case for shared system data, the list of public keys for an alias.\n            each.pubs(val, key, node, soul); return;\n          }\n          if('~' === soul.slice(0,1) && 2 === (tmp = soul.slice(1)).split('.').length){ // special case, account data for a public key.\n            each.pub(val, key, node, soul, tmp, (msg._||noop).user); return;\n          }\n          each.any(val, key, node, soul, (msg._||noop).user); return;\n          return each.end({err: \"No other data allowed!\"});\n        };\n        each.alias = function(val, key, node, soul){ // Example: {_:#~@, ~@alice: {#~@alice}}\n          if(!val){ return each.end({err: \"Data must exist!\"}) } // data MUST exist\n          if('~@'+key === Gun.val.link.is(val)){ return check['alias'+key] = 0 } // in fact, it must be EXACTLY equal to itself\n          each.end({err: \"Mismatching alias.\"}); // if it isn't, reject.\n        };\n        each.pubs = function(val, key, node, soul){ // Example: {_:#~@alice, ~asdf: {#~asdf}}\n          if(!val){ return each.end({err: \"Alias must exist!\"}) } // data MUST exist\n          if(key === Gun.val.link.is(val)){ return check['pubs'+soul+key] = 0 } // and the ID must be EXACTLY equal to its property\n          each.end({err: \"Alias must match!\"}); // that way nobody can tamper with the list of public keys.\n        };\n        each.pub = function(val, key, node, soul, pub, user){ var tmp; // Example: {_:#~asdf, hello:'world'~fdsa}}\n          if('pub' === key){\n            if(val === pub){ return (check['pub'+soul+key] = 0) } // the account MUST match `pub` property that equals the ID of the public key.\n            return each.end({err: \"Account must match!\"});\n          }\n          check['user'+soul+key] = 1;\n          if(Gun.is(msg.$) && user && user.is && pub === user.is.pub){\n            SEA.sign(SEA.opt.prep(tmp = SEA.opt.parse(val), key, node, soul), (user._).sea, function(data){ var rel;\n              if(u === data){ return each.end({err: SEA.err || 'Pub signature fail.'}) }\n              if(rel = Gun.val.link.is(val)){\n                (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n              }\n              node[key] = JSON.stringify({':': SEA.opt.unpack(data.m), '~': data.s});\n              check['user'+soul+key] = 0;\n              each.end({ok: 1});\n            }, {check: SEA.opt.pack(tmp, key, node, soul), raw: 1});\n            return;\n          }\n          SEA.verify(SEA.opt.pack(val,key,node,soul), pub, function(data){ var rel, tmp;\n            data = SEA.opt.unpack(data, key, node);\n            if(u === data){ // make sure the signature matches the account it claims to be on.\n              return each.end({err: \"Unverified data.\"}); // reject any updates that are signed with a mismatched account.\n            }\n            if((rel = Gun.val.link.is(data)) && pub === SEA.opt.pub(rel)){\n              (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n            }\n            check['user'+soul+key] = 0;\n            each.end({ok: 1});\n          });\n        };\n        each.any = function(val, key, node, soul, user){ var tmp, pub;\n          if(!(pub = SEA.opt.pub(soul))){\n            if(at.opt.secure){\n              each.end({err: \"Soul is missing public key at '\" + key + \"'.\"});\n              return;\n            }\n            // TODO: Ask community if should auto-sign non user-graph data.\n            check['any'+soul+key] = 1;\n            at.on('secure', function(msg){ this.off();\n              check['any'+soul+key] = 0;\n              if(at.opt.secure){ msg = null }\n              each.end(msg || {err: \"Data cannot be modified.\"});\n            }).on.on('secure', msg);\n            //each.end({err: \"Data cannot be modified.\"});\n            return;\n          }\n          if(Gun.is(msg.$) && user && user.is && pub === user.is.pub){\n            /*var other = Gun.obj.map(at.sea.own[soul], function(v, p){\n              if((user.is||{}).pub !== p){ return p }\n            });\n            if(other){\n              each.any(val, key, node, soul);\n              return;\n            }*/\n            check['any'+soul+key] = 1;\n            SEA.sign(SEA.opt.prep(tmp = SEA.opt.parse(val), key, node, soul), (user._).sea, function(data){\n              if(u === data){ return each.end({err: 'My signature fail.'}) }\n              node[key] = JSON.stringify({':': SEA.opt.unpack(data.m), '~': data.s});\n              check['any'+soul+key] = 0;\n              each.end({ok: 1});\n            }, {check: SEA.opt.pack(tmp, key, node, soul), raw: 1});\n            return;\n          }\n          check['any'+soul+key] = 1;\n          SEA.verify(SEA.opt.pack(val,key,node,soul), pub, function(data){ var rel;\n            data = SEA.opt.unpack(data, key, node);\n            if(u === data){ return each.end({err: \"Mismatched owner on '\" + key + \"'.\"}) } // thanks @rogowski !\n            if((rel = Gun.val.link.is(data)) && pub === SEA.opt.pub(rel)){\n              (at.sea.own[rel] = at.sea.own[rel] || {})[pub] = true;\n            }\n            check['any'+soul+key] = 0;\n            each.end({ok: 1});\n          });\n        }\n        each.end = function(ctx){ // TODO: Can't you just switch this to each.end = cb?\n          if(each.err){ return }\n          if((each.err = ctx.err) || ctx.no){\n            console.log('NO!', each.err, msg.put); // 451 mistmached data FOR MARTTI\n            return;\n          }\n          if(!each.end.ed){ return }\n          if(Gun.obj.map(check, function(no){\n            if(no){ return true }\n          })){ return }\n          (msg._||{}).user = at.user || security; // already been through firewall, does not need to again on out.\n          to.next(msg);\n        };\n        Gun.obj.map(msg.put, each.node);\n        each.end({end: each.end.ed = true});\n        return; // need to manually call next after async.\n      }\n      to.next(msg); // pass forward any data we do not know how to handle or process (this allows custom security protocols).\n    }\n    var pubcut = /[^\\w_-]/; // anything not alphanumeric or _ -\n    SEA.opt.pub = function(s){\n      if(!s){ return }\n      s = s.split('~');\n      if(!s || !(s = s[1])){ return }\n      s = s.split(pubcut).slice(0,2);\n      if(!s || 2 != s.length){ return }\n      if('@' === (s[0]||'')[0]){ return }\n      s = s.slice(0,2).join('.');\n      return s;\n    }\n    SEA.opt.prep = function(d,k, n,s){ // prep for signing\n      return {'#':s,'.':k,':':SEA.opt.parse(d),'>':Gun.state.is(n, k)};\n    }\n    SEA.opt.pack = function(d,k, n,s){ // pack for verifying\n      if(SEA.opt.check(d)){ return d }\n      var meta = (Gun.obj.ify((d && d[':'])||d)||''), sig = meta['~'];\n      return sig? {m: {'#':s||d['#'],'.':k||d['.'],':':meta[':'],'>':d['>']||Gun.state.is(n, k)}, s: sig} : d;\n    }\n    var O = SEA.opt;\n    SEA.opt.unpack = function(d, k, n){ var tmp;\n      if(u === d){ return }\n      if(d && (u !== (tmp = d[':']))){ return tmp }\n      k = k || O.fall_key; if(!n && O.fall_val){ n = {}; n[k] = O.fall_val }\n      if(!k || !n){ return }\n      if(d === n[k]){ return d }\n      if(!SEA.opt.check(n[k])){ return d }\n      var soul = Gun.node.soul(n) || O.fall_soul, s = Gun.state.is(n, k) || O.fall_state;\n      if(d && 4 === d.length && soul === d[0] && k === d[1] && fl(s) === fl(d[3])){\n        return d[2];\n      }\n      if(s < SEA.opt.shuffle_attack){\n        return d;\n      }\n    }\n    SEA.opt.shuffle_attack = 1546329600000; // Jan 1, 2019\n    var noop = function(){}, u;\n    var fl = Math.floor; // TODO: Still need to fix inconsistent state issue.\n    var rel_is = Gun.val.rel.is;\n    var obj_ify = Gun.obj.ify;\n    // TODO: Potential bug? If pub/priv key starts with `-`? IDK how possible.\n\n  })(USE, './index');\n}());\n"]},"metadata":{},"sourceType":"script"}