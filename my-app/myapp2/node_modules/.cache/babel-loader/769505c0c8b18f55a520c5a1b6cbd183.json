{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.default = financeDiscontinuousScale;\n\nvar _d3Collection = require(\"d3-collection\");\n\nvar _d3Array = require(\"d3-array\");\n\nvar _d3Scale = require(\"d3-scale\");\n\nvar _utils = require(\"../utils\");\n\nvar _levels = require(\"./levels\");\n\nvar MAX_LEVEL = _levels.levelDefinition.length - 1;\n\nfunction financeDiscontinuousScale(index, futureProvider) {\n  var backingLinearScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _d3Scale.scaleLinear)();\n  if ((0, _utils.isNotDefined)(index)) throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n\n  scale.invert = function (x) {\n    var inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n\n  scale.ticks = function (m, flexTicks) {\n    var backingTicks = backingLinearScale.ticks(m);\n    var ticksMap = (0, _d3Collection.map)();\n\n    var _backingLinearScale$d = backingLinearScale.domain(),\n        _backingLinearScale$d2 = _slicedToArray(_backingLinearScale$d, 2),\n        domainStart = _backingLinearScale$d2[0],\n        domainEnd = _backingLinearScale$d2[1];\n\n    var start = Math.max(Math.ceil(domainStart), (0, _utils.head)(index).index) + Math.abs((0, _utils.head)(index).index);\n    var end = Math.min(Math.floor(domainEnd), (0, _utils.last)(index).index) + Math.abs((0, _utils.head)(index).index);\n\n    if (Math.floor(domainEnd) > end) {// console.log(end, domainEnd, index);\n    }\n\n    var desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n    for (var i = MAX_LEVEL; i >= 0; i--) {\n      var ticksAtLevel = ticksMap.get(i);\n      var temp = (0, _utils.isNotDefined)(ticksAtLevel) ? [] : ticksAtLevel.slice();\n\n      for (var j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n\n      ticksMap.set(i, temp);\n    }\n\n    var unsortedTicks = [];\n\n    for (var _i = MAX_LEVEL; _i >= 0; _i--) {\n      if (ticksMap.get(_i).length + unsortedTicks.length > desiredTickCount * 1.5) break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(_i).map(function (d) {\n        return d.index;\n      }));\n    }\n\n    var ticks = unsortedTicks.sort(_d3Array.ascending); // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      var ticksSet = (0, _d3Collection.set)(ticks);\n      var d = Math.abs((0, _utils.head)(index).index); // ignore ticks within this distance\n\n      var distance = Math.ceil((backingTicks.length > 0 ? ((0, _utils.last)(backingTicks) - (0, _utils.head)(backingTicks)) / backingTicks.length / 4 : 1) * 1.5);\n\n      for (var _i2 = 0; _i2 < ticks.length - 1; _i2++) {\n        for (var _j = _i2 + 1; _j < ticks.length; _j++) {\n          if (ticks[_j] - ticks[_i2] <= distance) {\n            ticksSet.remove(index[ticks[_i2] + d].level >= index[ticks[_j] + d].level ? ticks[_j] : ticks[_i2]);\n          }\n        }\n      }\n\n      var tickValues = ticksSet.values().map(function (d) {\n        return parseInt(d, 10);\n      }); // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n\n    return ticks;\n  };\n\n  scale.tickFormat = function () {\n    return function (x) {\n      var d = Math.abs((0, _utils.head)(index).index);\n      var _index$Math$floor = index[Math.floor(x + d)],\n          format = _index$Math$floor.format,\n          date = _index$Math$floor.date;\n      return format(date);\n    };\n  };\n\n  scale.value = function (x) {\n    var d = Math.abs((0, _utils.head)(index).index);\n\n    if ((0, _utils.isDefined)(index[Math.floor(x + d)])) {\n      var date = index[Math.floor(x + d)].date;\n      return date;\n    }\n  };\n\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n\n  scale.copy = function () {\n    return financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n  };\n\n  return scale;\n}","map":{"version":3,"sources":["../../../src/lib/scale/financeDiscontinuousScale.js"],"names":["MAX_LEVEL","financeDiscontinuousScale","backingLinearScale","scale","inverted","Math","arguments","backingTicks","ticksMap","domainStart","domainEnd","start","end","desiredTickCount","i","ticksAtLevel","temp","j","index","unsortedTicks","d","ticks","ticksSet","distance","tickValues","parseInt","format","date","x"],"mappings":"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","sourcesContent":["\n\nimport { set, map } from \"d3-collection\";\nimport { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\n\nimport { isDefined, isNotDefined, head, last } from \"../utils\";\nimport { levelDefinition } from \"./levels\";\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n\tindex,\n\tfutureProvider,\n\tbackingLinearScale = scaleLinear()\n) {\n\n\tif (isNotDefined(index))\n\t\tthrow new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n\n\tfunction scale(x) {\n\t\treturn backingLinearScale(x);\n\t}\n\tscale.invert = function(x) {\n\t\tconst inverted = backingLinearScale.invert(x);\n\t\treturn Math.round(inverted * 10000) / 10000;\n\t};\n\tscale.domain = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.domain();\n\t\tbackingLinearScale.domain(x);\n\t\treturn scale;\n\t};\n\tscale.range = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.range();\n\t\tbackingLinearScale.range(x);\n\t\treturn scale;\n\t};\n\tscale.rangeRound = function(x) {\n\t\treturn backingLinearScale.range(x);\n\t};\n\tscale.clamp = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.clamp();\n\t\tbackingLinearScale.clamp(x);\n\t\treturn scale;\n\t};\n\tscale.interpolate = function(x) {\n\t\tif (!arguments.length) return backingLinearScale.interpolate();\n\t\tbackingLinearScale.interpolate(x);\n\t\treturn scale;\n\t};\n\tscale.ticks = function(m, flexTicks) {\n\t\tconst backingTicks = backingLinearScale.ticks(m);\n\t\tconst ticksMap = map();\n\n\t\tconst [domainStart, domainEnd] = backingLinearScale.domain();\n\n\t\tconst start = Math.max(Math.ceil(domainStart), head(index).index) + Math.abs(head(index).index);\n\t\tconst end = Math.min(Math.floor(domainEnd), last(index).index) + Math.abs(head(index).index);\n\n\t\tif (Math.floor(domainEnd) > end) {\n\t\t\t// console.log(end, domainEnd, index);\n\t\t}\n\n\t\tconst desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tconst ticksAtLevel = ticksMap.get(i);\n\t\t\tconst temp = isNotDefined(ticksAtLevel)\n\t\t\t\t? []\n\t\t\t\t: ticksAtLevel.slice();\n\n\t\t\tfor (let j = start; j <= end; j++) {\n\t\t\t\tif (index[j].level === i) {\n\t\t\t\t\ttemp.push(index[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tticksMap.set(i, temp);\n\t\t}\n\n\t\tlet unsortedTicks = [];\n\t\tfor (let i = MAX_LEVEL; i >= 0; i--) {\n\t\t\tif ((ticksMap.get(i).length + unsortedTicks.length) > desiredTickCount * 1.5) break;\n\t\t\tunsortedTicks = unsortedTicks.concat(ticksMap.get(i).map(d => d.index));\n\t\t}\n\n\t\tconst ticks = unsortedTicks.sort(ascending);\n\n\t\t// console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n\t\tif (!flexTicks && end - start > ticks.length) {\n\t\t\tconst ticksSet = set(ticks);\n\n\t\t\tconst d = Math.abs(head(index).index);\n\n\t\t\t// ignore ticks within this distance\n\t\t\tconst distance = Math.ceil(\n\t\t\t\t(backingTicks.length > 0\n\t\t\t\t\t? (last(backingTicks) - head(backingTicks)) / (backingTicks.length) / 4\n\t\t\t\t\t: 1) * 1.5);\n\n\t\t\tfor (let i = 0; i < ticks.length - 1; i++) {\n\t\t\t\tfor (let j = i + 1; j < ticks.length; j++) {\n\t\t\t\t\tif (ticks[j] - ticks[i] <= distance) {\n\t\t\t\t\t\tticksSet.remove(index[ticks[i] + d].level >= index[ticks[j] + d].level ? ticks[j] : ticks[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst tickValues = ticksSet.values().map(d => parseInt(d, 10));\n\n\t\t\t// console.log(ticks.length, tickValues, level);\n\t\t\t// console.log(ticks, tickValues, distance);\n\n\t\t\treturn tickValues;\n\t\t}\n\n\t\treturn ticks;\n\t};\n\tscale.tickFormat = function() {\n\t\treturn function(x) {\n\t\t\tconst d = Math.abs(head(index).index);\n\t\t\tconst { format, date } = index[Math.floor(x + d)];\n\t\t\treturn format(date);\n\t\t};\n\t};\n\tscale.value = function(x) {\n\t\tconst d = Math.abs(head(index).index);\n\t\tif (isDefined(index[Math.floor(x + d)])) {\n\t\t\tconst { date } = index[Math.floor(x + d)];\n\t\t\treturn date;\n\t\t}\n\t};\n\tscale.nice = function(m) {\n\t\tbackingLinearScale.nice(m);\n\t\treturn scale;\n\t};\n\tscale.index = function(x) {\n\t\tif (!arguments.length) return index;\n\t\tindex = x;\n\t\treturn scale;\n\t};\n\tscale.copy = function() {\n\t\treturn financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n\t};\n\treturn scale;\n}"]},"metadata":{},"sourceType":"script"}