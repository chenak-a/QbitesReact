{"ast":null,"code":"import { GraphQLError as e } from \"graphql/error/GraphQLError.mjs\";\nimport { Kind as r } from \"graphql/language/kinds.mjs\";\nimport { parse as t } from \"graphql/language/parser.mjs\";\nimport { print as n } from \"graphql/language/printer.mjs\";\nimport { make as o } from \"wonka\";\n\nfunction rehydrateGraphQlError(r) {\n  if (\"string\" == typeof r) {\n    return new e(r);\n  } else if (\"object\" == typeof r && r.message) {\n    return new e(r.message, r.nodes, r.source, r.positions, r.path, r, r.extensions || {});\n  } else {\n    return r;\n  }\n}\n\nvar i = function (e) {\n  function CombinedError(r) {\n    var t = r.networkError;\n    var n = r.response;\n    var o = (r.graphQLErrors || []).map(rehydrateGraphQlError);\n\n    var i = function generateErrorMessage(e, r) {\n      var t = \"\";\n\n      if (void 0 !== e) {\n        return t = \"[Network] \" + e.message;\n      }\n\n      if (void 0 !== r) {\n        r.forEach(function (e) {\n          t += \"[GraphQL] \" + e.message + \"\\n\";\n        });\n      }\n\n      return t.trim();\n    }(t, o);\n\n    e.call(this, i);\n    this.name = \"CombinedError\";\n    this.message = i;\n    this.graphQLErrors = o;\n    this.networkError = t;\n    this.response = n;\n  }\n\n  if (e) {\n    CombinedError.__proto__ = e;\n  }\n\n  (CombinedError.prototype = Object.create(e && e.prototype)).constructor = CombinedError;\n\n  CombinedError.prototype.toString = function toString() {\n    return this.message;\n  };\n\n  return CombinedError;\n}(Error);\n\nfunction phash(e, r) {\n  e |= 0;\n\n  for (var t = 0, n = 0 | r.length; t < n; t++) {\n    e = (e << 5) + e + r.charCodeAt(t);\n  }\n\n  return e;\n}\n\nfunction hash(e) {\n  return phash(5381, e) >>> 0;\n}\n\nvar a = new Set();\nvar s = new WeakMap();\n\nfunction stringify(e) {\n  if (null === e || a.has(e)) {\n    return \"null\";\n  } else if (\"object\" != typeof e) {\n    return JSON.stringify(e) || \"\";\n  } else if (e.toJSON) {\n    return stringify(e.toJSON());\n  } else if (Array.isArray(e)) {\n    var r = \"[\";\n\n    for (var t = 0, n = e.length; t < n; t++) {\n      if (t > 0) {\n        r += \",\";\n      }\n\n      var o = stringify(e[t]);\n      r += o.length > 0 ? o : \"null\";\n    }\n\n    return r += \"]\";\n  }\n\n  var i = Object.keys(e).sort();\n\n  if (!i.length && e.constructor && e.constructor !== Object) {\n    var u = s.get(e) || Math.random().toString(36).slice(2);\n    s.set(e, u);\n    return '{\"__key\":\"' + u + '\"}';\n  }\n\n  a.add(e);\n  var f = \"{\";\n\n  for (var c = 0, l = i.length; c < l; c++) {\n    var p = i[c];\n    var h = stringify(e[p]);\n\n    if (h) {\n      if (f.length > 1) {\n        f += \",\";\n      }\n\n      f += stringify(p) + \":\" + h;\n    }\n  }\n\n  a.delete(e);\n  return f += \"}\";\n}\n\nfunction stringifyVariables(e) {\n  a.clear();\n  return stringify(e);\n}\n\nfunction stringifyDocument(e) {\n  var r = (\"string\" != typeof e ? e.loc && e.loc.source.body || n(e) : e).replace(/([\\s,]|#[^\\n\\r]+)+/g, \" \").trim();\n\n  if (\"string\" != typeof e) {\n    var t = \"definitions\" in e && getOperationName(e);\n\n    if (t) {\n      r = \"# \" + t + \"\\n\" + r;\n    }\n\n    if (!e.loc) {\n      e.loc = {\n        start: 0,\n        end: r.length,\n        source: {\n          body: r,\n          name: \"gql\",\n          locationOffset: {\n            line: 1,\n            column: 1\n          }\n        }\n      };\n    }\n  }\n\n  return r;\n}\n\nvar u = new Map();\n\nfunction keyDocument(e) {\n  var r;\n  var n;\n\n  if (\"string\" == typeof e) {\n    r = hash(stringifyDocument(e));\n    n = u.get(r) || t(e, {\n      noLocation: !0\n    });\n  } else {\n    r = e.__key || hash(stringifyDocument(e));\n    n = u.get(r) || e;\n  }\n\n  if (!n.loc) {\n    stringifyDocument(n);\n  }\n\n  n.__key = r;\n  u.set(r, n);\n  return n;\n}\n\nfunction createRequest(e, r) {\n  if (!r) {\n    r = {};\n  }\n\n  var t = keyDocument(e);\n  return {\n    key: phash(t.__key, stringifyVariables(r)) >>> 0,\n    query: t,\n    variables: r\n  };\n}\n\nfunction getOperationName(e) {\n  for (var t = 0, n = e.definitions.length; t < n; t++) {\n    var o = e.definitions[t];\n\n    if (o.kind === r.OPERATION_DEFINITION && o.name) {\n      return o.name.value;\n    }\n  }\n}\n\nfunction makeResult(e, r, t) {\n  return {\n    operation: e,\n    data: r.data,\n    error: Array.isArray(r.errors) ? new i({\n      graphQLErrors: r.errors,\n      response: t\n    }) : void 0,\n    extensions: \"object\" == typeof r.extensions && r.extensions || void 0\n  };\n}\n\nfunction makeErrorResult(e, r, t) {\n  return {\n    operation: e,\n    data: void 0,\n    error: new i({\n      networkError: r,\n      response: t\n    }),\n    extensions: void 0\n  };\n}\n\nfunction _extends() {\n  return (_extends = Object.assign || function (e) {\n    for (var r = 1; r < arguments.length; r++) {\n      var t = arguments[r];\n\n      for (var n in t) {\n        if (Object.prototype.hasOwnProperty.call(t, n)) {\n          e[n] = t[n];\n        }\n      }\n    }\n\n    return e;\n  }).apply(this, arguments);\n}\n\nfunction shouldUseGet(e) {\n  return \"query\" === e.kind && !!e.context.preferGetMethod;\n}\n\nfunction makeFetchBody(e) {\n  return {\n    query: n(e.query),\n    operationName: getOperationName(e.query),\n    variables: e.variables || void 0,\n    extensions: void 0\n  };\n}\n\nfunction makeFetchURL(e, r) {\n  var t = shouldUseGet(e);\n  var n = e.context.url;\n\n  if (!t || !r) {\n    return n;\n  }\n\n  var o = [];\n\n  if (r.operationName) {\n    o.push(\"operationName=\" + encodeURIComponent(r.operationName));\n  }\n\n  if (r.query) {\n    o.push(\"query=\" + encodeURIComponent(r.query.replace(/([\\s,]|#[^\\n\\r]+)+/g, \" \").trim()));\n  }\n\n  if (r.variables) {\n    o.push(\"variables=\" + encodeURIComponent(stringifyVariables(r.variables)));\n  }\n\n  if (r.extensions) {\n    o.push(\"extensions=\" + encodeURIComponent(stringifyVariables(r.extensions)));\n  }\n\n  return n + \"?\" + o.join(\"&\");\n}\n\nfunction makeFetchOptions(e, r) {\n  var t = shouldUseGet(e);\n  var n = \"function\" == typeof e.context.fetchOptions ? e.context.fetchOptions() : e.context.fetchOptions || {};\n  return _extends({}, n, {\n    body: !t && r ? JSON.stringify(r) : void 0,\n    method: t ? \"GET\" : \"POST\",\n    headers: t ? n.headers : _extends({}, {\n      \"content-type\": \"application/json\"\n    }, n.headers)\n  });\n}\n\nfunction makeFetchSource(e, r, t) {\n  return o(function (n) {\n    var o = n.next;\n    var i = n.complete;\n    var a = \"undefined\" != typeof AbortController ? new AbortController() : null;\n    var s = !1;\n    Promise.resolve().then(function () {\n      if (s) {\n        return;\n      } else if (a) {\n        t.signal = a.signal;\n      }\n\n      return function executeFetch(e, r, t) {\n        var n = !1;\n        var o;\n        return (e.context.fetch || fetch)(r, t).then(function (e) {\n          o = e;\n          n = e.status < 200 || e.status >= (\"manual\" === t.redirect ? 400 : 300);\n          return e.json();\n        }).then(function (r) {\n          if (!(\"data\" in r) && !(\"errors\" in r)) {\n            throw new Error(\"No Content\");\n          }\n\n          return makeResult(e, r, o);\n        }).catch(function (r) {\n          if (\"AbortError\" !== r.name) {\n            return makeErrorResult(e, n ? new Error(o.statusText) : r, o);\n          }\n        });\n      }(e, r, t);\n    }).then(function (e) {\n      if (!s) {\n        s = !0;\n\n        if (e) {\n          o(e);\n        }\n\n        i();\n      }\n    });\n    return function () {\n      s = !0;\n\n      if (a) {\n        a.abort();\n      }\n    };\n  });\n}\n\nexport { i as C, _extends as _, makeErrorResult as a, makeFetchBody as b, makeFetchURL as c, makeFetchOptions as d, makeFetchSource as e, createRequest as f, stringifyVariables as g, getOperationName as h, keyDocument as k, makeResult as m, stringifyDocument as s };","map":{"version":3,"sources":["../src/utils/error.ts","../src/utils/hash.ts","../src/utils/stringifyVariables.ts","../src/utils/request.ts","../src/utils/result.ts","../src/internal/fetchOptions.ts","../src/internal/fetchSource.ts"],"names":["generateErrorMessage","rehydrateGraphQlError","message","super","response","h","const","hash","stringify","seen","x","let","i","Array","out","l$1","stringifyDocument","loc","key","noLocation","q","data","node","makeFetchBody","search","extensions","encodeURIComponent","useGETMethod","headers","push","stringifyVariables","executeFetch","fetcher","fetch","statusNotOk","extraOptions","result","url","AbortController","Promise","ended","next","complete"],"mappings":";;;kBAEMA,C,QAAAA,8B;;;AAqBH,SAAMC,qBAAN,CAAMA,CAAN,EAAMA;;;;;;;;;;;;QAmCCC,CAAAA,GAAAA,CAAAA,CAAAA,Y;;eAENC,a,IAAAA,E,EAAAA,G,CAAAA,qB;;YArDF,SAAA,oBAAA,CAAA,CAAA,EAAA,CAAA,EAAA;;;;;;;;;;;;;aAaIF,CAAAA,CAAAA,IAAAA,E;KAbJ,C,CAAA,E,CAAA,C;;iBA0DEC,C;SACKE,I,GAAAA,e;;;;;;;;;;;iBAIOF,S,GAAAA,MAAAA,CAAAA,MAAAA,CAAAA,CAAAA,IAAAA,CAAAA,CAAAA,SAAAA,C,EAAAA,W,GAAAA,a;;;;;;;;;AChEZG,SAAKA,KAALA,CAAIA,CAAJA,EAAIA,CAAJA,EAAIA;;;;;;;;;;ACLRC,SAAWC,IAAXD,CAAWC,CAAXD,EAAWC;;;;AAIP,IAAA,CAAA,GAAO,IAAA,GAAA,EAAP;AACD,IAAA,CAAA,GAAA,IAAA,OAAA,EAAA;;AAEA,SAAMC,SAAN,CAAMA,CAAN,EAAMA;oBACWC,CAAAA,CAAAA,GAAAA,CAACC,CAADD,C,EAACC;;;;SAGZC,IAAIC,CAAAA,CAAAA,MAAJD,EAAIC;WACFJ,SAAAA,CAAAA,CAAAA,CAAAA,MAAAA,EAAAA,C;GADFG,M,IACWE,KAAAA,CAAAA,OAAAA,CAAAA,CAAAA,C,EAAAA;;;;AAEdC,UAAAA,CAAAA,GAAAA,CAAAA,EAAAA;;;;;;;;;;;;;;;;;;;;;;kBAoBIC,CAAAA,GAAAA,CAAAA,CAAAA,M,EAAAA,CAAAA,GAAAA,C,EAAAA,CAAAA,E,EAAAA;QAAgBD,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,C;;;;;;;;;;;;;SAWxBL,CAAAA,IAAAA,G;;;SCvBWO,kB,CAAAA,C,EAAAA;;;;;;;;;;;;;;;WAqBCC,G,EAAAA;;;;;;;;;;;;;;;;;;;AAiBVC,IAAAA,CAAAA,GAAAA,IAAWF,GAAXE,EAAAA;;AACoCC,SAAAA,WAAAA,CAAAA,CAAAA,EAAAA;MAApCD,C;;;4BAGyBE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxD3BC,QAAIC,CAAAA,CAAAA,IAAAA,KAAAA,CAAAA,CAAAA,oBAAAA,IAAAA,CAAAA,CAAAA,IAAJD,EAAIC;;;;;;AAFiB,SAAA,UAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA;;;;;;;;;;;;AAyBrB,SAAA,eAAA,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbgB,SAAA,YAAA,CAAA,CAAA,EAAA;;;;AAYhBhB,SAASiB,aAATjB,CAASiB,CAATjB,EAASiB;;;;;;;;;AAKPC,SAAAA,YAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA;;;;;;;;UAaA,E;;;MAKOC,I,CAAAA,mBAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,aAAAA,C;;;;sBAMcC,kBAAAA,CAAAA,CAAAA,CAAAA,KAAAA,CAAAA,OAAAA,CAAAA,qBAAAA,EAAAA,GAAAA,EAAAA,IAAAA,EAAAA,C;;;MAOjBC,CAAAA,CAAAA,S,EAAAA;;;;;AAWJC,IAAAA,CAAAA,CAAOC,IAAPD,CAAOC,gBAAAA,kBAAAA,CAEHC,kBAAAA,CAAAA,CAAAA,CAAAA,UAAAA,CAFGD,CAAPD;;;;;;SC1EEG,gB,CAAAA,C,EAAAA,C,EAAAA;MAKEC,CAAAA,GAAAA,YAAAA,CAA4BC,CAA5BD,C;MAEFE,CAAAA,GAAAA,cAAAA,OAAAA,CAAAA,CAAAA,OAAAA,CAAAA,YAAAA,GAAAA,CAAAA,CAAAA,OAAAA,CAAAA,YAAAA,EAAAA,GAAAA,CAAAA,CAAAA,OAAAA,CAAAA,YAAAA,IAAAA,E;;;AAKA9B,IAAAA,MAAAA,EAAQuB,CAAAA,GAAAA,KAAAA,GAAAA,M;AACRO,IAAAA,OAAAA,EAAAA,CAAAA,GACEC,CAAAA,CACGP,OAFLM,GAEKN,QAAAA,CAAAA,EAAAA,EAAAA;;AAAAA,KAAAA,E,EAGAQ,OAHAR;;;;;;;;QA4CDY,CAAAA,GAAAA,eAAAA,OAAAA,eAAAA,GAAAA,IAAAA,eAAAA,EAAAA,GAAAA,I;;YACIJ,O,GAAAA,I,CAAAA,YAAAA;UAAQK,C,EAAAA;;;AACZC,QAAAA,CAAAA,CAAAA,MAAAA,GAAAA,CAAAA,CAAAA,MAAAA;;;;;;0CAlCoBL,C,EAAAA,C,EAAAA,I,CAAAA,UAAAA,CAAAA,EAAAA;;AAjB5BH,UAAAA,CAAAA,GAAAA,CAAAA,CAAAA,MAAAA,GAAAA,GAAAA,IAAAA,CAAAA,CAAAA,MAAAA,KAAAA,aAAAA,CAAAA,CAAAA,QAAAA,GAAAA,GAAAA,GAAAA,GAAAA,CAAAA;;;;;;;+BAiCWI,C,EAAAA,C;2BAET3B,C,EAAAA;AAEA4B,cAAAA,iBAAAA,CAAAA,CAAAA,IAAAA,EAAAA","sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  Location,\n  DefinitionNode,\n  DocumentNode,\n  Kind,\n  parse,\n  print,\n} from 'graphql';\n\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest } from '../types';\n\ninterface WritableLocation {\n  loc: Location | undefined;\n}\n\nexport interface KeyedDocumentNode extends DocumentNode {\n  __key: number;\n}\n\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let str = (typeof node !== 'string'\n    ? (node.loc && node.loc.source.body) || print(node)\n    : node\n  )\n    .replace(/([\\s,]|#[^\\n\\r]+)+/g, ' ')\n    .trim();\n\n  if (typeof node !== 'string') {\n    const operationName = 'definitions' in node && getOperationName(node);\n    if (operationName) {\n      str = `# ${operationName}\\n${str}`;\n    }\n\n    if (!node.loc) {\n      (node as WritableLocation).loc = {\n        start: 0,\n        end: str.length,\n        source: {\n          body: str,\n          name: 'gql',\n          locationOffset: { line: 1, column: 1 },\n        },\n      } as Location;\n    }\n  }\n\n  return str;\n};\n\nconst docs = new Map<number, KeyedDocumentNode>();\n\nexport const keyDocument = (q: string | DocumentNode): KeyedDocumentNode => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hash(stringifyDocument(q));\n    query = docs.get(key) || parse(q, { noLocation: true });\n  } else {\n    key = (q as KeyedDocumentNode).__key || hash(stringifyDocument(q));\n    query = docs.get(key) || q;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\nexport const createRequest = <Data = any, Variables = object>(\n  q: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  vars?: Variables\n): GraphQLRequest<Data, Variables> => {\n  if (!vars) vars = {} as Variables;\n  const query = keyDocument(q);\n  return {\n    key: phash(query.__key, stringifyVariables(vars)) >>> 0,\n    query,\n    variables: vars,\n  };\n};\n\n/**\n * Finds the Name value from the OperationDefinition of a Document\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { DocumentNode, print } from 'graphql';\n\nimport { getOperationName, stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return operation.kind === 'query' && !!operation.context.preferGetMethod;\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  const url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  const search: string[] = [];\n  if (body.operationName) {\n    search.push('operationName=' + encodeURIComponent(body.operationName));\n  }\n\n  if (body.query) {\n    search.push(\n      'query=' +\n        encodeURIComponent(\n          body.query.replace(/([\\s,]|#[^\\n\\r]+)+/g, ' ').trim()\n        )\n    );\n  }\n\n  if (body.variables) {\n    search.push(\n      'variables=' + encodeURIComponent(stringifyVariables(body.variables))\n    );\n  }\n\n  if (body.extensions) {\n    search.push(\n      'extensions=' + encodeURIComponent(stringifyVariables(body.extensions))\n    );\n  }\n\n  return `${url}?${search.join('&')}`;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: useGETMethod\n      ? extraOptions.headers\n      : { 'content-type': 'application/json', ...extraOptions.headers },\n  };\n};\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n"]},"metadata":{},"sourceType":"module"}